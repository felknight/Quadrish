# 1 "../Quadris/Font.cpp"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "../Quadris/Font.cpp"
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cassert" 1
# 41 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cassert"
       
# 42 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cassert" 3

# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/assert.h" 1 3
# 45 "C:\\ndk/platforms/android-9/arch-arm/usr/include/assert.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/cdefs.h" 1 3
# 59 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/cdefs.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/cdefs_elf.h" 1 3
# 60 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/cdefs.h" 2 3
# 500 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/cdefs.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/android/api-level.h" 1 3
# 501 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/cdefs.h" 2 3
# 46 "C:\\ndk/platforms/android-9/arch-arm/usr/include/assert.h" 2 3
# 62 "C:\\ndk/platforms/android-9/arch-arm/usr/include/assert.h" 3
extern "C" {
 void __assert(const char *, int, const char *);
 void __assert2(const char *, int, const char *, const char *);
}
# 43 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cassert" 2 3
# 2 "../Quadris/Font.cpp" 2
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 1
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath"
       
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 3

# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/c++config.h" 1 3
# 186 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/c++config.h" 3
namespace std
{
  typedef unsigned int size_t;
  typedef int ptrdiff_t;


  typedef decltype(nullptr) nullptr_t;

}
# 430 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/c++config.h" 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/os_defines.h" 1 3
# 431 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/c++config.h" 2 3


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/cpu_defines.h" 1 3
# 434 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/c++config.h" 2 3
# 42 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/cpp_type_traits.h" 1 3
# 35 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/cpp_type_traits.h" 3
       
# 36 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/cpp_type_traits.h" 3
# 68 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/cpp_type_traits.h" 3
namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  template<typename _Iterator, typename _Container>
    class __normal_iterator;


}

namespace std __attribute__ ((__visibility__ ("default")))
{


  struct __true_type { };
  struct __false_type { };

  template<bool>
    struct __truth_type
    { typedef __false_type __type; };

  template<>
    struct __truth_type<true>
    { typedef __true_type __type; };



  template<class _Sp, class _Tp>
    struct __traitor
    {
      enum { __value = bool(_Sp::__value) || bool(_Tp::__value) };
      typedef typename __truth_type<__value>::__type __type;
    };


  template<typename, typename>
    struct __are_same
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __are_same<_Tp, _Tp>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_void
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_void<void>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_integer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };




  template<>
    struct __is_integer<bool>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



  template<>
    struct __is_integer<char16_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<char32_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_integer<short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned short>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned int>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_integer<unsigned long long>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_floating
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<>
    struct __is_floating<float>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_floating<long double>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_pointer
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Tp>
    struct __is_pointer<_Tp*>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_normal_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<typename _Iterator, typename _Container>
    struct __is_normal_iterator< __gnu_cxx::__normal_iterator<_Iterator,
             _Container> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_arithmetic
    : public __traitor<__is_integer<_Tp>, __is_floating<_Tp> >
    { };




  template<typename _Tp>
    struct __is_scalar
    : public __traitor<__is_arithmetic<_Tp>, __is_pointer<_Tp> >
    { };




  template<typename _Tp>
    struct __is_char
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_char<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<>
    struct __is_char<wchar_t>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };


  template<typename _Tp>
    struct __is_byte
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };

  template<>
    struct __is_byte<char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<signed char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };

  template<>
    struct __is_byte<unsigned char>
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };




  template<typename _Tp>
    struct __is_move_iterator
    {
      enum { __value = 0 };
      typedef __false_type __type;
    };


  template<typename _Iterator>
    class move_iterator;

  template<typename _Iterator>
    struct __is_move_iterator< move_iterator<_Iterator> >
    {
      enum { __value = 1 };
      typedef __true_type __type;
    };



}
# 43 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/type_traits.h" 1 3
# 32 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/type_traits.h" 3
       
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/type_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<bool, typename>
    struct __enable_if
    { };

  template<typename _Tp>
    struct __enable_if<true, _Tp>
    { typedef _Tp __type; };



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct __conditional_type
    { typedef _Iftrue __type; };

  template<typename _Iftrue, typename _Iffalse>
    struct __conditional_type<false, _Iftrue, _Iffalse>
    { typedef _Iffalse __type; };



  template<typename _Tp>
    struct __add_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __add_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __add_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __add_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __add_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __add_unsigned<long long>
    { typedef unsigned long long __type; };


  template<>
    struct __add_unsigned<bool>;

  template<>
    struct __add_unsigned<wchar_t>;



  template<typename _Tp>
    struct __remove_unsigned
    {
    private:
      typedef __enable_if<std::__is_integer<_Tp>::__value, _Tp> __if_type;

    public:
      typedef typename __if_type::__type __type;
    };

  template<>
    struct __remove_unsigned<char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __remove_unsigned<unsigned short>
    { typedef short __type; };

  template<>
    struct __remove_unsigned<unsigned int>
    { typedef int __type; };

  template<>
    struct __remove_unsigned<unsigned long>
    { typedef long __type; };

  template<>
    struct __remove_unsigned<unsigned long long>
    { typedef long long __type; };


  template<>
    struct __remove_unsigned<bool>;

  template<>
    struct __remove_unsigned<wchar_t>;



  template<typename _Type>
    inline bool
    __is_null_pointer(_Type* __ptr)
    { return __ptr == 0; }

  template<typename _Type>
    inline bool
    __is_null_pointer(_Type)
    { return false; }


  inline bool
  __is_null_pointer(std::nullptr_t)
  { return true; }



  template<typename _Tp, bool = std::__is_integer<_Tp>::__value>
    struct __promote
    { typedef double __type; };




  template<typename _Tp>
    struct __promote<_Tp, false>
    { };

  template<>
    struct __promote<long double>
    { typedef long double __type; };

  template<>
    struct __promote<double>
    { typedef double __type; };

  template<>
    struct __promote<float>
    { typedef float __type; };

  template<typename _Tp, typename _Up,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type>
    struct __promote_2
    {
      typedef __typeof__(_Tp2() + _Up2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type>
    struct __promote_3
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2()) __type;
    };

  template<typename _Tp, typename _Up, typename _Vp, typename _Wp,
           typename _Tp2 = typename __promote<_Tp>::__type,
           typename _Up2 = typename __promote<_Up>::__type,
           typename _Vp2 = typename __promote<_Vp>::__type,
           typename _Wp2 = typename __promote<_Wp>::__type>
    struct __promote_4
    {
      typedef __typeof__(_Tp2() + _Up2() + _Vp2() + _Wp2()) __type;
    };


}
# 44 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 2 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/math.h" 1 3
# 21 "C:\\ndk/platforms/android-9/arch-arm/usr/include/math.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/types.h" 1 3
# 33 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/types.h" 3
# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 1 3 4
# 147 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 3 4
typedef int ptrdiff_t;
# 212 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 3 4
typedef unsigned int size_t;
# 34 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/types.h" 2 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdint.h" 1 3
# 31 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdint.h" 3
# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 1 3 4
# 422 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 3 4
typedef struct {
  long long __max_align_ll __attribute__((__aligned__(__alignof__(long long))));
  long double __max_align_ld __attribute__((__aligned__(__alignof__(long double))));
} max_align_t;






  typedef decltype(nullptr) nullptr_t;
# 32 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdint.h" 2 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/_types.h" 1 3
# 40 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/_types.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/machine/_types.h" 1 3
# 39 "C:\\ndk/platforms/android-9/arch-arm/usr/include/machine/_types.h" 3
typedef signed char __int8_t;
typedef unsigned char __uint8_t;
typedef short __int16_t;
typedef unsigned short __uint16_t;
typedef int __int32_t;
typedef unsigned int __uint32_t;

typedef long long __int64_t;

typedef unsigned long long __uint64_t;


typedef __int8_t __int_least8_t;
typedef __uint8_t __uint_least8_t;
typedef __int16_t __int_least16_t;
typedef __uint16_t __uint_least16_t;
typedef __int32_t __int_least32_t;
typedef __uint32_t __uint_least32_t;
typedef __int64_t __int_least64_t;
typedef __uint64_t __uint_least64_t;


typedef __int32_t __int_fast8_t;
typedef __uint32_t __uint_fast8_t;
typedef __int32_t __int_fast16_t;
typedef __uint32_t __uint_fast16_t;
typedef __int32_t __int_fast32_t;
typedef __uint32_t __uint_fast32_t;
typedef __int64_t __int_fast64_t;
typedef __uint64_t __uint_fast64_t;


typedef int __intptr_t;
typedef unsigned int __uintptr_t;


typedef __int64_t __intmax_t;
typedef __uint64_t __uintmax_t;


typedef __int32_t __register_t;


typedef unsigned long __vaddr_t;
typedef unsigned long __paddr_t;
typedef unsigned long __vsize_t;
typedef unsigned long __psize_t;


typedef int __clock_t;
typedef int __clockid_t;
typedef long __ptrdiff_t;
typedef int __time_t;
typedef int __timer_t;

typedef __builtin_va_list __va_list;
# 103 "C:\\ndk/platforms/android-9/arch-arm/usr/include/machine/_types.h" 3
typedef int __wint_t;
typedef int __rune_t;
typedef void * __wctrans_t;
typedef void * __wctype_t;
# 41 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/_types.h" 2 3

typedef unsigned long __cpuid_t;
typedef __int32_t __dev_t;
typedef __uint32_t __fixpt_t;
typedef __uint32_t __gid_t;
typedef __uint32_t __id_t;
typedef __uint32_t __in_addr_t;
typedef __uint16_t __in_port_t;
typedef __uint32_t __ino_t;
typedef long __key_t;
typedef __uint32_t __mode_t;
typedef __uint32_t __nlink_t;
typedef __int32_t __pid_t;
typedef __uint64_t __rlim_t;
typedef __uint16_t __sa_family_t;
typedef __int32_t __segsz_t;
typedef __uint32_t __socklen_t;
typedef __int32_t __swblk_t;
typedef __uint32_t __uid_t;
typedef __uint32_t __useconds_t;
typedef __int32_t __suseconds_t;





typedef union {
 char __mbstate8[128];
 __int64_t __mbstateL;
} __mbstate_t;
# 33 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdint.h" 2 3
# 42 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdint.h" 3
typedef __int8_t int8_t;
typedef __uint8_t uint8_t;
typedef __int16_t int16_t;
typedef __uint16_t uint16_t;
typedef __int32_t int32_t;
typedef __uint32_t uint32_t;
typedef __int64_t int64_t;
typedef __uint64_t uint64_t;





typedef int8_t int_least8_t;
typedef int8_t int_fast8_t;

typedef uint8_t uint_least8_t;
typedef uint8_t uint_fast8_t;
# 88 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdint.h" 3
typedef int16_t int_least16_t;
typedef int32_t int_fast16_t;

typedef uint16_t uint_least16_t;
typedef uint32_t uint_fast16_t;
# 121 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdint.h" 3
typedef int32_t int_least32_t;
typedef int32_t int_fast32_t;

typedef uint32_t uint_least32_t;
typedef uint32_t uint_fast32_t;
# 154 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdint.h" 3
typedef int64_t int_least64_t;
typedef int64_t int_fast64_t;

typedef uint64_t uint_least64_t;
typedef uint64_t uint_fast64_t;
# 198 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdint.h" 3
typedef int intptr_t;
typedef unsigned int uintptr_t;
# 220 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdint.h" 3
typedef uint64_t uintmax_t;
typedef int64_t intmax_t;
# 254 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdint.h" 3
typedef int ssize_t;
# 35 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/types.h" 2 3


# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/linux/posix_types.h" 1 3
# 15 "C:\\ndk/platforms/android-9/arch-arm/usr/include/linux/posix_types.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/linux/stddef.h" 1 3
# 21 "C:\\ndk/platforms/android-9/arch-arm/usr/include/linux/stddef.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/linux/compiler.h" 1 3
# 22 "C:\\ndk/platforms/android-9/arch-arm/usr/include/linux/stddef.h" 2 3
# 16 "C:\\ndk/platforms/android-9/arch-arm/usr/include/linux/posix_types.h" 2 3
# 32 "C:\\ndk/platforms/android-9/arch-arm/usr/include/linux/posix_types.h" 3
typedef struct {
 unsigned long fds_bits [(1024/(8 * sizeof(unsigned long)))];
} __kernel_fd_set;

typedef void (*__kernel_sighandler_t)(int);

typedef int __kernel_key_t;
typedef int __kernel_mqd_t;

# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm/posix_types.h" 1 3
# 15 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm/posix_types.h" 3
typedef unsigned long __kernel_ino_t;
typedef unsigned short __kernel_mode_t;
typedef unsigned short __kernel_nlink_t;
typedef long __kernel_off_t;
typedef int __kernel_pid_t;
typedef unsigned short __kernel_ipc_pid_t;
typedef unsigned short __kernel_uid_t;
typedef unsigned short __kernel_gid_t;
typedef unsigned int __kernel_size_t;
typedef int __kernel_ssize_t;
typedef int __kernel_ptrdiff_t;
typedef long __kernel_time_t;
typedef long __kernel_suseconds_t;
typedef long __kernel_clock_t;
typedef int __kernel_timer_t;
typedef int __kernel_clockid_t;
typedef int __kernel_daddr_t;
typedef char * __kernel_caddr_t;
typedef unsigned short __kernel_uid16_t;
typedef unsigned short __kernel_gid16_t;
typedef unsigned int __kernel_uid32_t;
typedef unsigned int __kernel_gid32_t;

typedef unsigned short __kernel_old_uid_t;
typedef unsigned short __kernel_old_gid_t;
typedef unsigned short __kernel_old_dev_t;


typedef long long __kernel_loff_t;


typedef struct {



 int __val[2];

} __kernel_fsid_t;
# 42 "C:\\ndk/platforms/android-9/arch-arm/usr/include/linux/posix_types.h" 2 3
# 38 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/types.h" 2 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm/types.h" 1 3
# 17 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm/types.h" 3
typedef unsigned short umode_t;

typedef __signed__ char __s8;
typedef unsigned char __u8;

typedef __signed__ short __s16;
typedef unsigned short __u16;

typedef __signed__ int __s32;
typedef unsigned int __u32;


typedef __signed__ long long __s64;
typedef unsigned long long __u64;
# 39 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/types.h" 2 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/linux/types.h" 1 3
# 21 "C:\\ndk/platforms/android-9/arch-arm/usr/include/linux/types.h" 3
typedef __u16 __le16;
typedef __u16 __be16;
typedef __u32 __le32;
typedef __u32 __be32;





struct ustat {
 __kernel_daddr_t f_tfree;
 __kernel_ino_t f_tinode;
 char f_fname[6];
 char f_fpack[6];
};
# 40 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/types.h" 2 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/machine/kernel.h" 1 3
# 34 "C:\\ndk/platforms/android-9/arch-arm/usr/include/machine/kernel.h" 3
typedef unsigned long __kernel_blkcnt_t;
typedef unsigned long __kernel_blksize_t;


typedef unsigned long __kernel_fsblkcnt_t;
typedef unsigned long __kernel_fsfilcnt_t;
typedef unsigned int __kernel_id_t;
# 41 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/types.h" 2 3

typedef __u32 __kernel_dev_t;
# 52 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/types.h" 3
typedef __kernel_blkcnt_t blkcnt_t;
typedef __kernel_blksize_t blksize_t;
typedef __kernel_clock_t clock_t;
typedef __kernel_clockid_t clockid_t;
typedef __kernel_dev_t dev_t;
typedef __kernel_fsblkcnt_t fsblkcnt_t;
typedef __kernel_fsfilcnt_t fsfilcnt_t;
typedef __kernel_gid32_t gid_t;
typedef __kernel_id_t id_t;
typedef __kernel_ino_t ino_t;
typedef __kernel_key_t key_t;
typedef __kernel_mode_t mode_t;
typedef __kernel_nlink_t nlink_t;


typedef __kernel_off_t off_t;

typedef __kernel_loff_t loff_t;
typedef loff_t off64_t;

typedef __kernel_pid_t pid_t;
# 93 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/types.h" 3
typedef __kernel_suseconds_t suseconds_t;
typedef __kernel_time_t time_t;
typedef __kernel_uid32_t uid_t;
typedef signed long useconds_t;

typedef __kernel_daddr_t daddr_t;
typedef __kernel_timer_t timer_t;
typedef __kernel_mqd_t mqd_t;

typedef __kernel_caddr_t caddr_t;
typedef unsigned int uint_t;
typedef unsigned int uint;


# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/sysmacros.h" 1 3
# 36 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/sysmacros.h" 3
static __inline__ int major(dev_t _dev)
{
  return (_dev >> 8) & 0xfff;
}

static __inline__ int minor(dev_t _dev)
{
  return (_dev & 0xff) | ((_dev >> 12) & 0xfff00);
}

static __inline__ dev_t makedev(int __ma, int __mi)
{
  return ((__ma & 0xfff) << 8) | (__mi & 0xff) | ((__mi & 0xfff00) << 12);
}
# 108 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/types.h" 2 3


typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;

typedef uint32_t u_int32_t;
typedef uint16_t u_int16_t;
typedef uint8_t u_int8_t;
typedef uint64_t u_int64_t;
# 22 "C:\\ndk/platforms/android-9/arch-arm/usr/include/math.h" 2 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/limits.h" 1 3
# 86 "C:\\ndk/platforms/android-9/arch-arm/usr/include/limits.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/limits.h" 1 3
# 30 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/limits.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/linux/limits.h" 1 3
# 31 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/limits.h" 2 3
# 44 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/limits.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/machine/internal_types.h" 1 3
# 45 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/limits.h" 2 3


# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/machine/limits.h" 1 3
# 48 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/limits.h" 2 3
# 87 "C:\\ndk/platforms/android-9/arch-arm/usr/include/limits.h" 2 3


# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/syslimits.h" 1 3
# 90 "C:\\ndk/platforms/android-9/arch-arm/usr/include/limits.h" 2 3
# 109 "C:\\ndk/platforms/android-9/arch-arm/usr/include/limits.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm/page.h" 1 3
# 110 "C:\\ndk/platforms/android-9/arch-arm/usr/include/limits.h" 2 3
# 23 "C:\\ndk/platforms/android-9/arch-arm/usr/include/math.h" 2 3






extern const union __infinity_un {
 unsigned char __uc[8];
 double __ud;
} __infinity;

extern const union __nan_un {
 unsigned char __uc[sizeof(float)];
 float __uf;
} __nan;
# 165 "C:\\ndk/platforms/android-9/arch-arm/usr/include/math.h" 3
extern int signgam;
# 182 "C:\\ndk/platforms/android-9/arch-arm/usr/include/math.h" 3
extern "C" {



int __fpclassifyd(double) ;
int __fpclassifyf(float) ;
int __fpclassifyl(long double) ;
int __isfinitef(float) ;
int __isfinite(double) ;
int __isfinitel(long double) ;
int __isinff(float) ;
int __isinf(double) ;
int __isinfl(long double) ;
int __isnanl(long double) ;
int __isnormalf(float) ;
int __isnormal(double) ;
int __isnormall(long double) ;
int __signbit(double) ;
int __signbitf(float) ;
int __signbitl(long double) ;

double acos(double) ;
double asin(double) ;
double atan(double) ;
double atan2(double, double) ;
double cos(double) ;
double sin(double) ;
double tan(double) ;

double cosh(double) ;
double sinh(double) ;
double tanh(double) ;

double exp(double) ;
double frexp(double, int *) ;
double ldexp(double, int) ;
double log(double) ;
double log10(double) ;
double modf(double, double *) ;

double pow(double, double) ;
double sqrt(double) ;

double ceil(double) ;
double fabs(double) ;
double floor(double) ;
double fmod(double, double) ;





double acosh(double) ;
double asinh(double) ;
double atanh(double) ;
double cbrt(double) ;
double erf(double) ;
double erfc(double) ;
double exp2(double) ;
double expm1(double) ;
double fma(double, double, double) ;
double hypot(double, double) ;
int ilogb(double) ;

int (isnan)(double) ;
double lgamma(double) ;
long long llrint(double) ;
long long llround(double) ;
double log1p(double) ;
double logb(double) ;
long lrint(double) ;
long lround(double) ;
double nextafter(double, double) ;
double remainder(double, double) ;
double remquo(double, double, int *) ;
double rint(double) ;



double j0(double) ;
double j1(double) ;
double jn(int, double) ;
double scalb(double, double) ;
double y0(double) ;
double y1(double) ;
double yn(int, double) ;


double gamma(double) ;




double copysign(double, double) ;
double fdim(double, double) ;
double fmax(double, double) ;
double fmin(double, double) ;
double nearbyint(double) ;
double round(double) ;
double scalbln(double, long) ;
double scalbn(double, int) ;
double tgamma(double) ;
double trunc(double) ;






double drem(double, double) ;
int finite(double) ;
int isnanf(float) ;





double gamma_r(double, int *) ;
double lgamma_r(double, int *) ;




double significand(double) ;




float acosf(float) ;
float asinf(float) ;
float atanf(float) ;
float atan2f(float, float) ;
float cosf(float) ;
float sinf(float) ;
float tanf(float) ;

float coshf(float) ;
float sinhf(float) ;
float tanhf(float) ;

float exp2f(float) ;
float expf(float) ;
float expm1f(float) ;
float frexpf(float, int *) ;
int ilogbf(float) ;
float ldexpf(float, int) ;
float log10f(float) ;
float log1pf(float) ;
float logf(float) ;
float modff(float, float *) ;

float powf(float, float) ;
float sqrtf(float) ;

float ceilf(float) ;
float fabsf(float) ;
float floorf(float) ;
float fmodf(float, float) ;
float roundf(float) ;

float erff(float) ;
float erfcf(float) ;
float hypotf(float, float) ;
float lgammaf(float) ;

float acoshf(float) ;
float asinhf(float) ;
float atanhf(float) ;
float cbrtf(float) ;
float logbf(float) ;
float copysignf(float, float) ;
long long llrintf(float) ;
long long llroundf(float) ;
long lrintf(float) ;
long lroundf(float) ;
float nearbyintf(float) ;
float nextafterf(float, float) ;
float remainderf(float, float) ;
float remquof(float, float, int *) ;
float rintf(float) ;
float scalblnf(float, long) ;
float scalbnf(float, int) ;
float truncf(float) ;

float fdimf(float, float) ;
float fmaf(float, float, float) ;
float fmaxf(float, float) ;
float fminf(float, float) ;






float dremf(float, float) ;
int finitef(float) ;
float gammaf(float) ;
float j0f(float) ;
float j1f(float) ;
float jnf(int, float) ;
float scalbf(float, float) ;
float y0f(float) ;
float y1f(float) ;
float ynf(int, float) ;






float gammaf_r(float, int *) ;
float lgammaf_r(float, int *) ;




float significandf(float) ;
# 415 "C:\\ndk/platforms/android-9/arch-arm/usr/include/math.h" 3
long double ceill(long double) ;
long double copysignl(long double, long double) ;
# 426 "C:\\ndk/platforms/android-9/arch-arm/usr/include/math.h" 3
long double fabsl(long double) ;
long double fdiml(long double, long double) ;
long double floorl(long double) ;
long double fmal(long double, long double, long double) ;
long double fmaxl(long double, long double) ;
long double fminl(long double, long double) ;



long double frexpl(long double value, int *) ;



int ilogbl(long double) ;
long double ldexpl(long double, int) ;




long long llroundl(long double) ;
# 454 "C:\\ndk/platforms/android-9/arch-arm/usr/include/math.h" 3
long lroundl(long double) ;





long double nextafterl(long double, long double) ;
double nexttoward(double, long double) ;
float nexttowardf(float, long double) ;
long double nexttowardl(long double, long double) ;






long double roundl(long double) ;
long double scalblnl(long double, long) ;
long double scalbnl(long double, int) ;
# 481 "C:\\ndk/platforms/android-9/arch-arm/usr/include/math.h" 3
long double truncl(long double) ;



void sincos(double x, double *sin, double *cos) ;
void sincosf(float x, float *sin, float *cos) ;
void sincosl(long double x, long double *sin, long double *cos) ;




double __builtin_acos(double) ;
double __builtin_asin(double) ;
double __builtin_atan(double) ;
double __builtin_atan2(double, double) ;
double __builtin_cos(double) ;
double __builtin_sin(double) ;
double __builtin_tan(double) ;
double __builtin_cosh(double) ;
double __builtin_sinh(double) ;
double __builtin_tanh(double) ;
double __builtin_exp(double) ;
double __builtin_frexp(double, int *) ;
double __builtin_ldexp(double, int) ;
double __builtin_log(double) ;
double __builtin_log10(double) ;
double __builtin_modf(double, double *) ;
double __builtin_pow(double, double) ;
double __builtin_sqrt(double) ;
double __builtin_ceil(double) ;
double __builtin_fabs(double) ;
double __builtin_floor(double) ;
double __builtin_fmod(double, double) ;
double __builtin_acosh(double) ;
double __builtin_asinh(double) ;
double __builtin_atanh(double) ;
double __builtin_cbrt(double) ;
double __builtin_erf(double) ;
double __builtin_erfc(double) ;
double __builtin_exp2(double) ;
double __builtin_expm1(double) ;
double __builtin_fma(double, double, double) ;
double __builtin_hypot(double, double) ;
int __builtin_ilogb(double) ;


int __builtin_isnan(double) ;



double __builtin_lgamma(double) ;
long long __builtin_llrint(double) ;
long long __builtin_llround(double) ;
double __builtin_log1p(double) ;
double __builtin_logb(double) ;
long __builtin_lrint(double) ;
long __builtin_lround(double) ;
double __builtin_nextafter(double, double) ;
double __builtin_remainder(double, double) ;
double __builtin_remquo(double, double, int *) ;
double __builtin_rint(double) ;
double __builtin_j0(double) ;
double __builtin_j1(double) ;
double __builtin_jn(int, double) ;
double __builtin_scalb(double, double) ;
double __builtin_y0(double) ;
double __builtin_y1(double) ;
double __builtin_yn(int, double) ;
double __builtin_gamma(double) ;
double __builtin_copysign(double, double) ;
double __builtin_fdim(double, double) ;
double __builtin_fmax(double, double) ;
double __builtin_fmin(double, double) ;
double __builtin_nearbyint(double) ;
double __builtin_round(double) ;
double __builtin_scalbln(double, long) ;
double __builtin_scalbn(double, int) ;
double __builtin_tgamma(double) ;
double __builtin_trunc(double) ;
double __builtin_drem(double, double) ;
int __builtin_finite(double) ;
int __builtin_isnanf(float) ;
double __builtin_gamma_r(double, int *) ;
double __builtin_lgamma_r(double, int *) ;
double __builtin_significand(double) ;
float __builtin_acosf(float) ;
float __builtin_asinf(float) ;
float __builtin_atanf(float) ;
float __builtin_atan2f(float, float) ;
float __builtin_cosf(float) ;
float __builtin_sinf(float) ;
float __builtin_tanf(float) ;
float __builtin_coshf(float) ;
float __builtin_sinhf(float) ;
float __builtin_tanhf(float) ;
float __builtin_exp2f(float) ;
float __builtin_expf(float) ;
float __builtin_expm1f(float) ;
float __builtin_frexpf(float, int *) ;
int __builtin_ilogbf(float) ;
float __builtin_ldexpf(float, int) ;
float __builtin_log10f(float) ;
float __builtin_log1pf(float) ;
float __builtin_logf(float) ;
float __builtin_modff(float, float *) ;
float __builtin_powf(float, float) ;
float __builtin_sqrtf(float) ;
float __builtin_ceilf(float) ;
float __builtin_fabsf(float) ;
float __builtin_floorf(float) ;
float __builtin_fmodf(float, float) ;
float __builtin_roundf(float) ;
float __builtin_erff(float) ;
float __builtin_erfcf(float) ;
float __builtin_hypotf(float, float) ;
float __builtin_lgammaf(float) ;
float __builtin_acoshf(float) ;
float __builtin_asinhf(float) ;
float __builtin_atanhf(float) ;
float __builtin_cbrtf(float) ;
float __builtin_logbf(float) ;
float __builtin_copysignf(float, float) ;
long long __builtin_llrintf(float) ;
long long __builtin_llroundf(float) ;
long __builtin_lrintf(float) ;
long __builtin_lroundf(float) ;
float __builtin_nearbyintf(float) ;
float __builtin_nextafterf(float, float) ;
float __builtin_remainderf(float, float) ;
float __builtin_remquof(float, float, int *) ;
float __builtin_rintf(float) ;
float __builtin_scalblnf(float, long) ;
float __builtin_scalbnf(float, int) ;
float __builtin_truncf(float) ;
float __builtin_fdimf(float, float) ;
float __builtin_fmaf(float, float, float) ;
float __builtin_fmaxf(float, float) ;
float __builtin_fminf(float, float) ;
float __builtin_dremf(float, float) ;
int __builtin_finitef(float) ;
float __builtin_gammaf(float) ;
float __builtin_j0f(float) ;
float __builtin_j1f(float) ;
float __builtin_jnf(int, float) ;
float __builtin_scalbf(float, float) ;
float __builtin_y0f(float) ;
float __builtin_y1f(float) ;
float __builtin_ynf(int, float) ;
float __builtin_gammaf_r(float, int *) ;
float __builtin_lgammaf_r(float, int *) ;
float __builtin_significandf(float) ;
long double __builtin_acoshl(long double) ;
long double __builtin_acosl(long double) ;
long double __builtin_asinhl(long double) ;
long double __builtin_asinl(long double) ;
long double __builtin_atan2l(long double, long double) ;
long double __builtin_atanhl(long double) ;
long double __builtin_atanl(long double) ;
long double __builtin_cbrtl(long double) ;
long double __builtin_ceill(long double) ;
long double __builtin_copysignl(long double, long double) ;
long double __builtin_coshl(long double) ;
long double __builtin_cosl(long double) ;
long double __builtin_erfcl(long double) ;
long double __builtin_erfl(long double) ;
long double __builtin_exp2l(long double) ;
long double __builtin_expl(long double) ;
long double __builtin_expm1l(long double) ;
long double __builtin_fabsl(long double) ;
long double __builtin_fdiml(long double, long double) ;
long double __builtin_floorl(long double) ;
long double __builtin_fmal(long double, long double, long double) ;
long double __builtin_fmaxl(long double, long double) ;
long double __builtin_fminl(long double, long double) ;
long double __builtin_fmodl(long double, long double) ;
long double __builtin_frexpl(long double value, int *) ;
long double __builtin_hypotl(long double, long double) ;
int __builtin_ilogbl(long double) ;
long double __builtin_ldexpl(long double, int) ;
long double __builtin_lgammal(long double) ;
long long __builtin_llrintl(long double) ;
long long __builtin_llroundl(long double) ;
long double __builtin_log10l(long double) ;
long double __builtin_log1pl(long double) ;
long double __builtin_log2l(long double) ;
long double __builtin_logbl(long double) ;
long double __builtin_logl(long double) ;
long __builtin_lrintl(long double) ;
long __builtin_lroundl(long double) ;
long double __builtin_modfl(long double, long double *) ;
long double __builtin_nanl(const char *) ;
long double __builtin_nearbyintl(long double) ;
long double __builtin_nextafterl(long double, long double) ;

double __builtin_nexttoward(double, long double) ;
float __builtin_nexttowardf(float, long double) ;





long double __builtin_nexttowardl(long double, long double) ;
long double __builtin_powl(long double, long double) ;
long double __builtin_remainderl(long double, long double) ;
long double __builtin_remquol(long double, long double, int *) ;
long double __builtin_rintl(long double) ;
long double __builtin_roundl(long double) ;
long double __builtin_scalblnl(long double, long) ;
long double __builtin_scalbnl(long double, int) ;
long double __builtin_sinhl(long double) ;
long double __builtin_sinl(long double) ;
long double __builtin_sqrtl(long double) ;
long double __builtin_tanhl(long double) ;
long double __builtin_tanl(long double) ;
long double __builtin_tgammal(long double) ;
long double __builtin_truncl(long double) ;
void __builtin_sincos(double x, double *sin, double *cos) ;
void __builtin_sincosf(float x, float *sin, float *cos) ;
void __builtin_sincosl(long double x, long double *sin, long double *cos) ;


}
# 45 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 2 3
# 75 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  inline constexpr double
  abs(double __x)
  { return __builtin_fabs(__x); }



  inline constexpr float
  abs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  abs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    abs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::acos;


  inline constexpr float
  acos(float __x)
  { return __builtin_acosf(__x); }

  inline constexpr long double
  acos(long double __x)
  { return __builtin_acosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    acos(_Tp __x)
    { return __builtin_acos(__x); }

  using ::asin;


  inline constexpr float
  asin(float __x)
  { return __builtin_asinf(__x); }

  inline constexpr long double
  asin(long double __x)
  { return __builtin_asinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    asin(_Tp __x)
    { return __builtin_asin(__x); }

  using ::atan;


  inline constexpr float
  atan(float __x)
  { return __builtin_atanf(__x); }

  inline constexpr long double
  atan(long double __x)
  { return __builtin_atanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    atan(_Tp __x)
    { return __builtin_atan(__x); }

  using ::atan2;


  inline constexpr float
  atan2(float __y, float __x)
  { return __builtin_atan2f(__y, __x); }

  inline constexpr long double
  atan2(long double __y, long double __x)
  { return __builtin_atan2l(__y, __x); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    atan2(_Tp __y, _Up __x)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return atan2(__type(__y), __type(__x));
    }

  using ::ceil;


  inline constexpr float
  ceil(float __x)
  { return __builtin_ceilf(__x); }

  inline constexpr long double
  ceil(long double __x)
  { return __builtin_ceill(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ceil(_Tp __x)
    { return __builtin_ceil(__x); }

  using ::cos;


  inline constexpr float
  cos(float __x)
  { return __builtin_cosf(__x); }

  inline constexpr long double
  cos(long double __x)
  { return __builtin_cosl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cos(_Tp __x)
    { return __builtin_cos(__x); }

  using ::cosh;


  inline constexpr float
  cosh(float __x)
  { return __builtin_coshf(__x); }

  inline constexpr long double
  cosh(long double __x)
  { return __builtin_coshl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    cosh(_Tp __x)
    { return __builtin_cosh(__x); }

  using ::exp;


  inline constexpr float
  exp(float __x)
  { return __builtin_expf(__x); }

  inline constexpr long double
  exp(long double __x)
  { return __builtin_expl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    exp(_Tp __x)
    { return __builtin_exp(__x); }

  using ::fabs;


  inline constexpr float
  fabs(float __x)
  { return __builtin_fabsf(__x); }

  inline constexpr long double
  fabs(long double __x)
  { return __builtin_fabsl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    fabs(_Tp __x)
    { return __builtin_fabs(__x); }

  using ::floor;


  inline constexpr float
  floor(float __x)
  { return __builtin_floorf(__x); }

  inline constexpr long double
  floor(long double __x)
  { return __builtin_floorl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    floor(_Tp __x)
    { return __builtin_floor(__x); }

  using ::fmod;


  inline constexpr float
  fmod(float __x, float __y)
  { return __builtin_fmodf(__x, __y); }

  inline constexpr long double
  fmod(long double __x, long double __y)
  { return __builtin_fmodl(__x, __y); }


  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    fmod(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return fmod(__type(__x), __type(__y));
    }

  using ::frexp;


  inline float
  frexp(float __x, int* __exp)
  { return __builtin_frexpf(__x, __exp); }

  inline long double
  frexp(long double __x, int* __exp)
  { return __builtin_frexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    frexp(_Tp __x, int* __exp)
    { return __builtin_frexp(__x, __exp); }

  using ::ldexp;


  inline constexpr float
  ldexp(float __x, int __exp)
  { return __builtin_ldexpf(__x, __exp); }

  inline constexpr long double
  ldexp(long double __x, int __exp)
  { return __builtin_ldexpl(__x, __exp); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    ldexp(_Tp __x, int __exp)
    { return __builtin_ldexp(__x, __exp); }

  using ::log;


  inline constexpr float
  log(float __x)
  { return __builtin_logf(__x); }

  inline constexpr long double
  log(long double __x)
  { return __builtin_logl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log(_Tp __x)
    { return __builtin_log(__x); }

  using ::log10;


  inline constexpr float
  log10(float __x)
  { return __builtin_log10f(__x); }

  inline constexpr long double
  log10(long double __x)
  { return __builtin_log10l(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    log10(_Tp __x)
    { return __builtin_log10(__x); }

  using ::modf;


  inline float
  modf(float __x, float* __iptr)
  { return __builtin_modff(__x, __iptr); }

  inline long double
  modf(long double __x, long double* __iptr)
  { return __builtin_modfl(__x, __iptr); }


  using ::pow;


  inline constexpr float
  pow(float __x, float __y)
  { return __builtin_powf(__x, __y); }

  inline constexpr long double
  pow(long double __x, long double __y)
  { return __builtin_powl(__x, __y); }
# 431 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 3
  template<typename _Tp, typename _Up>
    inline constexpr
    typename __gnu_cxx::__promote_2<_Tp, _Up>::__type
    pow(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return pow(__type(__x), __type(__y));
    }

  using ::sin;


  inline constexpr float
  sin(float __x)
  { return __builtin_sinf(__x); }

  inline constexpr long double
  sin(long double __x)
  { return __builtin_sinl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sin(_Tp __x)
    { return __builtin_sin(__x); }

  using ::sinh;


  inline constexpr float
  sinh(float __x)
  { return __builtin_sinhf(__x); }

  inline constexpr long double
  sinh(long double __x)
  { return __builtin_sinhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sinh(_Tp __x)
    { return __builtin_sinh(__x); }

  using ::sqrt;


  inline constexpr float
  sqrt(float __x)
  { return __builtin_sqrtf(__x); }

  inline constexpr long double
  sqrt(long double __x)
  { return __builtin_sqrtl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    sqrt(_Tp __x)
    { return __builtin_sqrt(__x); }

  using ::tan;


  inline constexpr float
  tan(float __x)
  { return __builtin_tanf(__x); }

  inline constexpr long double
  tan(long double __x)
  { return __builtin_tanl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tan(_Tp __x)
    { return __builtin_tan(__x); }

  using ::tanh;


  inline constexpr float
  tanh(float __x)
  { return __builtin_tanhf(__x); }

  inline constexpr long double
  tanh(long double __x)
  { return __builtin_tanhl(__x); }


  template<typename _Tp>
    inline constexpr
    typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                    double>::__type
    tanh(_Tp __x)
    { return __builtin_tanh(__x); }


}
# 555 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  constexpr int
  fpclassify(float __x)
  { return __builtin_fpclassify(0x02, 0x01, 0x04,
    0x08, 0x10, __x); }

  constexpr int
  fpclassify(double __x)
  { return __builtin_fpclassify(0x02, 0x01, 0x04,
    0x08, 0x10, __x); }

  constexpr int
  fpclassify(long double __x)
  { return __builtin_fpclassify(0x02, 0x01, 0x04,
    0x08, 0x10, __x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              int>::__type
    fpclassify(_Tp __x)
    { return __x != 0 ? 0x04 : 0x10; }

  constexpr bool
  isfinite(float __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(double __x)
  { return __builtin_isfinite(__x); }

  constexpr bool
  isfinite(long double __x)
  { return __builtin_isfinite(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isfinite(_Tp __x)
    { return true; }

  constexpr bool
  isinf(float __x)
  { return __builtin_isinf(__x); }

  constexpr bool
  isinf(double __x)
  { return __builtin_isinf(__x); }

  constexpr bool
  isinf(long double __x)
  { return __builtin_isinf(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isinf(_Tp __x)
    { return false; }

  constexpr bool
  isnan(float __x)
  { return __builtin_isnan(__x); }

  constexpr bool
  isnan(double __x)
  { return __builtin_isnan(__x); }

  constexpr bool
  isnan(long double __x)
  { return __builtin_isnan(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnan(_Tp __x)
    { return false; }

  constexpr bool
  isnormal(float __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(double __x)
  { return __builtin_isnormal(__x); }

  constexpr bool
  isnormal(long double __x)
  { return __builtin_isnormal(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    isnormal(_Tp __x)
    { return __x != 0 ? true : false; }


  constexpr bool
  signbit(float __x)
  { return __builtin_signbitf(__x); }

  constexpr bool
  signbit(double __x)
  { return __builtin_signbit(__x); }

  constexpr bool
  signbit(long double __x)
  { return __builtin_signbitl(__x); }

  template<typename _Tp>
    constexpr typename __gnu_cxx::__enable_if<__is_integer<_Tp>::__value,
                                              bool>::__type
    signbit(_Tp __x)
    { return __x < 0 ? true : false; }

  constexpr bool
  isgreater(float __x, float __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(double __x, double __y)
  { return __builtin_isgreater(__x, __y); }

  constexpr bool
  isgreater(long double __x, long double __y)
  { return __builtin_isgreater(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreater(__type(__x), __type(__y));
    }

  constexpr bool
  isgreaterequal(float __x, float __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(double __x, double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  constexpr bool
  isgreaterequal(long double __x, long double __y)
  { return __builtin_isgreaterequal(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isgreaterequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isgreaterequal(__type(__x), __type(__y));
    }

  constexpr bool
  isless(float __x, float __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(double __x, double __y)
  { return __builtin_isless(__x, __y); }

  constexpr bool
  isless(long double __x, long double __y)
  { return __builtin_isless(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isless(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isless(__type(__x), __type(__y));
    }

  constexpr bool
  islessequal(float __x, float __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(double __x, double __y)
  { return __builtin_islessequal(__x, __y); }

  constexpr bool
  islessequal(long double __x, long double __y)
  { return __builtin_islessequal(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessequal(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessequal(__type(__x), __type(__y));
    }

  constexpr bool
  islessgreater(float __x, float __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(double __x, double __y)
  { return __builtin_islessgreater(__x, __y); }

  constexpr bool
  islessgreater(long double __x, long double __y)
  { return __builtin_islessgreater(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    islessgreater(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_islessgreater(__type(__x), __type(__y));
    }

  constexpr bool
  isunordered(float __x, float __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(double __x, double __y)
  { return __builtin_isunordered(__x, __y); }

  constexpr bool
  isunordered(long double __x, long double __y)
  { return __builtin_isunordered(__x, __y); }

  template<typename _Tp, typename _Up>
    constexpr typename
    __gnu_cxx::__enable_if<(__is_arithmetic<_Tp>::__value
       && __is_arithmetic<_Up>::__value), bool>::__type
    isunordered(_Tp __x, _Up __y)
    {
      typedef typename __gnu_cxx::__promote_2<_Tp, _Up>::__type __type;
      return __builtin_isunordered(__type(__x), __type(__y));
    }
# 917 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 3

}
# 3 "../Quadris/Font.cpp" 2
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/limits" 1
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/limits"
       
# 41 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/limits" 3
# 147 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/limits" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  enum float_round_style
  {
    round_indeterminate = -1,
    round_toward_zero = 0,
    round_to_nearest = 1,
    round_toward_infinity = 2,
    round_toward_neg_infinity = 3
  };







  enum float_denorm_style
  {

    denorm_indeterminate = -1,

    denorm_absent = 0,

    denorm_present = 1
  };
# 191 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/limits" 3
  struct __numeric_limits_base
  {


    static constexpr bool is_specialized = false;




    static constexpr int digits = 0;


    static constexpr int digits10 = 0;




    static constexpr int max_digits10 = 0;



    static constexpr bool is_signed = false;


    static constexpr bool is_integer = false;




    static constexpr bool is_exact = false;



    static constexpr int radix = 0;



    static constexpr int min_exponent = 0;



    static constexpr int min_exponent10 = 0;




    static constexpr int max_exponent = 0;



    static constexpr int max_exponent10 = 0;


    static constexpr bool has_infinity = false;



    static constexpr bool has_quiet_NaN = false;



    static constexpr bool has_signaling_NaN = false;


    static constexpr float_denorm_style has_denorm = denorm_absent;



    static constexpr bool has_denorm_loss = false;



    static constexpr bool is_iec559 = false;




    static constexpr bool is_bounded = false;
# 277 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/limits" 3
    static constexpr bool is_modulo = false;


    static constexpr bool traps = false;


    static constexpr bool tinyness_before = false;




    static constexpr float_round_style round_style =
          round_toward_zero;
  };
# 303 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/limits" 3
  template<typename _Tp>
    struct numeric_limits : public __numeric_limits_base
    {


      static constexpr _Tp
      min() noexcept { return _Tp(); }


      static constexpr _Tp
      max() noexcept { return _Tp(); }




      static constexpr _Tp
      lowest() noexcept { return _Tp(); }




      static constexpr _Tp
      epsilon() noexcept { return _Tp(); }


      static constexpr _Tp
      round_error() noexcept { return _Tp(); }


      static constexpr _Tp
      infinity() noexcept { return _Tp(); }



      static constexpr _Tp
      quiet_NaN() noexcept { return _Tp(); }



      static constexpr _Tp
      signaling_NaN() noexcept { return _Tp(); }




      static constexpr _Tp
      denorm_min() noexcept { return _Tp(); }
    };


  template<typename _Tp>
    struct numeric_limits<const _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<volatile _Tp>
    : public numeric_limits<_Tp> { };

  template<typename _Tp>
    struct numeric_limits<const volatile _Tp>
    : public numeric_limits<_Tp> { };






  template<>
    struct numeric_limits<bool>
    {
      static constexpr bool is_specialized = true;

      static constexpr bool
      min() noexcept { return false; }

      static constexpr bool
      max() noexcept { return true; }


      static constexpr bool
      lowest() noexcept { return min(); }

      static constexpr int digits = 1;
      static constexpr int digits10 = 0;

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr bool
      epsilon() noexcept { return false; }

      static constexpr bool
      round_error() noexcept { return false; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr bool
      infinity() noexcept { return false; }

      static constexpr bool
      quiet_NaN() noexcept { return false; }

      static constexpr bool
      signaling_NaN() noexcept { return false; }

      static constexpr bool
      denorm_min() noexcept { return false; }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;




      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<char>
    {
      static constexpr bool is_specialized = true;

      static constexpr char
      min() noexcept { return (((char)(-1) < 0) ? -(((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0) - 1 : (char)0); }

      static constexpr char
      max() noexcept { return (((char)(-1) < 0) ? (((((char)1 << ((sizeof(char) * 8 - ((char)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char)0); }


      static constexpr char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(char) * 8 - ((char)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char) * 8 - ((char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((char)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char
      epsilon() noexcept { return 0; }

      static constexpr char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr
      char infinity() noexcept { return char(); }

      static constexpr char
      quiet_NaN() noexcept { return char(); }

      static constexpr char
      signaling_NaN() noexcept { return char(); }

      static constexpr char
      denorm_min() noexcept { return static_cast<char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<signed char>
    {
      static constexpr bool is_specialized = true;

      static constexpr signed char
      min() noexcept { return -127 - 1; }

      static constexpr signed char
      max() noexcept { return 127; }


      static constexpr signed char
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(signed char) * 8 - ((signed char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(signed char) * 8 - ((signed char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr signed char
      epsilon() noexcept { return 0; }

      static constexpr signed char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr signed char
      infinity() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      quiet_NaN() noexcept { return static_cast<signed char>(0); }

      static constexpr signed char
      signaling_NaN() noexcept
      { return static_cast<signed char>(0); }

      static constexpr signed char
      denorm_min() noexcept
      { return static_cast<signed char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned char>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned char
      min() noexcept { return 0; }

      static constexpr unsigned char
      max() noexcept { return 127 * 2U + 1; }


      static constexpr unsigned char
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned char) * 8 - ((unsigned char)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned char
      epsilon() noexcept { return 0; }

      static constexpr unsigned char
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned char
      infinity() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      quiet_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      signaling_NaN() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr unsigned char
      denorm_min() noexcept
      { return static_cast<unsigned char>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<wchar_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr wchar_t
      min() noexcept { return (((wchar_t)(-1) < 0) ? -(((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0) - 1 : (wchar_t)0); }

      static constexpr wchar_t
      max() noexcept { return (((wchar_t)(-1) < 0) ? (((((wchar_t)1 << ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(wchar_t)0); }


      static constexpr wchar_t
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(wchar_t) * 8 - ((wchar_t)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = ((wchar_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr wchar_t
      epsilon() noexcept { return 0; }

      static constexpr wchar_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr wchar_t
      infinity() noexcept { return wchar_t(); }

      static constexpr wchar_t
      quiet_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      signaling_NaN() noexcept { return wchar_t(); }

      static constexpr wchar_t
      denorm_min() noexcept { return wchar_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };



  template<>
    struct numeric_limits<char16_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char16_t
      min() noexcept { return (((char16_t)(-1) < 0) ? -(((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0) - 1 : (char16_t)0); }

      static constexpr char16_t
      max() noexcept { return (((char16_t)(-1) < 0) ? (((((char16_t)1 << ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char16_t)0); }

      static constexpr char16_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char16_t) * 8 - ((char16_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char16_t) * 8 - ((char16_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char16_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char16_t
      epsilon() noexcept { return 0; }

      static constexpr char16_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char16_t
      infinity() noexcept { return char16_t(); }

      static constexpr char16_t
      quiet_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      signaling_NaN() noexcept { return char16_t(); }

      static constexpr char16_t
      denorm_min() noexcept { return char16_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };


  template<>
    struct numeric_limits<char32_t>
    {
      static constexpr bool is_specialized = true;

      static constexpr char32_t
      min() noexcept { return (((char32_t)(-1) < 0) ? -(((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0) - 1 : (char32_t)0); }

      static constexpr char32_t
      max() noexcept { return (((char32_t)(-1) < 0) ? (((((char32_t)1 << ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(char32_t)0); }

      static constexpr char32_t
      lowest() noexcept { return min(); }

      static constexpr int digits = (sizeof(char32_t) * 8 - ((char32_t)(-1) < 0));
      static constexpr int digits10 = ((sizeof(char32_t) * 8 - ((char32_t)(-1) < 0)) * 643L / 2136);
      static constexpr int max_digits10 = 0;
      static constexpr bool is_signed = ((char32_t)(-1) < 0);
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr char32_t
      epsilon() noexcept { return 0; }

      static constexpr char32_t
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr char32_t
      infinity() noexcept { return char32_t(); }

      static constexpr char32_t
      quiet_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      signaling_NaN() noexcept { return char32_t(); }

      static constexpr char32_t
      denorm_min() noexcept { return char32_t(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = !is_signed;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style = round_toward_zero;
    };



  template<>
    struct numeric_limits<short>
    {
      static constexpr bool is_specialized = true;

      static constexpr short
      min() noexcept { return -32767 - 1; }

      static constexpr short
      max() noexcept { return 32767; }


      static constexpr short
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(short) * 8 - ((short)(-1) < 0));
      static constexpr int digits10 = ((sizeof(short) * 8 - ((short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr short
      epsilon() noexcept { return 0; }

      static constexpr short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr short
      infinity() noexcept { return short(); }

      static constexpr short
      quiet_NaN() noexcept { return short(); }

      static constexpr short
      signaling_NaN() noexcept { return short(); }

      static constexpr short
      denorm_min() noexcept { return short(); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned short>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned short
      min() noexcept { return 0; }

      static constexpr unsigned short
      max() noexcept { return 32767 * 2U + 1; }


      static constexpr unsigned short
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned short) * 8 - ((unsigned short)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned short
      epsilon() noexcept { return 0; }

      static constexpr unsigned short
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned short
      infinity() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      quiet_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      signaling_NaN() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr unsigned short
      denorm_min() noexcept
      { return static_cast<unsigned short>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<int>
    {
      static constexpr bool is_specialized = true;

      static constexpr int
      min() noexcept { return -2147483647 - 1; }

      static constexpr int
      max() noexcept { return 2147483647; }


      static constexpr int
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(int) * 8 - ((int)(-1) < 0));
      static constexpr int digits10 = ((sizeof(int) * 8 - ((int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr int
      epsilon() noexcept { return 0; }

      static constexpr int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr int
      infinity() noexcept { return static_cast<int>(0); }

      static constexpr int
      quiet_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      signaling_NaN() noexcept { return static_cast<int>(0); }

      static constexpr int
      denorm_min() noexcept { return static_cast<int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned int>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned int
      min() noexcept { return 0; }

      static constexpr unsigned int
      max() noexcept { return 2147483647 * 2U + 1; }


      static constexpr unsigned int
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned int) * 8 - ((unsigned int)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned int
      epsilon() noexcept { return 0; }

      static constexpr unsigned int
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned int
      infinity() noexcept { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      quiet_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      signaling_NaN() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr unsigned int
      denorm_min() noexcept
      { return static_cast<unsigned int>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long
      min() noexcept { return -2147483647L - 1; }

      static constexpr long
      max() noexcept { return 2147483647L; }


      static constexpr long
      lowest() noexcept { return min(); }


      static constexpr int digits = (sizeof(long) * 8 - ((long)(-1) < 0));
      static constexpr int digits10 = ((sizeof(long) * 8 - ((long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long
      epsilon() noexcept { return 0; }

      static constexpr long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long
      infinity() noexcept { return static_cast<long>(0); }

      static constexpr long
      quiet_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      signaling_NaN() noexcept { return static_cast<long>(0); }

      static constexpr long
      denorm_min() noexcept { return static_cast<long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long
      min() noexcept { return 0; }

      static constexpr unsigned long
      max() noexcept { return 2147483647L * 2UL + 1; }


      static constexpr unsigned long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long) * 8 - ((unsigned long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long
      infinity() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      quiet_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      signaling_NaN() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr unsigned long
      denorm_min() noexcept
      { return static_cast<unsigned long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr long long
      min() noexcept { return -9223372036854775807LL - 1; }

      static constexpr long long
      max() noexcept { return 9223372036854775807LL; }


      static constexpr long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(long long) * 8 - ((long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(long long) * 8 - ((long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr long long
      epsilon() noexcept { return 0; }

      static constexpr long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr long long
      infinity() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      quiet_NaN() noexcept { return static_cast<long long>(0); }

      static constexpr long long
      signaling_NaN() noexcept
      { return static_cast<long long>(0); }

      static constexpr long long
      denorm_min() noexcept { return static_cast<long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };


  template<>
    struct numeric_limits<unsigned long long>
    {
      static constexpr bool is_specialized = true;

      static constexpr unsigned long long
      min() noexcept { return 0; }

      static constexpr unsigned long long
      max() noexcept { return 9223372036854775807LL * 2ULL + 1; }


      static constexpr unsigned long long
      lowest() noexcept { return min(); }


      static constexpr int digits
       = (sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0));
      static constexpr int digits10
       = ((sizeof(unsigned long long) * 8 - ((unsigned long long)(-1) < 0)) * 643L / 2136);

      static constexpr int max_digits10 = 0;

      static constexpr bool is_signed = false;
      static constexpr bool is_integer = true;
      static constexpr bool is_exact = true;
      static constexpr int radix = 2;

      static constexpr unsigned long long
      epsilon() noexcept { return 0; }

      static constexpr unsigned long long
      round_error() noexcept { return 0; }

      static constexpr int min_exponent = 0;
      static constexpr int min_exponent10 = 0;
      static constexpr int max_exponent = 0;
      static constexpr int max_exponent10 = 0;

      static constexpr bool has_infinity = false;
      static constexpr bool has_quiet_NaN = false;
      static constexpr bool has_signaling_NaN = false;
      static constexpr float_denorm_style has_denorm
       = denorm_absent;
      static constexpr bool has_denorm_loss = false;

      static constexpr unsigned long long
      infinity() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      quiet_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      signaling_NaN() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr unsigned long long
      denorm_min() noexcept
      { return static_cast<unsigned long long>(0); }

      static constexpr bool is_iec559 = false;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = true;

      static constexpr bool traps = true;
      static constexpr bool tinyness_before = false;
      static constexpr float_round_style round_style
       = round_toward_zero;
    };
# 1552 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/limits" 3
  template<>
    struct numeric_limits<float>
    {
      static constexpr bool is_specialized = true;

      static constexpr float
      min() noexcept { return 1.1754943508222875e-38F; }

      static constexpr float
      max() noexcept { return 3.4028234663852886e+38F; }


      static constexpr float
      lowest() noexcept { return -3.4028234663852886e+38F; }


      static constexpr int digits = 24;
      static constexpr int digits10 = 6;

      static constexpr int max_digits10
  = (2 + (24) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr float
      epsilon() noexcept { return 1.1920928955078125e-7F; }

      static constexpr float
      round_error() noexcept { return 0.5F; }

      static constexpr int min_exponent = (-125);
      static constexpr int min_exponent10 = (-37);
      static constexpr int max_exponent = 128;
      static constexpr int max_exponent10 = 38;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
       = false;

      static constexpr float
      infinity() noexcept { return __builtin_huge_valf(); }

      static constexpr float
      quiet_NaN() noexcept { return __builtin_nanf(""); }

      static constexpr float
      signaling_NaN() noexcept { return __builtin_nansf(""); }

      static constexpr float
      denorm_min() noexcept { return 1.4012984643248171e-45F; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<double>
    {
      static constexpr bool is_specialized = true;

      static constexpr double
      min() noexcept { return double(2.2250738585072014e-308L); }

      static constexpr double
      max() noexcept { return double(1.7976931348623157e+308L); }


      static constexpr double
      lowest() noexcept { return -double(1.7976931348623157e+308L); }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr double
      epsilon() noexcept { return double(2.2204460492503131e-16L); }

      static constexpr double
      round_error() noexcept { return 0.5; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
        = false;

      static constexpr double
      infinity() noexcept { return __builtin_huge_val(); }

      static constexpr double
      quiet_NaN() noexcept { return __builtin_nan(""); }

      static constexpr double
      signaling_NaN() noexcept { return __builtin_nans(""); }

      static constexpr double
      denorm_min() noexcept { return double(4.9406564584124654e-324L); }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before
       = false;
      static constexpr float_round_style round_style
       = round_to_nearest;
    };






  template<>
    struct numeric_limits<long double>
    {
      static constexpr bool is_specialized = true;

      static constexpr long double
      min() noexcept { return 2.2250738585072014e-308L; }

      static constexpr long double
      max() noexcept { return 1.7976931348623157e+308L; }


      static constexpr long double
      lowest() noexcept { return -1.7976931348623157e+308L; }


      static constexpr int digits = 53;
      static constexpr int digits10 = 15;

      static constexpr int max_digits10
  = (2 + (53) * 643L / 2136);

      static constexpr bool is_signed = true;
      static constexpr bool is_integer = false;
      static constexpr bool is_exact = false;
      static constexpr int radix = 2;

      static constexpr long double
      epsilon() noexcept { return 2.2204460492503131e-16L; }

      static constexpr long double
      round_error() noexcept { return 0.5L; }

      static constexpr int min_exponent = (-1021);
      static constexpr int min_exponent10 = (-307);
      static constexpr int max_exponent = 1024;
      static constexpr int max_exponent10 = 308;

      static constexpr bool has_infinity = 1;
      static constexpr bool has_quiet_NaN = 1;
      static constexpr bool has_signaling_NaN = has_quiet_NaN;
      static constexpr float_denorm_style has_denorm
 = bool(1) ? denorm_present : denorm_absent;
      static constexpr bool has_denorm_loss
 = false;

      static constexpr long double
      infinity() noexcept { return __builtin_huge_vall(); }

      static constexpr long double
      quiet_NaN() noexcept { return __builtin_nanl(""); }

      static constexpr long double
      signaling_NaN() noexcept { return __builtin_nansl(""); }

      static constexpr long double
      denorm_min() noexcept { return 4.9406564584124654e-324L; }

      static constexpr bool is_iec559
 = has_infinity && has_quiet_NaN && has_denorm == denorm_present;
      static constexpr bool is_bounded = true;
      static constexpr bool is_modulo = false;

      static constexpr bool traps = false;
      static constexpr bool tinyness_before =
      false;
      static constexpr float_round_style round_style =
            round_to_nearest;
    };






}
# 4 "../Quadris/Font.cpp" 2





# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/GLES/gl.h" 1





# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/GLES/glplatform.h" 1
# 20 "C:\\ndk/platforms/android-9/arch-arm/usr/include/GLES/glplatform.h"
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/KHR/khrplatform.h" 1
# 135 "C:\\ndk/platforms/android-9/arch-arm/usr/include/KHR/khrplatform.h"
typedef int32_t khronos_int32_t;
typedef uint32_t khronos_uint32_t;
typedef int64_t khronos_int64_t;
typedef uint64_t khronos_uint64_t;
# 213 "C:\\ndk/platforms/android-9/arch-arm/usr/include/KHR/khrplatform.h"
typedef signed char khronos_int8_t;
typedef unsigned char khronos_uint8_t;
typedef signed short int khronos_int16_t;
typedef unsigned short int khronos_uint16_t;
typedef signed long int khronos_intptr_t;
typedef unsigned long int khronos_uintptr_t;
typedef signed long int khronos_ssize_t;
typedef unsigned long int khronos_usize_t;





typedef float khronos_float_t;
# 239 "C:\\ndk/platforms/android-9/arch-arm/usr/include/KHR/khrplatform.h"
typedef khronos_uint64_t khronos_utime_nanoseconds_t;
typedef khronos_int64_t khronos_stime_nanoseconds_t;
# 21 "C:\\ndk/platforms/android-9/arch-arm/usr/include/GLES/glplatform.h" 2
# 7 "C:\\ndk/platforms/android-9/arch-arm/usr/include/GLES/gl.h" 2


extern "C" {







typedef void GLvoid;
typedef char GLchar;
typedef unsigned int GLenum;
typedef unsigned char GLboolean;
typedef unsigned int GLbitfield;
typedef khronos_int8_t GLbyte;
typedef short GLshort;
typedef int GLint;
typedef int GLsizei;
typedef khronos_uint8_t GLubyte;
typedef unsigned short GLushort;
typedef unsigned int GLuint;
typedef khronos_float_t GLfloat;
typedef khronos_float_t GLclampf;
typedef khronos_int32_t GLfixed;
typedef khronos_int32_t GLclampx;

typedef khronos_intptr_t GLintptr;
typedef khronos_ssize_t GLsizeiptr;
# 593 "C:\\ndk/platforms/android-9/arch-arm/usr/include/GLES/gl.h"
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glAlphaFunc (GLenum func, GLclampf ref);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glClearColor (GLclampf red, GLclampf green, GLclampf blue, GLclampf alpha);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glClearDepthf (GLclampf depth);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glClipPlanef (GLenum plane, const GLfloat *equation);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glColor4f (GLfloat red, GLfloat green, GLfloat blue, GLfloat alpha);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glDepthRangef (GLclampf zNear, GLclampf zFar);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glFogf (GLenum pname, GLfloat param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glFogfv (GLenum pname, const GLfloat *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glFrustumf (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetClipPlanef (GLenum pname, GLfloat eqn[4]);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetFloatv (GLenum pname, GLfloat *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetLightfv (GLenum light, GLenum pname, GLfloat *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetMaterialfv (GLenum face, GLenum pname, GLfloat *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetTexEnvfv (GLenum env, GLenum pname, GLfloat *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetTexParameterfv (GLenum target, GLenum pname, GLfloat *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glLightModelf (GLenum pname, GLfloat param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glLightModelfv (GLenum pname, const GLfloat *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glLightf (GLenum light, GLenum pname, GLfloat param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glLightfv (GLenum light, GLenum pname, const GLfloat *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glLineWidth (GLfloat width);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glLoadMatrixf (const GLfloat *m);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glMaterialf (GLenum face, GLenum pname, GLfloat param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glMaterialfv (GLenum face, GLenum pname, const GLfloat *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glMultMatrixf (const GLfloat *m);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glMultiTexCoord4f (GLenum target, GLfloat s, GLfloat t, GLfloat r, GLfloat q);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glNormal3f (GLfloat nx, GLfloat ny, GLfloat nz);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glOrthof (GLfloat left, GLfloat right, GLfloat bottom, GLfloat top, GLfloat zNear, GLfloat zFar);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glPointParameterf (GLenum pname, GLfloat param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glPointParameterfv (GLenum pname, const GLfloat *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glPointSize (GLfloat size);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glPolygonOffset (GLfloat factor, GLfloat units);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glRotatef (GLfloat angle, GLfloat x, GLfloat y, GLfloat z);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glScalef (GLfloat x, GLfloat y, GLfloat z);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTexEnvf (GLenum target, GLenum pname, GLfloat param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTexEnvfv (GLenum target, GLenum pname, const GLfloat *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTexParameterf (GLenum target, GLenum pname, GLfloat param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTexParameterfv (GLenum target, GLenum pname, const GLfloat *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTranslatef (GLfloat x, GLfloat y, GLfloat z);


__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glActiveTexture (GLenum texture);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glAlphaFuncx (GLenum func, GLclampx ref);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glBindBuffer (GLenum target, GLuint buffer);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glBindTexture (GLenum target, GLuint texture);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glBlendFunc (GLenum sfactor, GLenum dfactor);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glBufferData (GLenum target, GLsizeiptr size, const GLvoid *data, GLenum usage);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glBufferSubData (GLenum target, GLintptr offset, GLsizeiptr size, const GLvoid *data);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glClear (GLbitfield mask);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glClearColorx (GLclampx red, GLclampx green, GLclampx blue, GLclampx alpha);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glClearDepthx (GLclampx depth);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glClearStencil (GLint s);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glClientActiveTexture (GLenum texture);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glClipPlanex (GLenum plane, const GLfixed *equation);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glColor4ub (GLubyte red, GLubyte green, GLubyte blue, GLubyte alpha);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glColor4x (GLfixed red, GLfixed green, GLfixed blue, GLfixed alpha);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glColorMask (GLboolean red, GLboolean green, GLboolean blue, GLboolean alpha);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glColorPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glCompressedTexImage2D (GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLsizei imageSize, const GLvoid *data);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glCompressedTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLsizei imageSize, const GLvoid *data);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glCopyTexImage2D (GLenum target, GLint level, GLenum internalformat, GLint x, GLint y, GLsizei width, GLsizei height, GLint border);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glCopyTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLint x, GLint y, GLsizei width, GLsizei height);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glCullFace (GLenum mode);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glDeleteBuffers (GLsizei n, const GLuint *buffers);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glDeleteTextures (GLsizei n, const GLuint *textures);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glDepthFunc (GLenum func);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glDepthMask (GLboolean flag);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glDepthRangex (GLclampx zNear, GLclampx zFar);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glDisable (GLenum cap);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glDisableClientState (GLenum array);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glDrawArrays (GLenum mode, GLint first, GLsizei count);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glDrawElements (GLenum mode, GLsizei count, GLenum type, const GLvoid *indices);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glEnable (GLenum cap);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glEnableClientState (GLenum array);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glFinish (void);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glFlush (void);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glFogx (GLenum pname, GLfixed param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glFogxv (GLenum pname, const GLfixed *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glFrontFace (GLenum mode);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glFrustumx (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetBooleanv (GLenum pname, GLboolean *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetBufferParameteriv (GLenum target, GLenum pname, GLint *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetClipPlanex (GLenum pname, GLfixed eqn[4]);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGenBuffers (GLsizei n, GLuint *buffers);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGenTextures (GLsizei n, GLuint *textures);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) GLenum glGetError (void);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetFixedv (GLenum pname, GLfixed *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetIntegerv (GLenum pname, GLint *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetLightxv (GLenum light, GLenum pname, GLfixed *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetMaterialxv (GLenum face, GLenum pname, GLfixed *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetPointerv (GLenum pname, GLvoid **params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) const GLubyte * glGetString (GLenum name);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetTexEnviv (GLenum env, GLenum pname, GLint *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetTexEnvxv (GLenum env, GLenum pname, GLfixed *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetTexParameteriv (GLenum target, GLenum pname, GLint *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glGetTexParameterxv (GLenum target, GLenum pname, GLfixed *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glHint (GLenum target, GLenum mode);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) GLboolean glIsBuffer (GLuint buffer);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) GLboolean glIsEnabled (GLenum cap);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) GLboolean glIsTexture (GLuint texture);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glLightModelx (GLenum pname, GLfixed param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glLightModelxv (GLenum pname, const GLfixed *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glLightx (GLenum light, GLenum pname, GLfixed param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glLightxv (GLenum light, GLenum pname, const GLfixed *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glLineWidthx (GLfixed width);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glLoadIdentity (void);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glLoadMatrixx (const GLfixed *m);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glLogicOp (GLenum opcode);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glMaterialx (GLenum face, GLenum pname, GLfixed param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glMaterialxv (GLenum face, GLenum pname, const GLfixed *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glMatrixMode (GLenum mode);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glMultMatrixx (const GLfixed *m);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glMultiTexCoord4x (GLenum target, GLfixed s, GLfixed t, GLfixed r, GLfixed q);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glNormal3x (GLfixed nx, GLfixed ny, GLfixed nz);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glNormalPointer (GLenum type, GLsizei stride, const GLvoid *pointer);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glOrthox (GLfixed left, GLfixed right, GLfixed bottom, GLfixed top, GLfixed zNear, GLfixed zFar);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glPixelStorei (GLenum pname, GLint param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glPointParameterx (GLenum pname, GLfixed param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glPointParameterxv (GLenum pname, const GLfixed *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glPointSizex (GLfixed size);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glPolygonOffsetx (GLfixed factor, GLfixed units);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glPopMatrix (void);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glPushMatrix (void);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glReadPixels (GLint x, GLint y, GLsizei width, GLsizei height, GLenum format, GLenum type, GLvoid *pixels);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glRotatex (GLfixed angle, GLfixed x, GLfixed y, GLfixed z);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glSampleCoverage (GLclampf value, GLboolean invert);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glSampleCoveragex (GLclampx value, GLboolean invert);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glScalex (GLfixed x, GLfixed y, GLfixed z);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glScissor (GLint x, GLint y, GLsizei width, GLsizei height);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glShadeModel (GLenum mode);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glStencilFunc (GLenum func, GLint ref, GLuint mask);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glStencilMask (GLuint mask);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glStencilOp (GLenum fail, GLenum zfail, GLenum zpass);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTexCoordPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTexEnvi (GLenum target, GLenum pname, GLint param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTexEnvx (GLenum target, GLenum pname, GLfixed param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTexEnviv (GLenum target, GLenum pname, const GLint *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTexEnvxv (GLenum target, GLenum pname, const GLfixed *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTexImage2D (GLenum target, GLint level, GLint internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, const GLvoid *pixels);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTexParameteri (GLenum target, GLenum pname, GLint param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTexParameterx (GLenum target, GLenum pname, GLfixed param);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTexParameteriv (GLenum target, GLenum pname, const GLint *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTexParameterxv (GLenum target, GLenum pname, const GLfixed *params);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTexSubImage2D (GLenum target, GLint level, GLint xoffset, GLint yoffset, GLsizei width, GLsizei height, GLenum format, GLenum type, const GLvoid *pixels);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glTranslatex (GLfixed x, GLfixed y, GLfixed z);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glVertexPointer (GLint size, GLenum type, GLsizei stride, const GLvoid *pointer);
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glViewport (GLint x, GLint y, GLsizei width, GLsizei height);
# 757 "C:\\ndk/platforms/android-9/arch-arm/usr/include/GLES/gl.h"
__attribute__((visibility("default"))) __attribute__((pcs("aapcs"))) void glPointSizePointerOES (GLenum type, GLsizei stride, const GLvoid *pointer);
# 766 "C:\\ndk/platforms/android-9/arch-arm/usr/include/GLES/gl.h"
}
# 10 "../Quadris/Font.cpp" 2



# 1 "../freetype/include/ft2build.h" 1
# 37 "../freetype/include/ft2build.h"
# 1 "../freetype/include/config/ftheader.h" 1
# 38 "../freetype/include/ft2build.h" 2
# 14 "../Quadris/Font.cpp" 2
# 1 "../freetype/include/freetype.h" 1
# 33 "../freetype/include/freetype.h"
# 1 "../freetype/include/config/ftconfig.h" 1
# 42 "../freetype/include/config/ftconfig.h"
# 1 "../freetype/include/config/ftoption.h" 1
# 26 "../freetype/include/config/ftoption.h"
extern "C" {
# 893 "../freetype/include/config/ftoption.h"
}
# 43 "../freetype/include/config/ftconfig.h" 2
# 1 "../freetype/include/config/ftstdlib.h" 1
# 36 "../freetype/include/config/ftstdlib.h"
# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 1 3 4
# 37 "../freetype/include/config/ftstdlib.h" 2
# 77 "../freetype/include/config/ftstdlib.h"
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/string.h" 1
# 32 "C:\\ndk/platforms/android-9/arch-arm/usr/include/string.h"
# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 1 3 4
# 33 "C:\\ndk/platforms/android-9/arch-arm/usr/include/string.h" 2
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/malloc.h" 1
# 26 "C:\\ndk/platforms/android-9/arch-arm/usr/include/malloc.h"
# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 1 3 4
# 27 "C:\\ndk/platforms/android-9/arch-arm/usr/include/malloc.h" 2

extern "C" {

extern __attribute__((malloc)) void* malloc(size_t);
extern __attribute__((malloc)) void* calloc(size_t, size_t);
extern void* realloc(void *, size_t);
extern void free(void *);

extern void* memalign(size_t alignment, size_t bytesize);
extern size_t malloc_usable_size(const void*);

extern void* valloc(size_t bytesize);
extern void* pvalloc(size_t bytesize);



struct mallinfo {
  size_t arena;
  size_t ordblks;
  size_t smblks;
  size_t hblks;
  size_t hblkhd;
  size_t usmblks;
  size_t fsmblks;
  size_t uordblks;
  size_t fordblks;
  size_t keepcost;
};


extern struct mallinfo mallinfo(void);

}
# 34 "C:\\ndk/platforms/android-9/arch-arm/usr/include/string.h" 2

extern "C" {

extern void* memccpy(void *, const void *, int, size_t);
extern void* memchr(const void *, int, size_t);
extern void* memrchr(const void *, int, size_t);
extern int memcmp(const void *, const void *, size_t);
extern void* memcpy(void *, const void *, size_t);
extern void* memmove(void *, const void *, size_t);
extern void* memset(void *, int, size_t);
extern void* memmem(const void *, size_t, const void *, size_t);
extern void memswap(void *, void *, size_t);

extern char* index(const char *, int);
extern char* rindex(const char *, int);
extern char* strchr(const char *, int);
extern char* strrchr(const char *, int);

extern size_t strlen(const char *);
extern int strcmp(const char *, const char *);
extern char* strcpy(char *, const char *);
extern char* strcat(char *, const char *);

extern int strcasecmp(const char *, const char *);
extern int strncasecmp(const char *, const char *, size_t);
extern char* strdup(const char *);

extern char* strstr(const char *, const char *);
extern char* strcasestr(const char *haystack, const char *needle);
extern char* strtok(char *, const char *);
extern char* strtok_r(char *, const char *, char**);

extern char* strerror(int);
extern int strerror_r(int errnum, char *buf, size_t n);

extern size_t strnlen(const char *, size_t);
extern char* strncat(char *, const char *, size_t);
extern char* strndup(const char *, size_t);
extern int strncmp(const char *, const char *, size_t);
extern char* strncpy(char *, const char *, size_t);

extern size_t strlcat(char *, const char *, size_t);
extern size_t strlcpy(char *, const char *, size_t);

extern size_t strcspn(const char *, const char *);
extern char* strpbrk(const char *, const char *);
extern char* strsep(char **, const char *);
extern size_t strspn(const char *, const char *);

extern char* strsignal(int sig);

extern int strcoll(const char *, const char *);
extern size_t strxfrm(char *, const char *, size_t);

}
# 78 "../freetype/include/config/ftstdlib.h" 2
# 101 "../freetype/include/config/ftstdlib.h"
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdio.h" 1
# 54 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdio.h"
# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stdarg.h" 1 3 4
# 40 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stdarg.h" 3 4
typedef __builtin_va_list __gnuc_va_list;
# 55 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdio.h" 2



# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 1 3 4
# 59 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdio.h" 2


# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 1 3 4
# 62 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdio.h" 2



typedef off_t fpos_t;
# 74 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdio.h"
struct __sbuf {
 unsigned char *_base;
 int _size;
};
# 106 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdio.h"
typedef struct __sFILE {
 unsigned char *_p;
 int _r;
 int _w;
 short _flags;
 short _file;
 struct __sbuf _bf;
 int _lbfsize;


 void *_cookie;
 int (*_close)(void *);
 int (*_read)(void *, char *, int);
 fpos_t (*_seek)(void *, fpos_t, int);
 int (*_write)(void *, const char *, int);


 struct __sbuf _ext;

 unsigned char *_up;
 int _ur;


 unsigned char _ubuf[3];
 unsigned char _nbuf[1];


 struct __sbuf _lb;


 int _blksize;
 fpos_t _offset;
} FILE;

extern "C" {
extern FILE __sF[];
}
# 210 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdio.h"
extern "C" {
void clearerr(FILE *);
int fclose(FILE *);
int feof(FILE *);
int ferror(FILE *);
int fflush(FILE *);
int fgetc(FILE *);
int fgetpos(FILE *, fpos_t *);
char *fgets(char *, int, FILE *);
FILE *fopen(const char *, const char *);
int fprintf(FILE *, const char *, ...);
int fputc(int, FILE *);
int fputs(const char *, FILE *);
size_t fread(void *, size_t, size_t, FILE *);
FILE *freopen(const char *, const char *, FILE *);
int fscanf(FILE *, const char *, ...);
int fseek(FILE *, long, int);
int fseeko(FILE *, off_t, int);
int fsetpos(FILE *, const fpos_t *);
long ftell(FILE *);
off_t ftello(FILE *);
size_t fwrite(const void *, size_t, size_t, FILE *);
int getc(FILE *);
int getchar(void);
char *gets(char *);



extern int sys_nerr;
extern char *sys_errlist[];

void perror(const char *);
int printf(const char *, ...);
int putc(int, FILE *);
int putchar(int);
int puts(const char *);
int remove(const char *);
int rename(const char *, const char *);
void rewind(FILE *);
int scanf(const char *, ...);
void setbuf(FILE *, char *);
int setvbuf(FILE *, char *, int, size_t);
int sprintf(char *, const char *, ...);
int sscanf(const char *, const char *, ...);
FILE *tmpfile(void);
char *tmpnam(char *);
int ungetc(int, FILE *);
int vfprintf(FILE *, const char *, __va_list);
int vprintf(const char *, __va_list);
int vsprintf(char *, const char *, __va_list);


int snprintf(char *, size_t, const char *, ...)
  __attribute__((__format__ (printf, 3, 4)))
  __attribute__((__nonnull__ (3)));
int vfscanf(FILE *, const char *, __va_list)
  __attribute__((__format__ (scanf, 2, 0)))
  __attribute__((__nonnull__ (2)));
int vscanf(const char *, __va_list)
  __attribute__((__format__ (scanf, 1, 0)))
  __attribute__((__nonnull__ (1)));
int vsnprintf(char *, size_t, const char *, __va_list)
  __attribute__((__format__ (printf, 3, 0)))
  __attribute__((__nonnull__ (3)));
int vsscanf(const char *, const char *, __va_list)
  __attribute__((__format__ (scanf, 2, 0)))
  __attribute__((__nonnull__ (2)));


}
# 289 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdio.h"
extern "C" {




FILE *fdopen(int, const char *);
int fileno(FILE *);


int pclose(FILE *);
FILE *popen(const char *, const char *);



void flockfile(FILE *);
int ftrylockfile(FILE *);
void funlockfile(FILE *);





int getc_unlocked(FILE *);
int getchar_unlocked(void);
int putc_unlocked(int, FILE *);
int putchar_unlocked(int);



char *tempnam(const char *, const char *);

}







extern "C" {
int asprintf(char **, const char *, ...)
  __attribute__((__format__ (printf, 2, 3)))
  __attribute__((__nonnull__ (2)));
char *fgetln(FILE *, size_t *);
int fpurge(FILE *);
int getw(FILE *);
int putw(int, FILE *);
void setbuffer(FILE *, char *, int);
int setlinebuf(FILE *);
int vasprintf(char **, const char *, __va_list)
  __attribute__((__format__ (printf, 2, 0)))
  __attribute__((__nonnull__ (2)));
}




extern "C" {
FILE *funopen(const void *,
  int (*)(void *, char *, int),
  int (*)(void *, const char *, int),
  fpos_t (*)(void *, fpos_t, int),
  int (*)(void *));
}
# 390 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdio.h"
int fdprintf(int, const char*, ...);
int vfdprintf(int, const char*, __va_list);
# 102 "../freetype/include/config/ftstdlib.h" 2
# 119 "../freetype/include/config/ftstdlib.h"
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdlib.h" 1
# 37 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdlib.h"
# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 1 3 4
# 38 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdlib.h" 2

# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 1 3 4
# 40 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdlib.h" 2

# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/alloca.h" 1
# 42 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdlib.h" 2
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/strings.h" 1
# 45 "C:\\ndk/platforms/android-9/arch-arm/usr/include/strings.h"
extern "C" {
int bcmp(const void *, const void *, size_t);
void bcopy(const void *, void *, size_t);
void bzero(void *, size_t);
int ffs(int);
char *index(const char *, int);
char *rindex(const char *, int);
int strcasecmp(const char *, const char *);
int strncasecmp(const char *, const char *, size_t);
}
# 43 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdlib.h" 2
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/memory.h" 1
# 44 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdlib.h" 2

extern "C" {




extern __attribute__((__noreturn__)) void exit(int);
extern __attribute__((__noreturn__)) void abort(void);
extern int atexit(void (*)(void));

extern char *getenv(const char *);
extern int putenv(const char *);
extern int setenv(const char *, const char *, int);
extern int unsetenv(const char *);
extern int clearenv(void);

extern char *mkdtemp(char *);
extern char *mktemp (char *);
extern int mkstemp (char *);

extern long strtol(const char *, char **, int);
extern long long strtoll(const char *, char **, int);
extern unsigned long strtoul(const char *, char **, int);
extern unsigned long long strtoull(const char *, char **, int);
extern double strtod(const char *nptr, char **endptr) __attribute__((pcs("aapcs")));

__attribute__((pcs("aapcs")))
static __inline__ float strtof(const char *nptr, char **endptr)
{
    return (float)strtod(nptr, endptr);
}

extern int atoi(const char *);
extern long atol(const char *);
extern long long atoll(const char *);

 __attribute__((pcs("aapcs")))
static __inline__ double atof(const char *nptr)
{
    return (strtod(nptr, __null));
}

static __inline__ int abs(int __n) {
    return (__n < 0) ? -__n : __n;
}

static __inline__ long labs(long __n) {
    return (__n < 0L) ? -__n : __n;
}

static __inline__ long long llabs(long long __n) {
    return (__n < 0LL) ? -__n : __n;
}

extern char * realpath(const char *path, char *resolved);
extern int system(const char * string);

extern void * bsearch(const void *key, const void *base0,
 size_t nmemb, size_t size,
 int (*compar)(const void *, const void *));

extern void qsort(void *, size_t, size_t, int (*)(const void *, const void *));

extern long jrand48(unsigned short *);
extern long mrand48(void);
extern long nrand48(unsigned short *);
extern long lrand48(void);
extern unsigned short *seed48(unsigned short*);
extern double erand48(unsigned short xsubi[3]) __attribute__((pcs("aapcs")));
extern double drand48(void) __attribute__((pcs("aapcs")));
extern void srand48(long);
extern unsigned int arc4random(void);
extern void arc4random_stir(void);
extern void arc4random_addrandom(unsigned char *, int);


static __inline__ int rand(void) {
    return (int)lrand48();
}
static __inline__ void srand(unsigned int __s) {
    srand48(__s);
}
static __inline__ long random(void)
{
    return lrand48();
}
static __inline__ void srandom(unsigned int __s)
{
    srand48(__s);
}



extern int unlockpt(int);
extern char* ptsname(int);
extern int ptsname_r(int, char*, size_t);
extern int getpt(void);

static __inline__ int grantpt(int __fd __attribute((unused)))
{
  (void)__fd;
  return 0;
}

typedef struct {
    int quot;
    int rem;
} div_t;

extern div_t div(int, int);

typedef struct {
    long int quot;
    long int rem;
} ldiv_t;

extern ldiv_t ldiv(long, long);

typedef struct {
    long long int quot;
    long long int rem;
} lldiv_t;

extern lldiv_t lldiv(long long, long long);



extern int mblen(const char *, size_t);
extern size_t mbstowcs(wchar_t *, const char *, size_t);
extern int mbtowc(wchar_t *, const char *, size_t);


extern int wctomb(char *, wchar_t);
extern size_t wcstombs(char *, const wchar_t *, size_t);
# 186 "C:\\ndk/platforms/android-9/arch-arm/usr/include/stdlib.h"
}
# 120 "../freetype/include/config/ftstdlib.h" 2
# 155 "../freetype/include/config/ftstdlib.h"
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/setjmp.h" 1
# 44 "C:\\ndk/platforms/android-9/arch-arm/usr/include/setjmp.h"
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/machine/setjmp.h" 1
# 45 "C:\\ndk/platforms/android-9/arch-arm/usr/include/setjmp.h" 2

typedef long sigjmp_buf[64 + 1];
typedef long jmp_buf[64];

extern "C" {

int _setjmp(jmp_buf);
void _longjmp(jmp_buf, int);
void longjmperror(void);

int setjmp(jmp_buf);
void longjmp(jmp_buf, int);

int sigsetjmp(sigjmp_buf, int);
void siglongjmp(sigjmp_buf, int);

}
# 156 "../freetype/include/config/ftstdlib.h" 2
# 168 "../freetype/include/config/ftstdlib.h"
# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stdarg.h" 1 3 4
# 98 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stdarg.h" 3 4
typedef __gnuc_va_list va_list;
# 169 "../freetype/include/config/ftstdlib.h" 2
# 44 "../freetype/include/config/ftconfig.h" 2


extern "C" {
# 162 "../freetype/include/config/ftconfig.h"
  typedef signed short FT_Int16;
# 173 "../freetype/include/config/ftconfig.h"
  typedef unsigned short FT_UInt16;
# 233 "../freetype/include/config/ftconfig.h"
  typedef signed int FT_Int32;
  typedef unsigned int FT_UInt32;
# 249 "../freetype/include/config/ftconfig.h"
  typedef int FT_Fast;
  typedef unsigned int FT_UFast;
# 444 "../freetype/include/config/ftconfig.h"
}
# 34 "../freetype/include/freetype.h" 2
# 1 "../freetype/include/fttypes.h" 1
# 25 "../freetype/include/fttypes.h"
# 1 "../freetype/include/ftsystem.h" 1
# 26 "../freetype/include/ftsystem.h"
extern "C" {
# 66 "../freetype/include/ftsystem.h"
  typedef struct FT_MemoryRec_* FT_Memory;
# 88 "../freetype/include/ftsystem.h"
  typedef void*
  (*FT_Alloc_Func)( FT_Memory memory,
                    long size );
# 109 "../freetype/include/ftsystem.h"
  typedef void
  (*FT_Free_Func)( FT_Memory memory,
                   void* block );
# 142 "../freetype/include/ftsystem.h"
  typedef void*
  (*FT_Realloc_Func)( FT_Memory memory,
                      long cur_size,
                      long new_size,
                      void* block );
# 171 "../freetype/include/ftsystem.h"
  struct FT_MemoryRec_
  {
    void* user;
    FT_Alloc_Func alloc;
    FT_Free_Func free;
    FT_Realloc_Func realloc;
  };
# 200 "../freetype/include/ftsystem.h"
  typedef struct FT_StreamRec_* FT_Stream;
# 213 "../freetype/include/ftsystem.h"
  typedef union FT_StreamDesc_
  {
    long value;
    void* pointer;

  } FT_StreamDesc;
# 251 "../freetype/include/ftsystem.h"
  typedef unsigned long
  (*FT_Stream_IoFunc)( FT_Stream stream,
                       unsigned long offset,
                       unsigned char* buffer,
                       unsigned long count );
# 271 "../freetype/include/ftsystem.h"
  typedef void
  (*FT_Stream_CloseFunc)( FT_Stream stream );
# 330 "../freetype/include/ftsystem.h"
  typedef struct FT_StreamRec_
  {
    unsigned char* base;
    unsigned long size;
    unsigned long pos;

    FT_StreamDesc descriptor;
    FT_StreamDesc pathname;
    FT_Stream_IoFunc read;
    FT_Stream_CloseFunc close;

    FT_Memory memory;
    unsigned char* cursor;
    unsigned char* limit;

  } FT_StreamRec;




}
# 26 "../freetype/include/fttypes.h" 2
# 1 "../freetype/include/ftimage.h" 1
# 37 "../freetype/include/ftimage.h"
extern "C" {
# 58 "../freetype/include/ftimage.h"
  typedef signed long FT_Pos;
# 74 "../freetype/include/ftimage.h"
  typedef struct FT_Vector_
  {
    FT_Pos x;
    FT_Pos y;

  } FT_Vector;
# 115 "../freetype/include/ftimage.h"
  typedef struct FT_BBox_
  {
    FT_Pos xMin, yMin;
    FT_Pos xMax, yMax;

  } FT_BBox;
# 180 "../freetype/include/ftimage.h"
  typedef enum FT_Pixel_Mode_
  {
    FT_PIXEL_MODE_NONE = 0,
    FT_PIXEL_MODE_MONO,
    FT_PIXEL_MODE_GRAY,
    FT_PIXEL_MODE_GRAY2,
    FT_PIXEL_MODE_GRAY4,
    FT_PIXEL_MODE_LCD,
    FT_PIXEL_MODE_LCD_V,
    FT_PIXEL_MODE_BGRA,

    FT_PIXEL_MODE_MAX

  } FT_Pixel_Mode;
# 266 "../freetype/include/ftimage.h"
  typedef struct FT_Bitmap_
  {
    unsigned int rows;
    unsigned int width;
    int pitch;
    unsigned char* buffer;
    unsigned short num_grays;
    unsigned char pixel_mode;
    unsigned char palette_mode;
    void* palette;

  } FT_Bitmap;
# 339 "../freetype/include/ftimage.h"
  typedef struct FT_Outline_
  {
    short n_contours;
    short n_points;

    FT_Vector* points;
    char* tags;
    short* contours;

    int flags;

  } FT_Outline;
# 497 "../freetype/include/ftimage.h"
  typedef int
  (*FT_Outline_MoveToFunc)( const FT_Vector* to,
                            void* user );
# 524 "../freetype/include/ftimage.h"
  typedef int
  (*FT_Outline_LineToFunc)( const FT_Vector* to,
                            void* user );
# 555 "../freetype/include/ftimage.h"
  typedef int
  (*FT_Outline_ConicToFunc)( const FT_Vector* control,
                             const FT_Vector* to,
                             void* user );
# 587 "../freetype/include/ftimage.h"
  typedef int
  (*FT_Outline_CubicToFunc)( const FT_Vector* control1,
                             const FT_Vector* control2,
                             const FT_Vector* to,
                             void* user );
# 633 "../freetype/include/ftimage.h"
  typedef struct FT_Outline_Funcs_
  {
    FT_Outline_MoveToFunc move_to;
    FT_Outline_LineToFunc line_to;
    FT_Outline_ConicToFunc conic_to;
    FT_Outline_CubicToFunc cubic_to;

    int shift;
    FT_Pos delta;

  } FT_Outline_Funcs;
# 720 "../freetype/include/ftimage.h"
  typedef enum FT_Glyph_Format_
  {
    FT_GLYPH_FORMAT_NONE = ( ( (unsigned long)0 << 24 ) | ( (unsigned long)0 << 16 ) | ( (unsigned long)0 << 8 ) | (unsigned long)0 ),

    FT_GLYPH_FORMAT_COMPOSITE = ( ( (unsigned long)'c' << 24 ) | ( (unsigned long)'o' << 16 ) | ( (unsigned long)'m' << 8 ) | (unsigned long)'p' ),
    FT_GLYPH_FORMAT_BITMAP = ( ( (unsigned long)'b' << 24 ) | ( (unsigned long)'i' << 16 ) | ( (unsigned long)'t' << 8 ) | (unsigned long)'s' ),
    FT_GLYPH_FORMAT_OUTLINE = ( ( (unsigned long)'o' << 24 ) | ( (unsigned long)'u' << 16 ) | ( (unsigned long)'t' << 8 ) | (unsigned long)'l' ),
    FT_GLYPH_FORMAT_PLOTTER = ( ( (unsigned long)'p' << 24 ) | ( (unsigned long)'l' << 16 ) | ( (unsigned long)'o' << 8 ) | (unsigned long)'t' )

  } FT_Glyph_Format;
# 805 "../freetype/include/ftimage.h"
  typedef struct FT_RasterRec_* FT_Raster;
# 833 "../freetype/include/ftimage.h"
  typedef struct FT_Span_
  {
    short x;
    unsigned short len;
    unsigned char coverage;

  } FT_Span;
# 878 "../freetype/include/ftimage.h"
  typedef void
  (*FT_SpanFunc)( int y,
                  int count,
                  const FT_Span* spans,
                  void* user );
# 895 "../freetype/include/ftimage.h"
  typedef int
  (*FT_Raster_BitTest_Func)( int y,
                             int x,
                             void* user );
# 909 "../freetype/include/ftimage.h"
  typedef void
  (*FT_Raster_BitSet_Func)( int y,
                            int x,
                            void* user );
# 1012 "../freetype/include/ftimage.h"
  typedef struct FT_Raster_Params_
  {
    const FT_Bitmap* target;
    const void* source;
    int flags;
    FT_SpanFunc gray_spans;
    FT_SpanFunc black_spans;
    FT_Raster_BitTest_Func bit_test;
    FT_Raster_BitSet_Func bit_set;
    void* user;
    FT_BBox clip_box;

  } FT_Raster_Params;
# 1051 "../freetype/include/ftimage.h"
  typedef int
  (*FT_Raster_NewFunc)( void* memory,
                        FT_Raster* raster );
# 1069 "../freetype/include/ftimage.h"
  typedef void
  (*FT_Raster_DoneFunc)( FT_Raster raster );
# 1102 "../freetype/include/ftimage.h"
  typedef void
  (*FT_Raster_ResetFunc)( FT_Raster raster,
                          unsigned char* pool_base,
                          unsigned long pool_size );
# 1128 "../freetype/include/ftimage.h"
  typedef int
  (*FT_Raster_SetModeFunc)( FT_Raster raster,
                            unsigned long mode,
                            void* args );
# 1170 "../freetype/include/ftimage.h"
  typedef int
  (*FT_Raster_RenderFunc)( FT_Raster raster,
                           const FT_Raster_Params* params );
# 1196 "../freetype/include/ftimage.h"
  typedef struct FT_Raster_Funcs_
  {
    FT_Glyph_Format glyph_format;
    FT_Raster_NewFunc raster_new;
    FT_Raster_ResetFunc raster_reset;
    FT_Raster_SetModeFunc raster_set_mode;
    FT_Raster_RenderFunc raster_render;
    FT_Raster_DoneFunc raster_done;

  } FT_Raster_Funcs;




}
# 27 "../freetype/include/fttypes.h" 2

# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 1 3 4
# 29 "../freetype/include/fttypes.h" 2


extern "C" {
# 108 "../freetype/include/fttypes.h"
  typedef unsigned char FT_Bool;
# 120 "../freetype/include/fttypes.h"
  typedef signed short FT_FWord;
# 132 "../freetype/include/fttypes.h"
  typedef unsigned short FT_UFWord;
# 143 "../freetype/include/fttypes.h"
  typedef signed char FT_Char;
# 154 "../freetype/include/fttypes.h"
  typedef unsigned char FT_Byte;
# 165 "../freetype/include/fttypes.h"
  typedef const FT_Byte* FT_Bytes;
# 176 "../freetype/include/fttypes.h"
  typedef FT_UInt32 FT_Tag;
# 187 "../freetype/include/fttypes.h"
  typedef char FT_String;
# 198 "../freetype/include/fttypes.h"
  typedef signed short FT_Short;
# 209 "../freetype/include/fttypes.h"
  typedef unsigned short FT_UShort;
# 220 "../freetype/include/fttypes.h"
  typedef signed int FT_Int;
# 231 "../freetype/include/fttypes.h"
  typedef unsigned int FT_UInt;
# 242 "../freetype/include/fttypes.h"
  typedef signed long FT_Long;
# 253 "../freetype/include/fttypes.h"
  typedef unsigned long FT_ULong;
# 264 "../freetype/include/fttypes.h"
  typedef signed short FT_F2Dot14;
# 276 "../freetype/include/fttypes.h"
  typedef signed long FT_F26Dot6;
# 288 "../freetype/include/fttypes.h"
  typedef signed long FT_Fixed;
# 300 "../freetype/include/fttypes.h"
  typedef int FT_Error;
# 311 "../freetype/include/fttypes.h"
  typedef void* FT_Pointer;
# 324 "../freetype/include/fttypes.h"
  typedef size_t FT_Offset;
# 337 "../freetype/include/fttypes.h"
  typedef ptrdiff_t FT_PtrDist;
# 354 "../freetype/include/fttypes.h"
  typedef struct FT_UnitVector_
  {
    FT_F2Dot14 x;
    FT_F2Dot14 y;

  } FT_UnitVector;
# 385 "../freetype/include/fttypes.h"
  typedef struct FT_Matrix_
  {
    FT_Fixed xx, xy;
    FT_Fixed yx, yy;

  } FT_Matrix;
# 406 "../freetype/include/fttypes.h"
  typedef struct FT_Data_
  {
    const FT_Byte* pointer;
    FT_Int length;

  } FT_Data;
# 428 "../freetype/include/fttypes.h"
  typedef void (*FT_Generic_Finalizer)(void* object);
# 459 "../freetype/include/fttypes.h"
  typedef struct FT_Generic_
  {
    void* data;
    FT_Generic_Finalizer finalizer;

  } FT_Generic;
# 515 "../freetype/include/fttypes.h"
  typedef struct FT_ListNodeRec_* FT_ListNode;
# 526 "../freetype/include/fttypes.h"
  typedef struct FT_ListRec_* FT_List;
# 544 "../freetype/include/fttypes.h"
  typedef struct FT_ListNodeRec_
  {
    FT_ListNode prev;
    FT_ListNode next;
    void* data;

  } FT_ListNodeRec;
# 567 "../freetype/include/fttypes.h"
  typedef struct FT_ListRec_
  {
    FT_ListNode head;
    FT_ListNode tail;

  } FT_ListRec;
# 597 "../freetype/include/fttypes.h"
}
# 35 "../freetype/include/freetype.h" 2
# 1 "../freetype/include/fterrors.h" 1
# 89 "../freetype/include/fterrors.h"
# 1 "../freetype/include/ftmoderr.h" 1
# 122 "../freetype/include/ftmoderr.h"
  extern "C" {
# 138 "../freetype/include/ftmoderr.h"
  enum {



  FT_Mod_Err_Base = 0,
  FT_Mod_Err_Autofit = 0,
  FT_Mod_Err_BDF = 0,
  FT_Mod_Err_Bzip2 = 0,
  FT_Mod_Err_Cache = 0,
  FT_Mod_Err_CFF = 0,
  FT_Mod_Err_CID = 0,
  FT_Mod_Err_Gzip = 0,
  FT_Mod_Err_LZW = 0,
  FT_Mod_Err_OTvalid = 0,
  FT_Mod_Err_PCF = 0,
  FT_Mod_Err_PFR = 0,
  FT_Mod_Err_PSaux = 0,
  FT_Mod_Err_PShinter = 0,
  FT_Mod_Err_PSnames = 0,
  FT_Mod_Err_Raster = 0,
  FT_Mod_Err_SFNT = 0,
  FT_Mod_Err_Smooth = 0,
  FT_Mod_Err_TrueType = 0,
  FT_Mod_Err_Type1 = 0,
  FT_Mod_Err_Type42 = 0,
  FT_Mod_Err_Winfonts = 0,
  FT_Mod_Err_GXvalid = 0,



  FT_Mod_Err_Max };
# 182 "../freetype/include/ftmoderr.h"
  }
# 90 "../freetype/include/fterrors.h" 2
# 139 "../freetype/include/fterrors.h"
  extern "C" {
# 155 "../freetype/include/fterrors.h"
  enum {




# 1 "../freetype/include/fterrdef.h" 1
# 34 "../freetype/include/fterrdef.h"
  FT_Err_Ok = 0x00,


  FT_Err_Cannot_Open_Resource = 0x01 + 0,

  FT_Err_Unknown_File_Format = 0x02 + 0,

  FT_Err_Invalid_File_Format = 0x03 + 0,

  FT_Err_Invalid_Version = 0x04 + 0,

  FT_Err_Lower_Module_Version = 0x05 + 0,

  FT_Err_Invalid_Argument = 0x06 + 0,

  FT_Err_Unimplemented_Feature = 0x07 + 0,

  FT_Err_Invalid_Table = 0x08 + 0,

  FT_Err_Invalid_Offset = 0x09 + 0,

  FT_Err_Array_Too_Large = 0x0A + 0,

  FT_Err_Missing_Module = 0x0B + 0,

  FT_Err_Missing_Property = 0x0C + 0,




  FT_Err_Invalid_Glyph_Index = 0x10 + 0,

  FT_Err_Invalid_Character_Code = 0x11 + 0,

  FT_Err_Invalid_Glyph_Format = 0x12 + 0,

  FT_Err_Cannot_Render_Glyph = 0x13 + 0,

  FT_Err_Invalid_Outline = 0x14 + 0,

  FT_Err_Invalid_Composite = 0x15 + 0,

  FT_Err_Too_Many_Hints = 0x16 + 0,

  FT_Err_Invalid_Pixel_Size = 0x17 + 0,




  FT_Err_Invalid_Handle = 0x20 + 0,

  FT_Err_Invalid_Library_Handle = 0x21 + 0,

  FT_Err_Invalid_Driver_Handle = 0x22 + 0,

  FT_Err_Invalid_Face_Handle = 0x23 + 0,

  FT_Err_Invalid_Size_Handle = 0x24 + 0,

  FT_Err_Invalid_Slot_Handle = 0x25 + 0,

  FT_Err_Invalid_CharMap_Handle = 0x26 + 0,

  FT_Err_Invalid_Cache_Handle = 0x27 + 0,

  FT_Err_Invalid_Stream_Handle = 0x28 + 0,




  FT_Err_Too_Many_Drivers = 0x30 + 0,

  FT_Err_Too_Many_Extensions = 0x31 + 0,




  FT_Err_Out_Of_Memory = 0x40 + 0,

  FT_Err_Unlisted_Object = 0x41 + 0,




  FT_Err_Cannot_Open_Stream = 0x51 + 0,

  FT_Err_Invalid_Stream_Seek = 0x52 + 0,

  FT_Err_Invalid_Stream_Skip = 0x53 + 0,

  FT_Err_Invalid_Stream_Read = 0x54 + 0,

  FT_Err_Invalid_Stream_Operation = 0x55 + 0,

  FT_Err_Invalid_Frame_Operation = 0x56 + 0,

  FT_Err_Nested_Frame_Access = 0x57 + 0,

  FT_Err_Invalid_Frame_Read = 0x58 + 0,




  FT_Err_Raster_Uninitialized = 0x60 + 0,

  FT_Err_Raster_Corrupted = 0x61 + 0,

  FT_Err_Raster_Overflow = 0x62 + 0,

  FT_Err_Raster_Negative_Height = 0x63 + 0,




  FT_Err_Too_Many_Caches = 0x70 + 0,




  FT_Err_Invalid_Opcode = 0x80 + 0,

  FT_Err_Too_Few_Arguments = 0x81 + 0,

  FT_Err_Stack_Overflow = 0x82 + 0,

  FT_Err_Code_Overflow = 0x83 + 0,

  FT_Err_Bad_Argument = 0x84 + 0,

  FT_Err_Divide_By_Zero = 0x85 + 0,

  FT_Err_Invalid_Reference = 0x86 + 0,

  FT_Err_Debug_OpCode = 0x87 + 0,

  FT_Err_ENDF_In_Exec_Stream = 0x88 + 0,

  FT_Err_Nested_DEFS = 0x89 + 0,

  FT_Err_Invalid_CodeRange = 0x8A + 0,

  FT_Err_Execution_Too_Long = 0x8B + 0,

  FT_Err_Too_Many_Function_Defs = 0x8C + 0,

  FT_Err_Too_Many_Instruction_Defs = 0x8D + 0,

  FT_Err_Table_Missing = 0x8E + 0,

  FT_Err_Horiz_Header_Missing = 0x8F + 0,

  FT_Err_Locations_Missing = 0x90 + 0,

  FT_Err_Name_Table_Missing = 0x91 + 0,

  FT_Err_CMap_Table_Missing = 0x92 + 0,

  FT_Err_Hmtx_Table_Missing = 0x93 + 0,

  FT_Err_Post_Table_Missing = 0x94 + 0,

  FT_Err_Invalid_Horiz_Metrics = 0x95 + 0,

  FT_Err_Invalid_CharMap_Format = 0x96 + 0,

  FT_Err_Invalid_PPem = 0x97 + 0,

  FT_Err_Invalid_Vert_Metrics = 0x98 + 0,

  FT_Err_Could_Not_Find_Context = 0x99 + 0,

  FT_Err_Invalid_Post_Table_Format = 0x9A + 0,

  FT_Err_Invalid_Post_Table = 0x9B + 0,




  FT_Err_Syntax_Error = 0xA0 + 0,

  FT_Err_Stack_Underflow = 0xA1 + 0,

  FT_Err_Ignore = 0xA2 + 0,

  FT_Err_No_Unicode_Glyph_Name = 0xA3 + 0,

  FT_Err_Glyph_Too_Big = 0xA4 + 0,




  FT_Err_Missing_Startfont_Field = 0xB0 + 0,

  FT_Err_Missing_Font_Field = 0xB1 + 0,

  FT_Err_Missing_Size_Field = 0xB2 + 0,

  FT_Err_Missing_Fontboundingbox_Field = 0xB3 + 0,

  FT_Err_Missing_Chars_Field = 0xB4 + 0,

  FT_Err_Missing_Startchar_Field = 0xB5 + 0,

  FT_Err_Missing_Encoding_Field = 0xB6 + 0,

  FT_Err_Missing_Bbx_Field = 0xB7 + 0,

  FT_Err_Bbx_Too_Big = 0xB8 + 0,

  FT_Err_Corrupted_Font_Header = 0xB9 + 0,

  FT_Err_Corrupted_Font_Glyphs = 0xBA + 0,
# 161 "../freetype/include/fterrors.h" 2



  FT_Err_Max };
# 177 "../freetype/include/fterrors.h"
  }
# 36 "../freetype/include/freetype.h" 2


extern "C" {
# 309 "../freetype/include/freetype.h"
  typedef struct FT_Glyph_Metrics_
  {
    FT_Pos width;
    FT_Pos height;

    FT_Pos horiBearingX;
    FT_Pos horiBearingY;
    FT_Pos horiAdvance;

    FT_Pos vertBearingX;
    FT_Pos vertBearingY;
    FT_Pos vertAdvance;

  } FT_Glyph_Metrics;
# 363 "../freetype/include/freetype.h"
  typedef struct FT_Bitmap_Size_
  {
    FT_Short height;
    FT_Short width;

    FT_Pos size;

    FT_Pos x_ppem;
    FT_Pos y_ppem;

  } FT_Bitmap_Size;
# 406 "../freetype/include/freetype.h"
  typedef struct FT_LibraryRec_ *FT_Library;
# 426 "../freetype/include/freetype.h"
  typedef struct FT_ModuleRec_* FT_Module;
# 438 "../freetype/include/freetype.h"
  typedef struct FT_DriverRec_* FT_Driver;
# 452 "../freetype/include/freetype.h"
  typedef struct FT_RendererRec_* FT_Renderer;
# 484 "../freetype/include/freetype.h"
  typedef struct FT_FaceRec_* FT_Face;
# 515 "../freetype/include/freetype.h"
  typedef struct FT_SizeRec_* FT_Size;
# 536 "../freetype/include/freetype.h"
  typedef struct FT_GlyphSlotRec_* FT_GlyphSlot;
# 568 "../freetype/include/freetype.h"
  typedef struct FT_CharMapRec_* FT_CharMap;
# 742 "../freetype/include/freetype.h"
  typedef enum FT_Encoding_
  {
    FT_ENCODING_NONE = ( ( (FT_UInt32)(0) << 24 ) | ( (FT_UInt32)(0) << 16 ) | ( (FT_UInt32)(0) << 8 ) | (FT_UInt32)(0) ),

    FT_ENCODING_MS_SYMBOL = ( ( (FT_UInt32)('s') << 24 ) | ( (FT_UInt32)('y') << 16 ) | ( (FT_UInt32)('m') << 8 ) | (FT_UInt32)('b') ),
    FT_ENCODING_UNICODE = ( ( (FT_UInt32)('u') << 24 ) | ( (FT_UInt32)('n') << 16 ) | ( (FT_UInt32)('i') << 8 ) | (FT_UInt32)('c') ),

    FT_ENCODING_SJIS = ( ( (FT_UInt32)('s') << 24 ) | ( (FT_UInt32)('j') << 16 ) | ( (FT_UInt32)('i') << 8 ) | (FT_UInt32)('s') ),
    FT_ENCODING_GB2312 = ( ( (FT_UInt32)('g') << 24 ) | ( (FT_UInt32)('b') << 16 ) | ( (FT_UInt32)(' ') << 8 ) | (FT_UInt32)(' ') ),
    FT_ENCODING_BIG5 = ( ( (FT_UInt32)('b') << 24 ) | ( (FT_UInt32)('i') << 16 ) | ( (FT_UInt32)('g') << 8 ) | (FT_UInt32)('5') ),
    FT_ENCODING_WANSUNG = ( ( (FT_UInt32)('w') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('n') << 8 ) | (FT_UInt32)('s') ),
    FT_ENCODING_JOHAB = ( ( (FT_UInt32)('j') << 24 ) | ( (FT_UInt32)('o') << 16 ) | ( (FT_UInt32)('h') << 8 ) | (FT_UInt32)('a') ),


    FT_ENCODING_MS_SJIS = FT_ENCODING_SJIS,
    FT_ENCODING_MS_GB2312 = FT_ENCODING_GB2312,
    FT_ENCODING_MS_BIG5 = FT_ENCODING_BIG5,
    FT_ENCODING_MS_WANSUNG = FT_ENCODING_WANSUNG,
    FT_ENCODING_MS_JOHAB = FT_ENCODING_JOHAB,

    FT_ENCODING_ADOBE_STANDARD = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('O') << 8 ) | (FT_UInt32)('B') ),
    FT_ENCODING_ADOBE_EXPERT = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('B') << 8 ) | (FT_UInt32)('E') ),
    FT_ENCODING_ADOBE_CUSTOM = ( ( (FT_UInt32)('A') << 24 ) | ( (FT_UInt32)('D') << 16 ) | ( (FT_UInt32)('B') << 8 ) | (FT_UInt32)('C') ),
    FT_ENCODING_ADOBE_LATIN_1 = ( ( (FT_UInt32)('l') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('t') << 8 ) | (FT_UInt32)('1') ),

    FT_ENCODING_OLD_LATIN_2 = ( ( (FT_UInt32)('l') << 24 ) | ( (FT_UInt32)('a') << 16 ) | ( (FT_UInt32)('t') << 8 ) | (FT_UInt32)('2') ),

    FT_ENCODING_APPLE_ROMAN = ( ( (FT_UInt32)('a') << 24 ) | ( (FT_UInt32)('r') << 16 ) | ( (FT_UInt32)('m') << 8 ) | (FT_UInt32)('n') )

  } FT_Encoding;
# 816 "../freetype/include/freetype.h"
  typedef struct FT_CharMapRec_
  {
    FT_Face face;
    FT_Encoding encoding;
    FT_UShort platform_id;
    FT_UShort encoding_id;

  } FT_CharMapRec;
# 847 "../freetype/include/freetype.h"
  typedef struct FT_Face_InternalRec_* FT_Face_Internal;
# 995 "../freetype/include/freetype.h"
  typedef struct FT_FaceRec_
  {
    FT_Long num_faces;
    FT_Long face_index;

    FT_Long face_flags;
    FT_Long style_flags;

    FT_Long num_glyphs;

    FT_String* family_name;
    FT_String* style_name;

    FT_Int num_fixed_sizes;
    FT_Bitmap_Size* available_sizes;

    FT_Int num_charmaps;
    FT_CharMap* charmaps;

    FT_Generic generic;




    FT_BBox bbox;

    FT_UShort units_per_EM;
    FT_Short ascender;
    FT_Short descender;
    FT_Short height;

    FT_Short max_advance_width;
    FT_Short max_advance_height;

    FT_Short underline_position;
    FT_Short underline_thickness;

    FT_GlyphSlot glyph;
    FT_Size size;
    FT_CharMap charmap;



    FT_Driver driver;
    FT_Memory memory;
    FT_Stream stream;

    FT_ListRec sizes_list;

    FT_Generic autohint;
    void* extensions;

    FT_Face_Internal internal;



  } FT_FaceRec;
# 1404 "../freetype/include/freetype.h"
  typedef struct FT_Size_InternalRec_* FT_Size_Internal;
# 1462 "../freetype/include/freetype.h"
  typedef struct FT_Size_Metrics_
  {
    FT_UShort x_ppem;
    FT_UShort y_ppem;

    FT_Fixed x_scale;
    FT_Fixed y_scale;

    FT_Pos ascender;
    FT_Pos descender;
    FT_Pos height;
    FT_Pos max_advance;

  } FT_Size_Metrics;
# 1497 "../freetype/include/freetype.h"
  typedef struct FT_SizeRec_
  {
    FT_Face face;
    FT_Generic generic;
    FT_Size_Metrics metrics;
    FT_Size_Internal internal;

  } FT_SizeRec;
# 1523 "../freetype/include/freetype.h"
  typedef struct FT_SubGlyphRec_* FT_SubGlyph;
# 1535 "../freetype/include/freetype.h"
  typedef struct FT_Slot_InternalRec_* FT_Slot_Internal;
# 1706 "../freetype/include/freetype.h"
  typedef struct FT_GlyphSlotRec_
  {
    FT_Library library;
    FT_Face face;
    FT_GlyphSlot next;
    FT_UInt reserved;
    FT_Generic generic;

    FT_Glyph_Metrics metrics;
    FT_Fixed linearHoriAdvance;
    FT_Fixed linearVertAdvance;
    FT_Vector advance;

    FT_Glyph_Format format;

    FT_Bitmap bitmap;
    FT_Int bitmap_left;
    FT_Int bitmap_top;

    FT_Outline outline;

    FT_UInt num_subglyphs;
    FT_SubGlyph subglyphs;

    void* control_data;
    long control_len;

    FT_Pos lsb_delta;
    FT_Pos rsb_delta;

    void* other;

    FT_Slot_Internal internal;

  } FT_GlyphSlotRec;
# 1778 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Init_FreeType( FT_Library *alibrary );
# 1797 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Done_FreeType( FT_Library library );
# 1860 "../freetype/include/freetype.h"
  typedef struct FT_Parameter_
  {
    FT_ULong tag;
    FT_Pointer data;

  } FT_Parameter;
# 1926 "../freetype/include/freetype.h"
  typedef struct FT_Open_Args_
  {
    FT_UInt flags;
    const FT_Byte* memory_base;
    FT_Long memory_size;
    FT_String* pathname;
    FT_Stream stream;
    FT_Module driver;
    FT_Int num_params;
    FT_Parameter* params;

  } FT_Open_Args;
# 1969 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_New_Face( FT_Library library,
               const char* filepathname,
               FT_Long face_index,
               FT_Face *aface );
# 2007 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_New_Memory_Face( FT_Library library,
                      const FT_Byte* file_base,
                      FT_Long file_size,
                      FT_Long face_index,
                      FT_Face *aface );
# 2067 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Open_Face( FT_Library library,
                const FT_Open_Args* args,
                FT_Long face_index,
                FT_Face *aface );
# 2091 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Attach_File( FT_Face face,
                  const char* filepathname );
# 2126 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Attach_Stream( FT_Face face,
                    FT_Open_Args* parameters );
# 2154 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Reference_Face( FT_Face face );
# 2177 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Done_Face( FT_Face face );
# 2199 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Select_Size( FT_Face face,
                  FT_Int strike_index );
# 2246 "../freetype/include/freetype.h"
  typedef enum FT_Size_Request_Type_
  {
    FT_SIZE_REQUEST_TYPE_NOMINAL,
    FT_SIZE_REQUEST_TYPE_REAL_DIM,
    FT_SIZE_REQUEST_TYPE_BBOX,
    FT_SIZE_REQUEST_TYPE_CELL,
    FT_SIZE_REQUEST_TYPE_SCALES,

    FT_SIZE_REQUEST_TYPE_MAX

  } FT_Size_Request_Type;
# 2286 "../freetype/include/freetype.h"
  typedef struct FT_Size_RequestRec_
  {
    FT_Size_Request_Type type;
    FT_Long width;
    FT_Long height;
    FT_UInt horiResolution;
    FT_UInt vertResolution;

  } FT_Size_RequestRec;
# 2305 "../freetype/include/freetype.h"
  typedef struct FT_Size_RequestRec_ *FT_Size_Request;
# 2339 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Request_Size( FT_Face face,
                   FT_Size_Request req );
# 2380 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Set_Char_Size( FT_Face face,
                    FT_F26Dot6 char_width,
                    FT_F26Dot6 char_height,
                    FT_UInt horz_resolution,
                    FT_UInt vert_resolution );
# 2415 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Set_Pixel_Sizes( FT_Face face,
                      FT_UInt pixel_width,
                      FT_UInt pixel_height );
# 2457 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Load_Glyph( FT_Face face,
                 FT_UInt glyph_index,
                 FT_Int32 load_flags );
# 2492 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Load_Char( FT_Face face,
                FT_ULong char_code,
                FT_Int32 load_flags );
# 2789 "../freetype/include/freetype.h"
  extern "C" void
  FT_Set_Transform( FT_Face face,
                    FT_Matrix* matrix,
                    FT_Vector* delta );
# 2850 "../freetype/include/freetype.h"
  typedef enum FT_Render_Mode_
  {
    FT_RENDER_MODE_NORMAL = 0,
    FT_RENDER_MODE_LIGHT,
    FT_RENDER_MODE_MONO,
    FT_RENDER_MODE_LCD,
    FT_RENDER_MODE_LCD_V,

    FT_RENDER_MODE_MAX

  } FT_Render_Mode;
# 2895 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Render_Glyph( FT_GlyphSlot slot,
                   FT_Render_Mode render_mode );
# 2919 "../freetype/include/freetype.h"
  typedef enum FT_Kerning_Mode_
  {
    FT_KERNING_DEFAULT = 0,
    FT_KERNING_UNFITTED,
    FT_KERNING_UNSCALED

  } FT_Kerning_Mode;
# 2968 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Get_Kerning( FT_Face face,
                  FT_UInt left_glyph,
                  FT_UInt right_glyph,
                  FT_UInt kern_mode,
                  FT_Vector *akerning );
# 3009 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Get_Track_Kerning( FT_Face face,
                        FT_Fixed point_size,
                        FT_Int degree,
                        FT_Fixed* akerning );
# 3055 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Get_Glyph_Name( FT_Face face,
                     FT_UInt glyph_index,
                     FT_Pointer buffer,
                     FT_UInt buffer_max );
# 3081 "../freetype/include/freetype.h"
  extern "C" const char*
  FT_Get_Postscript_Name( FT_Face face );
# 3113 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Select_Charmap( FT_Face face,
                     FT_Encoding encoding );
# 3142 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Set_Charmap( FT_Face face,
                  FT_CharMap charmap );
# 3164 "../freetype/include/freetype.h"
  extern "C" FT_Int
  FT_Get_Charmap_Index( FT_CharMap charmap );
# 3198 "../freetype/include/freetype.h"
  extern "C" FT_UInt
  FT_Get_Char_Index( FT_Face face,
                     FT_ULong charcode );
# 3246 "../freetype/include/freetype.h"
  extern "C" FT_ULong
  FT_Get_First_Char( FT_Face face,
                     FT_UInt *agindex );
# 3280 "../freetype/include/freetype.h"
  extern "C" FT_ULong
  FT_Get_Next_Char( FT_Face face,
                    FT_ULong char_code,
                    FT_UInt *agindex );
# 3303 "../freetype/include/freetype.h"
  extern "C" FT_UInt
  FT_Get_Name_Index( FT_Face face,
                     FT_String* glyph_name );
# 3379 "../freetype/include/freetype.h"
  extern "C" FT_Error
  FT_Get_SubGlyph_Info( FT_GlyphSlot glyph,
                        FT_UInt sub_index,
                        FT_Int *p_index,
                        FT_UInt *p_flags,
                        FT_Int *p_arg1,
                        FT_Int *p_arg2,
                        FT_Matrix *p_transform );
# 3470 "../freetype/include/freetype.h"
  extern "C" FT_UShort
  FT_Get_FSType_Flags( FT_Face face );
# 3556 "../freetype/include/freetype.h"
  extern "C" FT_UInt
  FT_Face_GetCharVariantIndex( FT_Face face,
                               FT_ULong charcode,
                               FT_ULong variantSelector );
# 3592 "../freetype/include/freetype.h"
  extern "C" FT_Int
  FT_Face_GetCharVariantIsDefault( FT_Face face,
                                   FT_ULong charcode,
                                   FT_ULong variantSelector );
# 3623 "../freetype/include/freetype.h"
  extern "C" FT_UInt32*
  FT_Face_GetVariantSelectors( FT_Face face );
# 3656 "../freetype/include/freetype.h"
  extern "C" FT_UInt32*
  FT_Face_GetVariantsOfChar( FT_Face face,
                             FT_ULong charcode );
# 3690 "../freetype/include/freetype.h"
  extern "C" FT_UInt32*
  FT_Face_GetCharsOfVariant( FT_Face face,
                             FT_ULong variantSelector );
# 3747 "../freetype/include/freetype.h"
  extern "C" FT_Long
  FT_MulDiv( FT_Long a,
             FT_Long b,
             FT_Long c );
# 3782 "../freetype/include/freetype.h"
  extern "C" FT_Long
  FT_MulFix( FT_Long a,
             FT_Long b );
# 3804 "../freetype/include/freetype.h"
  extern "C" FT_Long
  FT_DivFix( FT_Long a,
             FT_Long b );
# 3823 "../freetype/include/freetype.h"
  extern "C" FT_Fixed
  FT_RoundFix( FT_Fixed a );
# 3842 "../freetype/include/freetype.h"
  extern "C" FT_Fixed
  FT_CeilFix( FT_Fixed a );
# 3861 "../freetype/include/freetype.h"
  extern "C" FT_Fixed
  FT_FloorFix( FT_Fixed a );
# 3882 "../freetype/include/freetype.h"
  extern "C" void
  FT_Vector_Transform( FT_Vector* vec,
                       const FT_Matrix* matrix );
# 3972 "../freetype/include/freetype.h"
  extern "C" void
  FT_Library_Version( FT_Library library,
                      FT_Int *amajor,
                      FT_Int *aminor,
                      FT_Int *apatch );
# 4006 "../freetype/include/freetype.h"
  extern "C" FT_Bool
  FT_Face_CheckTrueTypePatents( FT_Face face );
# 4036 "../freetype/include/freetype.h"
  extern "C" FT_Bool
  FT_Face_SetUnpatentedHinting( FT_Face face,
                                FT_Bool value );




}
# 15 "../Quadris/Font.cpp" 2
# 1 "../glm/gtx/transform.hpp" 1
# 45 "../glm/gtx/transform.hpp"
       


# 1 "../glm/gtx/../glm.hpp" 1
# 81 "../glm/gtx/../glm.hpp"
# 1 "../glm/gtx/../detail/_fixes.hpp" 1
# 33 "../glm/gtx/../detail/_fixes.hpp"
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 1
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath"
       
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 3
# 34 "../glm/gtx/../detail/_fixes.hpp" 2
# 82 "../glm/gtx/../glm.hpp" 2

       

# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 1
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath"
       
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 3
# 86 "../glm/gtx/../glm.hpp" 2
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/climits" 1
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/climits"
       
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/climits" 3
# 87 "../glm/gtx/../glm.hpp" 2
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cfloat" 1
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cfloat"
       
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cfloat" 3

# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\float.h" 1 3 4
# 42 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cfloat" 2 3
# 88 "../glm/gtx/../glm.hpp" 2

# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cassert" 1
# 41 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cassert"
       
# 42 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cassert" 3

# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/assert.h" 1 3
# 62 "C:\\ndk/platforms/android-9/arch-arm/usr/include/assert.h" 3
extern "C" {
 void __assert(const char *, int, const char *);
 void __assert2(const char *, int, const char *, const char *);
}
# 43 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cassert" 2 3
# 90 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../fwd.hpp" 1
# 33 "../glm/gtx/../fwd.hpp"
       

# 1 "../glm/gtx/../detail/type_int.hpp" 1
# 33 "../glm/gtx/../detail/type_int.hpp"
       

# 1 "../glm/gtx/../detail/setup.hpp" 1
# 33 "../glm/gtx/../detail/setup.hpp"
       

# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cassert" 1
# 41 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cassert"
       
# 42 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cassert" 3

# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/assert.h" 1 3
# 62 "C:\\ndk/platforms/android-9/arch-arm/usr/include/assert.h" 3
extern "C" {
 void __assert(const char *, int, const char *);
 void __assert2(const char *, int, const char *, const char *);
}
# 43 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cassert" 2 3
# 36 "../glm/gtx/../detail/setup.hpp" 2
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cstddef" 1
# 42 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cstddef"
       
# 43 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cstddef" 3


# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 1 3 4
# 46 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cstddef" 2 3


namespace std
{

  using ::max_align_t;
}
# 37 "../glm/gtx/../detail/setup.hpp" 2
# 838 "../glm/gtx/../detail/setup.hpp"
namespace glm
{
 using std::size_t;



  typedef int length_t;


namespace detail
{



  typedef length_t component_count_t;


 template <typename genType>
 inline constexpr component_count_t component_count(genType const & m)
 {



   return m.length();

 }
}
}
# 881 "../glm/gtx/../detail/setup.hpp"
namespace glm
{
 enum ctor{uninitialize};
}
# 36 "../glm/gtx/../detail/type_int.hpp" 2

# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 1
# 32 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits"
       
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 3
# 42 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 3
namespace std
{
  typedef short unsigned int uint_least16_t;
  typedef unsigned int uint_least32_t;
}





namespace std __attribute__ ((__visibility__ ("default")))
{

# 68 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 3
  template<typename _Tp, _Tp __v>
    struct integral_constant
    {
      static constexpr _Tp value = __v;
      typedef _Tp value_type;
      typedef integral_constant<_Tp, __v> type;
      constexpr operator value_type() const { return value; }



    };

  template<typename _Tp, _Tp __v>
    constexpr _Tp integral_constant<_Tp, __v>::value;


  typedef integral_constant<bool, true> true_type;


  typedef integral_constant<bool, false> false_type;



  template<bool, typename, typename>
    struct conditional;

  template<typename...>
    struct __or_;

  template<>
    struct __or_<>
    : public false_type
    { };

  template<typename _B1>
    struct __or_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __or_<_B1, _B2>
    : public conditional<_B1::value, _B1, _B2>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __or_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type
    { };

  template<typename...>
    struct __and_;

  template<>
    struct __and_<>
    : public true_type
    { };

  template<typename _B1>
    struct __and_<_B1>
    : public _B1
    { };

  template<typename _B1, typename _B2>
    struct __and_<_B1, _B2>
    : public conditional<_B1::value, _B2, _B1>::type
    { };

  template<typename _B1, typename _B2, typename _B3, typename... _Bn>
    struct __and_<_B1, _B2, _B3, _Bn...>
    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type
    { };

  template<typename _Pp>
    struct __not_
    : public integral_constant<bool, !_Pp::value>
    { };






  template<typename _Tp>
    struct __success_type
    { typedef _Tp type; };

  struct __failure_type
  { };



  template<typename>
    struct remove_cv;

  template<typename>
    struct __is_void_helper
    : public false_type { };

  template<>
    struct __is_void_helper<void>
    : public true_type { };


  template<typename _Tp>
    struct is_void
    : public __is_void_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_integral_helper
    : public false_type { };

  template<>
    struct __is_integral_helper<bool>
    : public true_type { };

  template<>
    struct __is_integral_helper<char>
    : public true_type { };

  template<>
    struct __is_integral_helper<signed char>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned char>
    : public true_type { };


  template<>
    struct __is_integral_helper<wchar_t>
    : public true_type { };


  template<>
    struct __is_integral_helper<char16_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<char32_t>
    : public true_type { };

  template<>
    struct __is_integral_helper<short>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned short>
    : public true_type { };

  template<>
    struct __is_integral_helper<int>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned int>
    : public true_type { };

  template<>
    struct __is_integral_helper<long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long>
    : public true_type { };

  template<>
    struct __is_integral_helper<long long>
    : public true_type { };

  template<>
    struct __is_integral_helper<unsigned long long>
    : public true_type { };
# 253 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 3
  template<typename _Tp>
    struct is_integral
    : public __is_integral_helper<typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_floating_point_helper
    : public false_type { };

  template<>
    struct __is_floating_point_helper<float>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<double>
    : public true_type { };

  template<>
    struct __is_floating_point_helper<long double>
    : public true_type { };
# 281 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 3
  template<typename _Tp>
    struct is_floating_point
    : public __is_floating_point_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_array
    : public false_type { };

  template<typename _Tp, std::size_t _Size>
    struct is_array<_Tp[_Size]>
    : public true_type { };

  template<typename _Tp>
    struct is_array<_Tp[]>
    : public true_type { };

  template<typename>
    struct __is_pointer_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_pointer_helper<_Tp*>
    : public true_type { };


  template<typename _Tp>
    struct is_pointer
    : public __is_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename>
    struct is_lvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_lvalue_reference<_Tp&>
    : public true_type { };


  template<typename>
    struct is_rvalue_reference
    : public false_type { };

  template<typename _Tp>
    struct is_rvalue_reference<_Tp&&>
    : public true_type { };

  template<typename>
    struct is_function;

  template<typename>
    struct __is_member_object_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_object_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, !is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_object_pointer
    : public __is_member_object_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };

  template<typename>
    struct __is_member_function_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_function_pointer_helper<_Tp _Cp::*>
    : public integral_constant<bool, is_function<_Tp>::value> { };


  template<typename _Tp>
    struct is_member_function_pointer
    : public __is_member_function_pointer_helper<
    typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct is_enum
    : public integral_constant<bool, __is_enum(_Tp)>
    { };


  template<typename _Tp>
    struct is_union
    : public integral_constant<bool, __is_union(_Tp)>
    { };


  template<typename _Tp>
    struct is_class
    : public integral_constant<bool, __is_class(_Tp)>
    { };


  template<typename>
    struct is_function
    : public false_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......)>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes...) const volatile &&>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile &>
    : public true_type { };

  template<typename _Res, typename... _ArgTypes>
    struct is_function<_Res(_ArgTypes......) const volatile &&>
    : public true_type { };

  template<typename>
    struct __is_null_pointer_helper
    : public false_type { };

  template<>
    struct __is_null_pointer_helper<std::nullptr_t>
    : public true_type { };


  template<typename _Tp>
    struct is_null_pointer
    : public __is_null_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };


  template<typename _Tp>
    struct __is_nullptr_t
    : public is_null_pointer<_Tp>
    { };




  template<typename _Tp>
    struct is_reference
    : public __or_<is_lvalue_reference<_Tp>,
                   is_rvalue_reference<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_arithmetic
    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_fundamental
    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>,
     is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_object
    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,
                          is_void<_Tp>>>::type
    { };

  template<typename>
    struct is_member_pointer;


  template<typename _Tp>
    struct is_scalar
    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,
                   is_member_pointer<_Tp>, is_null_pointer<_Tp>>::type
    { };


  template<typename _Tp>
    struct is_compound
    : public integral_constant<bool, !is_fundamental<_Tp>::value> { };

  template<typename _Tp>
    struct __is_member_pointer_helper
    : public false_type { };

  template<typename _Tp, typename _Cp>
    struct __is_member_pointer_helper<_Tp _Cp::*>
    : public true_type { };


  template<typename _Tp>
    struct is_member_pointer
    : public __is_member_pointer_helper<typename remove_cv<_Tp>::type>::type
    { };



  template<typename _Tp>
    struct __is_referenceable
    : public __or_<is_object<_Tp>, is_reference<_Tp>>::type
    { };

  template<typename _Res, typename... _Args>
    struct __is_referenceable<_Res(_Args...)>
    : public true_type
    { };

  template<typename _Res, typename... _Args>
    struct __is_referenceable<_Res(_Args......)>
    : public true_type
    { };




  template<typename>
    struct is_const
    : public false_type { };

  template<typename _Tp>
    struct is_const<_Tp const>
    : public true_type { };


  template<typename>
    struct is_volatile
    : public false_type { };

  template<typename _Tp>
    struct is_volatile<_Tp volatile>
    : public true_type { };


  template<typename _Tp>
    struct is_trivial
    : public integral_constant<bool, __is_trivial(_Tp)>
    { };




  template<typename _Tp>
    struct is_standard_layout
    : public integral_constant<bool, __is_standard_layout(_Tp)>
    { };



  template<typename _Tp>
    struct is_pod
    : public integral_constant<bool, __is_pod(_Tp)>
    { };


  template<typename _Tp>
    struct is_literal_type
    : public integral_constant<bool, __is_literal_type(_Tp)>
    { };


  template<typename _Tp>
    struct is_empty
    : public integral_constant<bool, __is_empty(_Tp)>
    { };


  template<typename _Tp>
    struct is_polymorphic
    : public integral_constant<bool, __is_polymorphic(_Tp)>
    { };


  template<typename _Tp>
    struct is_abstract
    : public integral_constant<bool, __is_abstract(_Tp)>
    { };

  template<typename _Tp,
    bool = is_arithmetic<_Tp>::value>
    struct __is_signed_helper
    : public false_type { };

  template<typename _Tp>
    struct __is_signed_helper<_Tp, true>
    : public integral_constant<bool, _Tp(-1) < _Tp(0)>
    { };


  template<typename _Tp>
    struct is_signed
    : public __is_signed_helper<_Tp>::type
    { };


  template<typename _Tp>
    struct is_unsigned
    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type
    { };




  template<typename>
    struct add_rvalue_reference;





  template<typename _Tp>
    typename add_rvalue_reference<_Tp>::type declval() noexcept;

  template<typename, unsigned = 0>
    struct extent;

  template<typename>
    struct remove_all_extents;

  template<typename _Tp>
    struct __is_array_known_bounds
    : public integral_constant<bool, (extent<_Tp>::value > 0)>
    { };

  template<typename _Tp>
    struct __is_array_unknown_bounds
    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>::type
    { };






  struct __do_is_destructible_impl
  {
    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_destructible_impl
    : public __do_is_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_destructible_safe;

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, false>
    : public __is_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_destructible
    : public __is_destructible_safe<_Tp>::type
    { };





  struct __do_is_nt_destructible_impl
  {
    template<typename _Tp>
      static integral_constant<bool, noexcept(declval<_Tp&>().~_Tp())>
        __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_nt_destructible_impl
    : public __do_is_nt_destructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp,
           bool = __or_<is_void<_Tp>,
                        __is_array_unknown_bounds<_Tp>,
                        is_function<_Tp>>::value,
           bool = __or_<is_reference<_Tp>, is_scalar<_Tp>>::value>
    struct __is_nt_destructible_safe;

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, false>
    : public __is_nt_destructible_impl<typename
               remove_all_extents<_Tp>::type>::type
    { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, true, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_destructible_safe<_Tp, false, true>
    : public true_type { };


  template<typename _Tp>
    struct is_nothrow_destructible
    : public __is_nt_destructible_safe<_Tp>::type
    { };

  struct __do_is_default_constructible_impl
  {
    template<typename _Tp, typename = decltype(_Tp())>
      static true_type __test(int);

    template<typename>
      static false_type __test(...);
  };

  template<typename _Tp>
    struct __is_default_constructible_impl
    : public __do_is_default_constructible_impl
    {
      typedef decltype(__test<_Tp>(0)) type;
    };

  template<typename _Tp>
    struct __is_default_constructible_atom
    : public __and_<__not_<is_void<_Tp>>,
                    __is_default_constructible_impl<_Tp>>::type
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_default_constructible_safe;






  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>::type
    { };

  template<typename _Tp>
    struct __is_default_constructible_safe<_Tp, false>
    : public __is_default_constructible_atom<_Tp>::type
    { };


  template<typename _Tp>
    struct is_default_constructible
    : public __is_default_constructible_safe<_Tp>::type
    { };
# 850 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 3
  struct __do_is_static_castable_impl
  {
    template<typename _From, typename _To, typename
             = decltype(static_cast<_To>(declval<_From>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _From, typename _To>
    struct __is_static_castable_impl
    : public __do_is_static_castable_impl
    {
      typedef decltype(__test<_From, _To>(0)) type;
    };

  template<typename _From, typename _To>
    struct __is_static_castable_safe
    : public __is_static_castable_impl<_From, _To>::type
    { };


  template<typename _From, typename _To>
    struct __is_static_castable
    : public integral_constant<bool, (__is_static_castable_safe<
          _From, _To>::value)>
    { };






  struct __do_is_direct_constructible_impl
  {
    template<typename _Tp, typename _Arg, typename
      = decltype(::new _Tp(declval<_Arg>()))>
      static true_type __test(int);

    template<typename, typename>
      static false_type __test(...);
  };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_impl
    : public __do_is_direct_constructible_impl
    {
      typedef decltype(__test<_Tp, _Arg>(0)) type;
    };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new_safe
    : public __and_<is_destructible<_Tp>,
                    __is_direct_constructible_impl<_Tp, _Arg>>::type
    { };

  template<typename, typename>
    struct is_same;

  template<typename, typename>
    struct is_base_of;

  template<typename>
    struct remove_reference;

  template<typename _From, typename _To, bool
           = __not_<__or_<is_void<_From>,
                          is_function<_From>>>::value>
    struct __is_base_to_derived_ref;



  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<_From
        >::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<_To
        >::type>::type __dst_t;
      typedef __and_<__not_<is_same<__src_t, __dst_t>>,
       is_base_of<__src_t, __dst_t>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_base_to_derived_ref<_From, _To, false>
    : public false_type
    { };

  template<typename _From, typename _To, bool
           = __and_<is_lvalue_reference<_From>,
                    is_rvalue_reference<_To>>::value>
    struct __is_lvalue_to_rvalue_ref;



  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, true>
    {
      typedef typename remove_cv<typename remove_reference<
        _From>::type>::type __src_t;
      typedef typename remove_cv<typename remove_reference<
        _To>::type>::type __dst_t;
      typedef __and_<__not_<is_function<__src_t>>,
        __or_<is_same<__src_t, __dst_t>,
      is_base_of<__dst_t, __src_t>>> type;
      static constexpr bool value = type::value;
    };

  template<typename _From, typename _To>
    struct __is_lvalue_to_rvalue_ref<_From, _To, false>
    : public false_type
    { };







  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_ref_cast
    : public __and_<__is_static_castable<_Arg, _Tp>,
                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,
                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>
                   >>>::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible_new
    : public conditional<is_reference<_Tp>::value,
    __is_direct_constructible_ref_cast<_Tp, _Arg>,
    __is_direct_constructible_new_safe<_Tp, _Arg>
    >::type
    { };

  template<typename _Tp, typename _Arg>
    struct __is_direct_constructible
    : public __is_direct_constructible_new<_Tp, _Arg>::type
    { };






  struct __do_is_nary_constructible_impl
  {
    template<typename _Tp, typename... _Args, typename
             = decltype(_Tp(declval<_Args>()...))>
      static true_type __test(int);

    template<typename, typename...>
      static false_type __test(...);
  };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible_impl
    : public __do_is_nary_constructible_impl
    {
      typedef decltype(__test<_Tp, _Args...>(0)) type;
    };

  template<typename _Tp, typename... _Args>
    struct __is_nary_constructible
    : public __is_nary_constructible_impl<_Tp, _Args...>::type
    {
      static_assert(sizeof...(_Args) > 1,
                    "Only useful for > 1 arguments");
    };

  template<typename _Tp, typename... _Args>
    struct __is_constructible_impl
    : public __is_nary_constructible<_Tp, _Args...>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_constructible_impl<_Tp, _Arg>
    : public __is_direct_constructible<_Tp, _Arg>
    { };

  template<typename _Tp>
    struct __is_constructible_impl<_Tp>
    : public is_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_constructible
    : public __is_constructible_impl<_Tp, _Args...>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_constructible_impl;

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_constructible
    : public __is_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_constructible_impl;

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_constructible_impl<_Tp, true>
    : public is_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_constructible
    : public __is_move_constructible_impl<_Tp>
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_atom
    : public integral_constant<bool, noexcept(_Tp())>
    { };

  template<typename _Tp, bool = is_array<_Tp>::value>
    struct __is_nt_default_constructible_impl;

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, true>
    : public __and_<__is_array_known_bounds<_Tp>,
      __is_nt_default_constructible_atom<typename
                      remove_all_extents<_Tp>::type>>::type
    { };

  template<typename _Tp>
    struct __is_nt_default_constructible_impl<_Tp, false>
    : public __is_nt_default_constructible_atom<_Tp>
    { };


  template<typename _Tp>
    struct is_nothrow_default_constructible
    : public __and_<is_default_constructible<_Tp>,
                    __is_nt_default_constructible_impl<_Tp>>::type
    { };

  template<typename _Tp, typename... _Args>
    struct __is_nt_constructible_impl
    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>
    { };

  template<typename _Tp, typename _Arg>
    struct __is_nt_constructible_impl<_Tp, _Arg>
    : public integral_constant<bool,
                               noexcept(static_cast<_Tp>(declval<_Arg>()))>
    { };

  template<typename _Tp>
    struct __is_nt_constructible_impl<_Tp>
    : public is_nothrow_default_constructible<_Tp>
    { };


  template<typename _Tp, typename... _Args>
    struct is_nothrow_constructible
    : public __and_<is_constructible<_Tp, _Args...>,
      __is_nt_constructible_impl<_Tp, _Args...>>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_copy_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_copy_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_constructible
    : public __is_nothrow_copy_constructible_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nothrow_move_constructible_impl;

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nothrow_move_constructible_impl<_Tp, true>
    : public is_nothrow_constructible<_Tp, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_constructible
    : public __is_nothrow_move_constructible_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    class __is_assignable_helper
    {
      template<typename _Tp1, typename _Up1,
        typename = decltype(declval<_Tp1>() = declval<_Up1>())>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_Tp, _Up>(0)) type;
    };


  template<typename _Tp, typename _Up>
    struct is_assignable
      : public __is_assignable_helper<_Tp, _Up>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_copy_assignable_impl;

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_copy_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_copy_assignable
    : public __is_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_move_assignable_impl;

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_move_assignable_impl<_Tp, true>
    : public is_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_move_assignable
    : public __is_move_assignable_impl<_Tp>
    { };

  template<typename _Tp, typename _Up>
    struct __is_nt_assignable_impl
    : public integral_constant<bool, noexcept(declval<_Tp>() = declval<_Up>())>
    { };


  template<typename _Tp, typename _Up>
    struct is_nothrow_assignable
    : public __and_<is_assignable<_Tp, _Up>,
      __is_nt_assignable_impl<_Tp, _Up>>::type
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_copy_assignable_impl;

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_copy_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, const _Tp&>
    { };


  template<typename _Tp>
    struct is_nothrow_copy_assignable
    : public __is_nt_copy_assignable_impl<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __is_nt_move_assignable_impl;

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, false>
    : public false_type { };

  template<typename _Tp>
    struct __is_nt_move_assignable_impl<_Tp, true>
    : public is_nothrow_assignable<_Tp&, _Tp&&>
    { };


  template<typename _Tp>
    struct is_nothrow_move_assignable
    : public __is_nt_move_assignable_impl<_Tp>
    { };
# 1286 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 3
  template<typename _Tp>
    struct is_trivially_destructible
    : public __and_<is_destructible<_Tp>, integral_constant<bool,
         __has_trivial_destructor(_Tp)>>::type
    { };


  template<typename _Tp>
    struct has_trivial_default_constructor
    : public integral_constant<bool, __has_trivial_constructor(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_copy_constructor
    : public integral_constant<bool, __has_trivial_copy(_Tp)>
    { };


  template<typename _Tp>
    struct has_trivial_copy_assign
    : public integral_constant<bool, __has_trivial_assign(_Tp)>
    { };


  template<typename _Tp>
    struct has_virtual_destructor
    : public integral_constant<bool, __has_virtual_destructor(_Tp)>
    { };





  template<typename _Tp>
    struct alignment_of
    : public integral_constant<std::size_t, __alignof__(_Tp)> { };


  template<typename>
    struct rank
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, std::size_t _Size>
    struct rank<_Tp[_Size]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };

  template<typename _Tp>
    struct rank<_Tp[]>
    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };


  template<typename, unsigned _Uint>
    struct extent
    : public integral_constant<std::size_t, 0> { };

  template<typename _Tp, unsigned _Uint, std::size_t _Size>
    struct extent<_Tp[_Size], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? _Size : extent<_Tp,
          _Uint - 1>::value>
    { };

  template<typename _Tp, unsigned _Uint>
    struct extent<_Tp[], _Uint>
    : public integral_constant<std::size_t,
          _Uint == 0 ? 0 : extent<_Tp,
             _Uint - 1>::value>
    { };





  template<typename, typename>
    struct is_same
    : public false_type { };

  template<typename _Tp>
    struct is_same<_Tp, _Tp>
    : public true_type { };


  template<typename _Base, typename _Derived>
    struct is_base_of
    : public integral_constant<bool, __is_base_of(_Base, _Derived)>
    { };

  template<typename _From, typename _To,
           bool = __or_<is_void<_From>, is_function<_To>,
                        is_array<_To>>::value>
    struct __is_convertible_helper
    { typedef typename is_void<_To>::type type; };

  template<typename _From, typename _To>
    class __is_convertible_helper<_From, _To, false>
    {
       template<typename _To1>
 static void __test_aux(_To1);

      template<typename _From1, typename _To1,
        typename = decltype(__test_aux<_To1>(std::declval<_From1>()))>
 static true_type
 __test(int);

      template<typename, typename>
 static false_type
 __test(...);

    public:
      typedef decltype(__test<_From, _To>(0)) type;
    };



  template<typename _From, typename _To>
    struct is_convertible
    : public __is_convertible_helper<_From, _To>::type
    { };





  template<typename _Tp>
    struct remove_const
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_const<_Tp const>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_volatile
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_volatile<_Tp volatile>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_cv
    {
      typedef typename
      remove_const<typename remove_volatile<_Tp>::type>::type type;
    };


  template<typename _Tp>
    struct add_const
    { typedef _Tp const type; };


  template<typename _Tp>
    struct add_volatile
    { typedef _Tp volatile type; };


  template<typename _Tp>
    struct add_cv
    {
      typedef typename
      add_const<typename add_volatile<_Tp>::type>::type type;
    };
# 1482 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 3
  template<typename _Tp>
    struct remove_reference
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_reference<_Tp&&>
    { typedef _Tp type; };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_lvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_lvalue_reference_helper<_Tp, true>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct add_lvalue_reference
    : public __add_lvalue_reference_helper<_Tp>
    { };

  template<typename _Tp, bool = __is_referenceable<_Tp>::value>
    struct __add_rvalue_reference_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_rvalue_reference_helper<_Tp, true>
    { typedef _Tp&& type; };


  template<typename _Tp>
    struct add_rvalue_reference
    : public __add_rvalue_reference_helper<_Tp>
    { };
# 1539 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 3
  template<typename _Unqualified, bool _IsConst, bool _IsVol>
    struct __cv_selector;

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, false>
    { typedef _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, false, true>
    { typedef volatile _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, false>
    { typedef const _Unqualified __type; };

  template<typename _Unqualified>
    struct __cv_selector<_Unqualified, true, true>
    { typedef const volatile _Unqualified __type; };

  template<typename _Qualified, typename _Unqualified,
    bool _IsConst = is_const<_Qualified>::value,
    bool _IsVol = is_volatile<_Qualified>::value>
    class __match_cv_qualifiers
    {
      typedef __cv_selector<_Unqualified, _IsConst, _IsVol> __match;

    public:
      typedef typename __match::__type __type;
    };


  template<typename _Tp>
    struct __make_unsigned
    { typedef _Tp __type; };

  template<>
    struct __make_unsigned<char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<signed char>
    { typedef unsigned char __type; };

  template<>
    struct __make_unsigned<short>
    { typedef unsigned short __type; };

  template<>
    struct __make_unsigned<int>
    { typedef unsigned int __type; };

  template<>
    struct __make_unsigned<long>
    { typedef unsigned long __type; };

  template<>
    struct __make_unsigned<long long>
    { typedef unsigned long long __type; };
# 1611 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_unsigned_selector;

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, true, false>
    {
      typedef __make_unsigned<typename remove_cv<_Tp>::type> __unsignedt;
      typedef typename __unsignedt::__type __unsigned_type;
      typedef __match_cv_qualifiers<_Tp, __unsigned_type> __cv_unsigned;

    public:
      typedef typename __cv_unsigned::__type __type;
    };

  template<typename _Tp>
    class __make_unsigned_selector<_Tp, false, true>
    {

      typedef unsigned char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(unsigned short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(unsigned int);
      typedef conditional<__b2, unsigned int, unsigned long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, unsigned short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_unsigned
    { typedef typename __make_unsigned_selector<_Tp>::__type type; };


  template<>
    struct make_unsigned<bool>;



  template<typename _Tp>
    struct __make_signed
    { typedef _Tp __type; };

  template<>
    struct __make_signed<char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned char>
    { typedef signed char __type; };

  template<>
    struct __make_signed<unsigned short>
    { typedef signed short __type; };

  template<>
    struct __make_signed<unsigned int>
    { typedef signed int __type; };

  template<>
    struct __make_signed<unsigned long>
    { typedef signed long __type; };

  template<>
    struct __make_signed<unsigned long long>
    { typedef signed long long __type; };


  template<>
    struct __make_signed<wchar_t> : __make_signed<unsigned int>
    { };



  template<>
    struct __make_signed<char16_t> : __make_signed<uint_least16_t>
    { };
  template<>
    struct __make_signed<char32_t> : __make_signed<uint_least32_t>
    { };
# 1708 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 3
  template<typename _Tp,
    bool _IsInt = is_integral<_Tp>::value,
    bool _IsEnum = is_enum<_Tp>::value>
    class __make_signed_selector;

  template<typename _Tp>
    class __make_signed_selector<_Tp, true, false>
    {
      typedef __make_signed<typename remove_cv<_Tp>::type> __signedt;
      typedef typename __signedt::__type __signed_type;
      typedef __match_cv_qualifiers<_Tp, __signed_type> __cv_signed;

    public:
      typedef typename __cv_signed::__type __type;
    };

  template<typename _Tp>
    class __make_signed_selector<_Tp, false, true>
    {

      typedef signed char __smallest;
      static const bool __b0 = sizeof(_Tp) <= sizeof(__smallest);
      static const bool __b1 = sizeof(_Tp) <= sizeof(signed short);
      static const bool __b2 = sizeof(_Tp) <= sizeof(signed int);
      typedef conditional<__b2, signed int, signed long> __cond2;
      typedef typename __cond2::type __cond2_type;
      typedef conditional<__b1, signed short, __cond2_type> __cond1;
      typedef typename __cond1::type __cond1_type;

    public:
      typedef typename conditional<__b0, __smallest, __cond1_type>::type __type;
    };





  template<typename _Tp>
    struct make_signed
    { typedef typename __make_signed_selector<_Tp>::__type type; };


  template<>
    struct make_signed<bool>;
# 1766 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 3
  template<typename _Tp>
    struct remove_extent
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_extent<_Tp[_Size]>
    { typedef _Tp type; };

  template<typename _Tp>
    struct remove_extent<_Tp[]>
    { typedef _Tp type; };


  template<typename _Tp>
    struct remove_all_extents
    { typedef _Tp type; };

  template<typename _Tp, std::size_t _Size>
    struct remove_all_extents<_Tp[_Size]>
    { typedef typename remove_all_extents<_Tp>::type type; };

  template<typename _Tp>
    struct remove_all_extents<_Tp[]>
    { typedef typename remove_all_extents<_Tp>::type type; };
# 1803 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 3
  template<typename _Tp, typename>
    struct __remove_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp, typename _Up>
    struct __remove_pointer_helper<_Tp, _Up*>
    { typedef _Up type; };


  template<typename _Tp>
    struct remove_pointer
    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>
    { };


  template<typename _Tp, bool = __or_<__is_referenceable<_Tp>,
          is_void<_Tp>>::value>
    struct __add_pointer_helper
    { typedef _Tp type; };

  template<typename _Tp>
    struct __add_pointer_helper<_Tp, true>
    { typedef typename remove_reference<_Tp>::type* type; };

  template<typename _Tp>
    struct add_pointer
    : public __add_pointer_helper<_Tp>
    { };
# 1842 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 3
  template<std::size_t _Len>
    struct __aligned_storage_msa
    {
      union __type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__)) { } __align;
      };
    };
# 1862 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 3
  template<std::size_t _Len, std::size_t _Align =
    __alignof__(typename __aligned_storage_msa<_Len>::__type)>
    struct aligned_storage
    {
      union type
      {
 unsigned char __data[_Len];
 struct __attribute__((__aligned__((_Align)))) { } __align;
      };
    };




  template<typename _Up,
    bool _IsArray = is_array<_Up>::value,
    bool _IsFunction = is_function<_Up>::value>
    struct __decay_selector;


  template<typename _Up>
    struct __decay_selector<_Up, false, false>
    { typedef typename remove_cv<_Up>::type __type; };

  template<typename _Up>
    struct __decay_selector<_Up, true, false>
    { typedef typename remove_extent<_Up>::type* __type; };

  template<typename _Up>
    struct __decay_selector<_Up, false, true>
    { typedef typename add_pointer<_Up>::type __type; };


  template<typename _Tp>
    class decay
    {
      typedef typename remove_reference<_Tp>::type __remove_type;

    public:
      typedef typename __decay_selector<__remove_type>::__type type;
    };

  template<typename _Tp>
    class reference_wrapper;


  template<typename _Tp>
    struct __strip_reference_wrapper
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __strip_reference_wrapper<reference_wrapper<_Tp> >
    {
      typedef _Tp& __type;
    };

  template<typename _Tp>
    struct __decay_and_strip
    {
      typedef typename __strip_reference_wrapper<
 typename decay<_Tp>::type>::__type __type;
    };




  template<bool, typename _Tp = void>
    struct enable_if
    { };


  template<typename _Tp>
    struct enable_if<true, _Tp>
    { typedef _Tp type; };

  template<typename... _Cond>
    using _Require = typename enable_if<__and_<_Cond...>::value>::type;



  template<bool _Cond, typename _Iftrue, typename _Iffalse>
    struct conditional
    { typedef _Iftrue type; };


  template<typename _Iftrue, typename _Iffalse>
    struct conditional<false, _Iftrue, _Iffalse>
    { typedef _Iffalse type; };


  template<typename... _Tp>
    struct common_type;



  struct __do_common_type_impl
  {
    template<typename _Tp, typename _Up>
      static __success_type<typename decay<decltype
       (true ? std::declval<_Tp>()
        : std::declval<_Up>())>::type> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp, typename _Up>
    struct __common_type_impl
    : private __do_common_type_impl
    {



      typedef typename decay<decltype(_S_test<_Tp, _Up>(0))>::type type;

    };

  struct __do_member_type_wrapper
  {
    template<typename _Tp>
      static __success_type<typename _Tp::type> _S_test(int);

    template<typename>
      static __failure_type _S_test(...);
  };

  template<typename _Tp>
    struct __member_type_wrapper
    : private __do_member_type_wrapper
    {
      typedef decltype(_S_test<_Tp>(0)) type;
    };

  template<typename _CTp, typename... _Args>
    struct __expanded_common_type_wrapper
    {
      typedef common_type<typename _CTp::type, _Args...> type;
    };

  template<typename... _Args>
    struct __expanded_common_type_wrapper<__failure_type, _Args...>
    { typedef __failure_type type; };

  template<typename _Tp>
    struct common_type<_Tp>
    { typedef typename decay<_Tp>::type type; };

  template<typename _Tp, typename _Up>
    struct common_type<_Tp, _Up>
    : public __common_type_impl<_Tp, _Up>::type
    { };

  template<typename _Tp, typename _Up, typename... _Vp>
    struct common_type<_Tp, _Up, _Vp...>
    : public __expanded_common_type_wrapper<typename __member_type_wrapper<
               common_type<_Tp, _Up>>::type, _Vp...>::type
    { };


  template<typename _Tp>
    struct underlying_type
    {
      typedef __underlying_type(_Tp) type;
    };

  template<typename _Tp>
    struct __declval_protector
    {
      static const bool __stop = false;
      static typename add_rvalue_reference<_Tp>::type __delegate();
    };

  template<typename _Tp>
    inline typename add_rvalue_reference<_Tp>::type
    declval() noexcept
    {
      static_assert(__declval_protector<_Tp>::__stop,
      "declval() must not be used!");
      return __declval_protector<_Tp>::__delegate();
    }


  template<typename _Signature>
    class result_of;




  struct __result_of_memfun_ref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __success_type<decltype(
      (std::declval<_Tp1>().*std::declval<_Fp>())(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_ref
    : private __result_of_memfun_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memfun_deref_impl
  {
    template<typename _Fp, typename _Tp1, typename... _Args>
      static __success_type<decltype(
      ((*std::declval<_Tp1>()).*std::declval<_Fp>())(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun_deref
    : private __result_of_memfun_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg, _Args...>(0)) type;
    };


  struct __result_of_memobj_ref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __success_type<decltype(
      std::declval<_Tp1>().*std::declval<_Fp>()
      )> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_ref
    : private __result_of_memobj_ref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };


  struct __result_of_memobj_deref_impl
  {
    template<typename _Fp, typename _Tp1>
      static __success_type<decltype(
      (*std::declval<_Tp1>()).*std::declval<_Fp>()
      )> _S_test(int);

    template<typename, typename>
      static __failure_type _S_test(...);
  };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj_deref
    : private __result_of_memobj_deref_impl
    {
      typedef decltype(_S_test<_MemPtr, _Arg>(0)) type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_memobj;

  template<typename _Res, typename _Class, typename _Arg>
    struct __result_of_memobj<_Res _Class::*, _Arg>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memobj_ref<_MemPtr, _Arg>,
        __result_of_memobj_deref<_MemPtr, _Arg>
      >::type::type type;
    };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_memfun;

  template<typename _Res, typename _Class, typename _Arg, typename... _Args>
    struct __result_of_memfun<_Res _Class::*, _Arg, _Args...>
    {
      typedef typename remove_cv<typename remove_reference<
        _Arg>::type>::type _Argval;
      typedef _Res _Class::* _MemPtr;
      typedef typename conditional<__or_<is_same<_Argval, _Class>,
        is_base_of<_Class, _Argval>>::value,
        __result_of_memfun_ref<_MemPtr, _Arg, _Args...>,
        __result_of_memfun_deref<_MemPtr, _Arg, _Args...>
      >::type::type type;
    };

  template<bool, bool, typename _Functor, typename... _ArgTypes>
    struct __result_of_impl
    {
      typedef __failure_type type;
    };

  template<typename _MemPtr, typename _Arg>
    struct __result_of_impl<true, false, _MemPtr, _Arg>
    : public __result_of_memobj<typename decay<_MemPtr>::type, _Arg>
    { };

  template<typename _MemPtr, typename _Arg, typename... _Args>
    struct __result_of_impl<false, true, _MemPtr, _Arg, _Args...>
    : public __result_of_memfun<typename decay<_MemPtr>::type, _Arg, _Args...>
    { };


  struct __result_of_other_impl
  {
    template<typename _Fn, typename... _Args>
      static __success_type<decltype(
      std::declval<_Fn>()(std::declval<_Args>()...)
      )> _S_test(int);

    template<typename...>
      static __failure_type _S_test(...);
  };

  template<typename _Functor, typename... _ArgTypes>
    struct __result_of_impl<false, false, _Functor, _ArgTypes...>
    : private __result_of_other_impl
    {
      typedef decltype(_S_test<_Functor, _ArgTypes...>(0)) type;
    };

  template<typename _Functor, typename... _ArgTypes>
    struct result_of<_Functor(_ArgTypes...)>
    : public __result_of_impl<
        is_member_object_pointer<
          typename remove_reference<_Functor>::type
        >::value,
        is_member_function_pointer<
          typename remove_reference<_Functor>::type
        >::value,
     _Functor, _ArgTypes...
      >::type
    { };
# 2268 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/type_traits" 3

}
# 38 "../glm/gtx/../detail/type_int.hpp" 2



# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cstdint" 1
# 32 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cstdint"
       
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cstdint" 3
# 46 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cstdint" 3
namespace std
{
  using ::int8_t;
  using ::int16_t;
  using ::int32_t;
  using ::int64_t;

  using ::int_fast8_t;
  using ::int_fast16_t;
  using ::int_fast32_t;
  using ::int_fast64_t;

  using ::int_least8_t;
  using ::int_least16_t;
  using ::int_least32_t;
  using ::int_least64_t;

  using ::intmax_t;
  using ::intptr_t;

  using ::uint8_t;
  using ::uint16_t;
  using ::uint32_t;
  using ::uint64_t;

  using ::uint_fast8_t;
  using ::uint_fast16_t;
  using ::uint_fast32_t;
  using ::uint_fast64_t;

  using ::uint_least8_t;
  using ::uint_least16_t;
  using ::uint_least32_t;
  using ::uint_least64_t;

  using ::uintmax_t;
  using ::uintptr_t;
}
# 42 "../glm/gtx/../detail/type_int.hpp" 2


namespace glm{
namespace detail
{

  typedef std::int8_t int8;
  typedef std::int16_t int16;
  typedef std::int32_t int32;
  typedef std::int64_t int64;

  typedef std::uint8_t uint8;
  typedef std::uint16_t uint16;
  typedef std::uint32_t uint32;
  typedef std::uint64_t uint64;
# 83 "../glm/gtx/../detail/type_int.hpp"
 typedef signed int lowp_int_t;
 typedef signed int mediump_int_t;
 typedef signed int highp_int_t;

 typedef unsigned int lowp_uint_t;
 typedef unsigned int mediump_uint_t;
 typedef unsigned int highp_uint_t;


  using std::make_signed;
  using std::make_unsigned;
# 224 "../glm/gtx/../detail/type_int.hpp"
}

 typedef detail::int8 int8;
 typedef detail::int16 int16;
 typedef detail::int32 int32;
 typedef detail::int64 int64;

 typedef detail::uint8 uint8;
 typedef detail::uint16 uint16;
 typedef detail::uint32 uint32;
 typedef detail::uint64 uint64;
# 244 "../glm/gtx/../detail/type_int.hpp"
 typedef detail::lowp_int_t lowp_int;






 typedef detail::mediump_int_t mediump_int;






 typedef detail::highp_int_t highp_int;






 typedef detail::lowp_uint_t lowp_uint;






 typedef detail::mediump_uint_t mediump_uint;






 typedef detail::highp_uint_t highp_uint;


 typedef mediump_int int_t;
# 294 "../glm/gtx/../detail/type_int.hpp"
 typedef mediump_uint uint_t;
# 308 "../glm/gtx/../detail/type_int.hpp"
 typedef unsigned int uint;






 static_assert(sizeof(glm::int8) == 1, "int8 size isn't 1 byte on this platform");
 static_assert(sizeof(glm::int16) == 2, "int16 size isn't 2 bytes on this platform");
 static_assert(sizeof(glm::int32) == 4, "int32 size isn't 4 bytes on this platform");
 static_assert(sizeof(glm::int64) == 8, "int64 size isn't 8 bytes on this platform");

 static_assert(sizeof(glm::uint8) == 1, "uint8 size isn't 1 byte on this platform");
 static_assert(sizeof(glm::uint16) == 2, "uint16 size isn't 2 bytes on this platform");
 static_assert(sizeof(glm::uint32) == 4, "uint32 size isn't 4 bytes on this platform");
 static_assert(sizeof(glm::uint64) == 8, "uint64 size isn't 8 bytes on this platform");


}
# 36 "../glm/gtx/../fwd.hpp" 2
# 1 "../glm/gtx/../detail/type_float.hpp" 1
# 33 "../glm/gtx/../detail/type_float.hpp"
       



namespace glm{
namespace detail
{
 typedef float float32;
 typedef double float64;
}

 typedef float lowp_float_t;
 typedef float mediump_float_t;
 typedef double highp_float_t;
# 56 "../glm/gtx/../detail/type_float.hpp"
 typedef lowp_float_t lowp_float;






 typedef mediump_float_t mediump_float;






 typedef highp_float_t highp_float;


 typedef mediump_float float_t;
# 84 "../glm/gtx/../detail/type_float.hpp"
 typedef float float32;
 typedef double float64;




 static_assert(sizeof(glm::float32) == 4, "float32 size isn't 4 bytes on this platform");
 static_assert(sizeof(glm::float64) == 8, "float64 size isn't 8 bytes on this platform");




}
# 37 "../glm/gtx/../fwd.hpp" 2
# 1 "../glm/gtx/../detail/type_vec.hpp" 1
# 33 "../glm/gtx/../detail/type_vec.hpp"
       

# 1 "../glm/gtx/../detail/precision.hpp" 1
# 33 "../glm/gtx/../detail/precision.hpp"
       

namespace glm
{
 enum precision
 {
  highp,
  mediump,
  lowp,
  defaultp = highp
 };
}
# 36 "../glm/gtx/../detail/type_vec.hpp" 2


namespace glm
{
 template <typename T, precision P> struct tvec1;
 template <typename T, precision P> struct tvec2;
 template <typename T, precision P> struct tvec3;
 template <typename T, precision P> struct tvec4;

 typedef tvec1<float, highp> highp_vec1_t;
 typedef tvec1<float, mediump> mediump_vec1_t;
 typedef tvec1<float, lowp> lowp_vec1_t;
 typedef tvec1<double, highp> highp_dvec1_t;
 typedef tvec1<double, mediump> mediump_dvec1_t;
 typedef tvec1<double, lowp> lowp_dvec1_t;
 typedef tvec1<int, highp> highp_ivec1_t;
 typedef tvec1<int, mediump> mediump_ivec1_t;
 typedef tvec1<int, lowp> lowp_ivec1_t;
 typedef tvec1<uint, highp> highp_uvec1_t;
 typedef tvec1<uint, mediump> mediump_uvec1_t;
 typedef tvec1<uint, lowp> lowp_uvec1_t;
 typedef tvec1<bool, highp> highp_bvec1_t;
 typedef tvec1<bool, mediump> mediump_bvec1_t;
 typedef tvec1<bool, lowp> lowp_bvec1_t;
# 69 "../glm/gtx/../detail/type_vec.hpp"
 typedef tvec2<float, highp> highp_vec2;






 typedef tvec2<float, mediump> mediump_vec2;






 typedef tvec2<float, lowp> lowp_vec2;






 typedef tvec2<double, highp> highp_dvec2;






 typedef tvec2<double, mediump> mediump_dvec2;






 typedef tvec2<double, lowp> lowp_dvec2;






 typedef tvec2<int, highp> highp_ivec2;






 typedef tvec2<int, mediump> mediump_ivec2;






 typedef tvec2<int, lowp> lowp_ivec2;






 typedef tvec2<uint, highp> highp_uvec2;






 typedef tvec2<uint, mediump> mediump_uvec2;






 typedef tvec2<uint, lowp> lowp_uvec2;






 typedef tvec2<bool, highp> highp_bvec2;






 typedef tvec2<bool, mediump> mediump_bvec2;






 typedef tvec2<bool, lowp> lowp_bvec2;
# 180 "../glm/gtx/../detail/type_vec.hpp"
 typedef tvec3<float, highp> highp_vec3;






 typedef tvec3<float, mediump> mediump_vec3;






 typedef tvec3<float, lowp> lowp_vec3;






 typedef tvec3<double, highp> highp_dvec3;






 typedef tvec3<double, mediump> mediump_dvec3;






 typedef tvec3<double, lowp> lowp_dvec3;






 typedef tvec3<int, highp> highp_ivec3;






 typedef tvec3<int, mediump> mediump_ivec3;






 typedef tvec3<int, lowp> lowp_ivec3;






 typedef tvec3<uint, highp> highp_uvec3;






 typedef tvec3<uint, mediump> mediump_uvec3;






 typedef tvec3<uint, lowp> lowp_uvec3;





 typedef tvec3<bool, highp> highp_bvec3;





 typedef tvec3<bool, mediump> mediump_bvec3;





 typedef tvec3<bool, lowp> lowp_bvec3;
# 286 "../glm/gtx/../detail/type_vec.hpp"
 typedef tvec4<float, highp> highp_vec4;





 typedef tvec4<float, mediump> mediump_vec4;





 typedef tvec4<float, lowp> lowp_vec4;





 typedef tvec4<double, highp> highp_dvec4;





 typedef tvec4<double, mediump> mediump_dvec4;





 typedef tvec4<double, lowp> lowp_dvec4;





 typedef tvec4<int, highp> highp_ivec4;





 typedef tvec4<int, mediump> mediump_ivec4;





 typedef tvec4<int, lowp> lowp_ivec4;





 typedef tvec4<uint, highp> highp_uvec4;





 typedef tvec4<uint, mediump> mediump_uvec4;





 typedef tvec4<uint, lowp> lowp_uvec4;





 typedef tvec4<bool, highp> highp_bvec4;





 typedef tvec4<bool, mediump> mediump_bvec4;





 typedef tvec4<bool, lowp> lowp_bvec4;
# 392 "../glm/gtx/../detail/type_vec.hpp"
 typedef highp_vec2 vec2;




 typedef highp_vec3 vec3;




 typedef highp_vec4 vec4;
# 420 "../glm/gtx/../detail/type_vec.hpp"
 typedef highp_dvec2 dvec2;




 typedef highp_dvec3 dvec3;




 typedef highp_dvec4 dvec4;
# 448 "../glm/gtx/../detail/type_vec.hpp"
 typedef highp_ivec2 ivec2;




 typedef highp_ivec3 ivec3;




 typedef highp_ivec4 ivec4;
# 476 "../glm/gtx/../detail/type_vec.hpp"
 typedef highp_uvec2 uvec2;




 typedef highp_uvec3 uvec3;




 typedef highp_uvec4 uvec4;
# 504 "../glm/gtx/../detail/type_vec.hpp"
 typedef highp_bvec2 bvec2;




 typedef highp_bvec3 bvec3;




 typedef highp_bvec4 bvec4;



}
# 38 "../glm/gtx/../fwd.hpp" 2
# 1 "../glm/gtx/../detail/type_mat.hpp" 1
# 33 "../glm/gtx/../detail/type_mat.hpp"
       



namespace glm{
namespace detail
{
 template <typename T, precision P, template <class, precision> class colType, template <class, precision> class rowType>
 struct outerProduct_trait{};
}

 template <typename T, precision P> struct tvec2;
 template <typename T, precision P> struct tvec3;
 template <typename T, precision P> struct tvec4;
 template <typename T, precision P> struct tmat2x2;
 template <typename T, precision P> struct tmat2x3;
 template <typename T, precision P> struct tmat2x4;
 template <typename T, precision P> struct tmat3x2;
 template <typename T, precision P> struct tmat3x3;
 template <typename T, precision P> struct tmat3x4;
 template <typename T, precision P> struct tmat4x2;
 template <typename T, precision P> struct tmat4x3;
 template <typename T, precision P> struct tmat4x4;
# 65 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat2x2<float, lowp> lowp_mat2;






 typedef tmat2x2<float, mediump> mediump_mat2;






 typedef tmat2x2<float, highp> highp_mat2;






 typedef tmat2x2<float, lowp> lowp_mat2x2;






 typedef tmat2x2<float, mediump> mediump_mat2x2;






 typedef tmat2x2<float, highp> highp_mat2x2;
# 112 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat2x3<float, lowp> lowp_mat2x3;






 typedef tmat2x3<float, mediump> mediump_mat2x3;






 typedef tmat2x3<float, highp> highp_mat2x3;
# 138 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat2x4<float, lowp> lowp_mat2x4;






 typedef tmat2x4<float, mediump> mediump_mat2x4;






 typedef tmat2x4<float, highp> highp_mat2x4;
# 164 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat3x2<float, lowp> lowp_mat3x2;






 typedef tmat3x2<float, mediump> mediump_mat3x2;






 typedef tmat3x2<float, highp> highp_mat3x2;
# 190 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat3x3<float, lowp> lowp_mat3;






 typedef tmat3x3<float, mediump> mediump_mat3;






 typedef tmat3x3<float, highp> highp_mat3;






 typedef tmat3x3<float, lowp> lowp_mat3x3;






 typedef tmat3x3<float, mediump> mediump_mat3x3;






 typedef tmat3x3<float, highp> highp_mat3x3;
# 237 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat3x4<float, lowp> lowp_mat3x4;






 typedef tmat3x4<float, mediump> mediump_mat3x4;






 typedef tmat3x4<float, highp> highp_mat3x4;
# 263 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat4x2<float, lowp> lowp_mat4x2;






 typedef tmat4x2<float, mediump> mediump_mat4x2;






 typedef tmat4x2<float, highp> highp_mat4x2;
# 289 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat4x3<float, lowp> lowp_mat4x3;






 typedef tmat4x3<float, mediump> mediump_mat4x3;






 typedef tmat4x3<float, highp> highp_mat4x3;
# 316 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat4x4<float, lowp> lowp_mat4;






 typedef tmat4x4<float, mediump> mediump_mat4;






 typedef tmat4x4<float, highp> highp_mat4;






 typedef tmat4x4<float, lowp> lowp_mat4x4;






 typedef tmat4x4<float, mediump> mediump_mat4x4;






 typedef tmat4x4<float, highp> highp_mat4x4;
# 385 "../glm/gtx/../detail/type_mat.hpp"
 typedef highp_mat2x2 mat2x2;




 typedef highp_mat2x3 mat2x3;




 typedef highp_mat2x4 mat2x4;




 typedef highp_mat3x2 mat3x2;




 typedef highp_mat3x3 mat3x3;




 typedef highp_mat3x4 mat3x4;




 typedef highp_mat4x2 mat4x2;




 typedef highp_mat4x3 mat4x3;




 typedef highp_mat4x4 mat4x4;






 typedef mat2x2 mat2;




 typedef mat3x3 mat3;




 typedef mat4x4 mat4;
# 454 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat2x2<double, lowp> lowp_dmat2;





 typedef tmat2x2<double, mediump> mediump_dmat2;





 typedef tmat2x2<double, highp> highp_dmat2;





 typedef tmat2x2<double, lowp> lowp_dmat2x2;





 typedef tmat2x2<double, mediump> mediump_dmat2x2;





 typedef tmat2x2<double, highp> highp_dmat2x2;
# 495 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat2x3<double, lowp> lowp_dmat2x3;





 typedef tmat2x3<double, mediump> mediump_dmat2x3;





 typedef tmat2x3<double, highp> highp_dmat2x3;
# 518 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat2x4<double, lowp> lowp_dmat2x4;





 typedef tmat2x4<double, mediump> mediump_dmat2x4;





 typedef tmat2x4<double, highp> highp_dmat2x4;
# 541 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat3x2<double, lowp> lowp_dmat3x2;





 typedef tmat3x2<double, mediump> mediump_dmat3x2;





 typedef tmat3x2<double, highp> highp_dmat3x2;
# 564 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat3x3<float, lowp> lowp_dmat3;





 typedef tmat3x3<double, mediump> mediump_dmat3;





 typedef tmat3x3<double, highp> highp_dmat3;





 typedef tmat3x3<double, lowp> lowp_dmat3x3;





 typedef tmat3x3<double, mediump> mediump_dmat3x3;





 typedef tmat3x3<double, highp> highp_dmat3x3;
# 605 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat3x4<double, lowp> lowp_dmat3x4;





 typedef tmat3x4<double, mediump> mediump_dmat3x4;





 typedef tmat3x4<double, highp> highp_dmat3x4;
# 628 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat4x2<double, lowp> lowp_dmat4x2;





 typedef tmat4x2<double, mediump> mediump_dmat4x2;





 typedef tmat4x2<double, highp> highp_dmat4x2;
# 651 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat4x3<double, lowp> lowp_dmat4x3;





 typedef tmat4x3<double, mediump> mediump_dmat4x3;





 typedef tmat4x3<double, highp> highp_dmat4x3;
# 674 "../glm/gtx/../detail/type_mat.hpp"
 typedef tmat4x4<double, lowp> lowp_dmat4;





 typedef tmat4x4<double, mediump> mediump_dmat4;





 typedef tmat4x4<double, highp> highp_dmat4;





 typedef tmat4x4<double, lowp> lowp_dmat4x4;





 typedef tmat4x4<double, mediump> mediump_dmat4x4;





 typedef tmat4x4<double, highp> highp_dmat4x4;
# 733 "../glm/gtx/../detail/type_mat.hpp"
 typedef highp_dmat2x2 dmat2;




 typedef highp_dmat3x3 dmat3;




 typedef highp_dmat4x4 dmat4;




 typedef highp_dmat2x2 dmat2x2;




 typedef highp_dmat2x3 dmat2x3;




 typedef highp_dmat2x4 dmat2x4;




 typedef highp_dmat3x2 dmat3x2;




 typedef highp_dmat3x3 dmat3x3;




 typedef highp_dmat3x4 dmat3x4;




 typedef highp_dmat4x2 dmat4x2;




 typedef highp_dmat4x3 dmat4x3;




 typedef highp_dmat4x4 dmat4x4;




}
# 39 "../glm/gtx/../fwd.hpp" 2



namespace glm
{
 template <typename T, precision P> struct tquat;




 typedef tquat<float, lowp> lowp_quat;




 typedef tquat<float, mediump> mediump_quat;




 typedef tquat<float, highp> highp_quat;
# 69 "../glm/gtx/../fwd.hpp"
 typedef highp_quat quat;





 typedef lowp_quat lowp_fquat;




 typedef mediump_quat mediump_fquat;




 typedef highp_quat highp_fquat;




 typedef quat fquat;





 typedef tquat<double, lowp> lowp_dquat;




 typedef tquat<double, mediump> mediump_dquat;




 typedef tquat<double, highp> highp_dquat;
# 118 "../glm/gtx/../fwd.hpp"
 typedef highp_dquat dquat;


}



namespace glm
{





 typedef detail::int8 lowp_int8;



 typedef detail::int16 lowp_int16;



 typedef detail::int32 lowp_int32;



 typedef detail::int64 lowp_int64;



 typedef detail::int8 lowp_int8_t;



 typedef detail::int16 lowp_int16_t;



 typedef detail::int32 lowp_int32_t;



 typedef detail::int64 lowp_int64_t;



 typedef detail::int8 lowp_i8;



 typedef detail::int16 lowp_i16;



 typedef detail::int32 lowp_i32;



 typedef detail::int64 lowp_i64;



 typedef detail::int8 mediump_int8;



 typedef detail::int16 mediump_int16;



 typedef detail::int32 mediump_int32;



 typedef detail::int64 mediump_int64;



 typedef detail::int8 mediump_int8_t;



 typedef detail::int16 mediump_int16_t;



 typedef detail::int32 mediump_int32_t;



 typedef detail::int64 mediump_int64_t;



 typedef detail::int8 mediump_i8;



 typedef detail::int16 mediump_i16;



 typedef detail::int32 mediump_i32;



 typedef detail::int64 mediump_i64;



 typedef detail::int8 highp_int8;



 typedef detail::int16 highp_int16;



 typedef detail::int32 highp_int32;



 typedef detail::int64 highp_int64;



 typedef detail::int8 highp_int8_t;



 typedef detail::int16 highp_int16_t;



 typedef detail::int32 highp_int32_t;



 typedef detail::int64 highp_int64_t;



 typedef detail::int8 highp_i8;



 typedef detail::int16 highp_i16;



 typedef detail::int32 highp_i32;



 typedef detail::int64 highp_i64;




 typedef detail::int8 int8;



 typedef detail::int16 int16;



 typedef detail::int32 int32;



 typedef detail::int64 int64;



 using std::int8_t;
 using std::int16_t;
 using std::int32_t;
 using std::int64_t;
# 317 "../glm/gtx/../fwd.hpp"
 typedef detail::int8 i8;



 typedef detail::int16 i16;



 typedef detail::int32 i32;



 typedef detail::int64 i64;





 typedef tvec1<i8, lowp> lowp_i8vec1;



 typedef tvec2<i8, lowp> lowp_i8vec2;



 typedef tvec3<i8, lowp> lowp_i8vec3;



 typedef tvec4<i8, lowp> lowp_i8vec4;




 typedef tvec1<i8, mediump> mediump_i8vec1;



 typedef tvec2<i8, mediump> mediump_i8vec2;



 typedef tvec3<i8, mediump> mediump_i8vec3;



 typedef tvec4<i8, mediump> mediump_i8vec4;




 typedef tvec1<i8, highp> highp_i8vec1;



 typedef tvec2<i8, highp> highp_i8vec2;



 typedef tvec3<i8, highp> highp_i8vec3;



 typedef tvec4<i8, highp> highp_i8vec4;
# 396 "../glm/gtx/../fwd.hpp"
 typedef highp_i8vec1 i8vec1;



 typedef highp_i8vec2 i8vec2;



 typedef highp_i8vec3 i8vec3;



 typedef highp_i8vec4 i8vec4;





 typedef tvec1<i16, lowp> lowp_i16vec1;



 typedef tvec2<i16, lowp> lowp_i16vec2;



 typedef tvec3<i16, lowp> lowp_i16vec3;



 typedef tvec4<i16, lowp> lowp_i16vec4;




 typedef tvec1<i16, mediump> mediump_i16vec1;



 typedef tvec2<i16, mediump> mediump_i16vec2;



 typedef tvec3<i16, mediump> mediump_i16vec3;



 typedef tvec4<i16, mediump> mediump_i16vec4;




 typedef tvec1<i16, highp> highp_i16vec1;



 typedef tvec2<i16, highp> highp_i16vec2;



 typedef tvec3<i16, highp> highp_i16vec3;



 typedef tvec4<i16, highp> highp_i16vec4;
# 476 "../glm/gtx/../fwd.hpp"
 typedef highp_i16vec1 i16vec1;



 typedef highp_i16vec2 i16vec2;



 typedef highp_i16vec3 i16vec3;



 typedef highp_i16vec4 i16vec4;





 typedef tvec1<i32, lowp> lowp_i32vec1;



 typedef tvec2<i32, lowp> lowp_i32vec2;



 typedef tvec3<i32, lowp> lowp_i32vec3;



 typedef tvec4<i32, lowp> lowp_i32vec4;




 typedef tvec1<i32, mediump> mediump_i32vec1;



 typedef tvec2<i32, mediump> mediump_i32vec2;



 typedef tvec3<i32, mediump> mediump_i32vec3;



 typedef tvec4<i32, mediump> mediump_i32vec4;




 typedef tvec1<i32, highp> highp_i32vec1;



 typedef tvec2<i32, highp> highp_i32vec2;



 typedef tvec3<i32, highp> highp_i32vec3;



 typedef tvec4<i32, highp> highp_i32vec4;
# 555 "../glm/gtx/../fwd.hpp"
 typedef highp_i32vec1 i32vec1;



 typedef highp_i32vec2 i32vec2;



 typedef highp_i32vec3 i32vec3;



 typedef highp_i32vec4 i32vec4;





 typedef tvec1<i32, lowp> lowp_i32vec1;



 typedef tvec2<i32, lowp> lowp_i32vec2;



 typedef tvec3<i32, lowp> lowp_i32vec3;



 typedef tvec4<i32, lowp> lowp_i32vec4;




 typedef tvec1<i32, mediump> mediump_i32vec1;



 typedef tvec2<i32, mediump> mediump_i32vec2;



 typedef tvec3<i32, mediump> mediump_i32vec3;



 typedef tvec4<i32, mediump> mediump_i32vec4;




 typedef tvec1<i32, highp> highp_i32vec1;



 typedef tvec2<i32, highp> highp_i32vec2;



 typedef tvec3<i32, highp> highp_i32vec3;



 typedef tvec4<i32, highp> highp_i32vec4;
# 634 "../glm/gtx/../fwd.hpp"
 typedef highp_i32vec1 i32vec1;



 typedef highp_i32vec2 i32vec2;



 typedef highp_i32vec3 i32vec3;



 typedef highp_i32vec4 i32vec4;






 typedef tvec1<i64, lowp> lowp_i64vec1;



 typedef tvec2<i64, lowp> lowp_i64vec2;



 typedef tvec3<i64, lowp> lowp_i64vec3;



 typedef tvec4<i64, lowp> lowp_i64vec4;




 typedef tvec1<i64, mediump> mediump_i64vec1;



 typedef tvec2<i64, mediump> mediump_i64vec2;



 typedef tvec3<i64, mediump> mediump_i64vec3;



 typedef tvec4<i64, mediump> mediump_i64vec4;




 typedef tvec1<i64, highp> highp_i64vec1;



 typedef tvec2<i64, highp> highp_i64vec2;



 typedef tvec3<i64, highp> highp_i64vec3;



 typedef tvec4<i64, highp> highp_i64vec4;
# 714 "../glm/gtx/../fwd.hpp"
 typedef highp_i64vec1 i64vec1;



 typedef highp_i64vec2 i64vec2;



 typedef highp_i64vec3 i64vec3;



 typedef highp_i64vec4 i64vec4;
# 735 "../glm/gtx/../fwd.hpp"
 typedef detail::uint8 lowp_uint8;



 typedef detail::uint16 lowp_uint16;



 typedef detail::uint32 lowp_uint32;



 typedef detail::uint64 lowp_uint64;




 typedef detail::uint8 lowp_uint8_t;



 typedef detail::uint16 lowp_uint16_t;



 typedef detail::uint32 lowp_uint32_t;



 typedef detail::uint64 lowp_uint64_t;




 typedef detail::uint8 lowp_u8;



 typedef detail::uint16 lowp_u16;



 typedef detail::uint32 lowp_u32;



 typedef detail::uint64 lowp_u64;





 typedef detail::uint8 mediump_uint8;



 typedef detail::uint16 mediump_uint16;



 typedef detail::uint32 mediump_uint32;



 typedef detail::uint64 mediump_uint64;



 typedef detail::uint8 mediump_uint8_t;



 typedef detail::uint16 mediump_uint16_t;



 typedef detail::uint32 mediump_uint32_t;



 typedef detail::uint64 mediump_uint64_t;



 typedef detail::uint8 mediump_u8;



 typedef detail::uint16 mediump_u16;



 typedef detail::uint32 mediump_u32;



 typedef detail::uint64 mediump_u64;





 typedef detail::uint8 highp_uint8;



 typedef detail::uint16 highp_uint16;



 typedef detail::uint32 highp_uint32;



 typedef detail::uint64 highp_uint64;



 typedef detail::uint8 highp_uint8_t;



 typedef detail::uint16 highp_uint16_t;



 typedef detail::uint32 highp_uint32_t;



 typedef detail::uint64 highp_uint64_t;



 typedef detail::uint8 highp_u8;



 typedef detail::uint16 highp_u16;



 typedef detail::uint32 highp_u32;



 typedef detail::uint64 highp_u64;





 typedef detail::uint8 uint8;



 typedef detail::uint16 uint16;



 typedef detail::uint32 uint32;



 typedef detail::uint64 uint64;


 using std::uint8_t;
 using std::uint16_t;
 using std::uint32_t;
 using std::uint64_t;
# 926 "../glm/gtx/../fwd.hpp"
 typedef detail::uint8 u8;



 typedef detail::uint16 u16;



 typedef detail::uint32 u32;



 typedef detail::uint64 u64;





 typedef tvec1<u8, lowp> lowp_u8vec1;



 typedef tvec2<u8, lowp> lowp_u8vec2;



 typedef tvec3<u8, lowp> lowp_u8vec3;



 typedef tvec4<u8, lowp> lowp_u8vec4;




 typedef tvec1<u8, mediump> mediump_u8vec1;



 typedef tvec2<u8, mediump> mediump_u8vec2;



 typedef tvec3<u8, mediump> mediump_u8vec3;



 typedef tvec4<u8, mediump> mediump_u8vec4;




 typedef tvec1<u8, highp> highp_u8vec1;



 typedef tvec2<u8, highp> highp_u8vec2;



 typedef tvec3<u8, highp> highp_u8vec3;



 typedef tvec4<u8, highp> highp_u8vec4;
# 1005 "../glm/gtx/../fwd.hpp"
 typedef highp_u8vec1 u8vec1;



 typedef highp_u8vec2 u8vec2;



 typedef highp_u8vec3 u8vec3;



 typedef highp_u8vec4 u8vec4;





 typedef tvec1<u16, lowp> lowp_u16vec1;



 typedef tvec2<u16, lowp> lowp_u16vec2;



 typedef tvec3<u16, lowp> lowp_u16vec3;



 typedef tvec4<u16, lowp> lowp_u16vec4;




 typedef tvec1<u16, mediump> mediump_u16vec1;



 typedef tvec2<u16, mediump> mediump_u16vec2;



 typedef tvec3<u16, mediump> mediump_u16vec3;



 typedef tvec4<u16, mediump> mediump_u16vec4;




 typedef tvec1<u16, highp> highp_u16vec1;



 typedef tvec2<u16, highp> highp_u16vec2;



 typedef tvec3<u16, highp> highp_u16vec3;



 typedef tvec4<u16, highp> highp_u16vec4;
# 1085 "../glm/gtx/../fwd.hpp"
 typedef highp_u16vec1 u16vec1;



 typedef highp_u16vec2 u16vec2;



 typedef highp_u16vec3 u16vec3;



 typedef highp_u16vec4 u16vec4;





 typedef tvec1<u32, lowp> lowp_u32vec1;



 typedef tvec2<u32, lowp> lowp_u32vec2;



 typedef tvec3<u32, lowp> lowp_u32vec3;



 typedef tvec4<u32, lowp> lowp_u32vec4;




 typedef tvec1<u32, mediump> mediump_u32vec1;



 typedef tvec2<u32, mediump> mediump_u32vec2;



 typedef tvec3<u32, mediump> mediump_u32vec3;



 typedef tvec4<u32, mediump> mediump_u32vec4;




 typedef tvec1<u32, highp> highp_u32vec1;



 typedef tvec2<u32, highp> highp_u32vec2;



 typedef tvec3<u32, highp> highp_u32vec3;



 typedef tvec4<u32, highp> highp_u32vec4;
# 1164 "../glm/gtx/../fwd.hpp"
 typedef highp_u32vec1 u32vec1;



 typedef highp_u32vec2 u32vec2;



 typedef highp_u32vec3 u32vec3;



 typedef highp_u32vec4 u32vec4;





 typedef tvec1<u32, lowp> lowp_u32vec1;



 typedef tvec2<u32, lowp> lowp_u32vec2;



 typedef tvec3<u32, lowp> lowp_u32vec3;



 typedef tvec4<u32, lowp> lowp_u32vec4;




 typedef tvec1<u32, mediump> mediump_u32vec1;



 typedef tvec2<u32, mediump> mediump_u32vec2;



 typedef tvec3<u32, mediump> mediump_u32vec3;



 typedef tvec4<u32, mediump> mediump_u32vec4;




 typedef tvec1<u32, highp> highp_u32vec1;



 typedef tvec2<u32, highp> highp_u32vec2;



 typedef tvec3<u32, highp> highp_u32vec3;



 typedef tvec4<u32, highp> highp_u32vec4;
# 1243 "../glm/gtx/../fwd.hpp"
 typedef highp_u32vec1 u32vec1;



 typedef highp_u32vec2 u32vec2;



 typedef highp_u32vec3 u32vec3;



 typedef highp_u32vec4 u32vec4;






 typedef tvec1<u64, lowp> lowp_u64vec1;



 typedef tvec2<u64, lowp> lowp_u64vec2;



 typedef tvec3<u64, lowp> lowp_u64vec3;



 typedef tvec4<u64, lowp> lowp_u64vec4;




 typedef tvec1<u64, mediump> mediump_u64vec1;



 typedef tvec2<u64, mediump> mediump_u64vec2;



 typedef tvec3<u64, mediump> mediump_u64vec3;



 typedef tvec4<u64, mediump> mediump_u64vec4;




 typedef tvec1<u64, highp> highp_u64vec1;



 typedef tvec2<u64, highp> highp_u64vec2;



 typedef tvec3<u64, highp> highp_u64vec3;



 typedef tvec4<u64, highp> highp_u64vec4;
# 1323 "../glm/gtx/../fwd.hpp"
 typedef highp_u64vec1 u64vec1;



 typedef highp_u64vec2 u64vec2;



 typedef highp_u64vec3 u64vec3;



 typedef highp_u64vec4 u64vec4;
# 1344 "../glm/gtx/../fwd.hpp"
 typedef detail::float32 lowp_float32;



 typedef detail::float64 lowp_float64;



 typedef detail::float32 lowp_float32_t;



 typedef detail::float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;



 typedef detail::float32 lowp_float32;



 typedef detail::float64 lowp_float64;



 typedef detail::float32 lowp_float32_t;



 typedef detail::float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;




 typedef detail::float32 lowp_float32;



 typedef detail::float64 lowp_float64;



 typedef detail::float32 lowp_float32_t;



 typedef detail::float64 lowp_float64_t;



 typedef float32 lowp_f32;



 typedef float64 lowp_f64;




 typedef detail::float32 mediump_float32;



 typedef detail::float64 mediump_float64;



 typedef detail::float32 mediump_float32_t;



 typedef detail::float64 mediump_float64_t;



 typedef float32 mediump_f32;



 typedef float64 mediump_f64;




 typedef detail::float32 highp_float32;



 typedef detail::float64 highp_float64;



 typedef detail::float32 highp_float32_t;



 typedef detail::float64 highp_float64_t;



 typedef float32 highp_f32;



 typedef float64 highp_f64;
# 1521 "../glm/gtx/../fwd.hpp"
 typedef highp_float32 float32;



 typedef highp_float64 float64;



 typedef highp_float32_t float32_t;



 typedef highp_float64_t float64_t;



 typedef highp_float32_t f32;



 typedef highp_float64_t f64;





 typedef tvec1<float, lowp> lowp_vec1;



 typedef tvec2<float, lowp> lowp_vec2;



 typedef tvec3<float, lowp> lowp_vec3;



 typedef tvec4<float, lowp> lowp_vec4;



 typedef tvec1<float, lowp> lowp_fvec1;



 typedef tvec2<float, lowp> lowp_fvec2;



 typedef tvec3<float, lowp> lowp_fvec3;



 typedef tvec4<float, lowp> lowp_fvec4;




 typedef tvec1<float, mediump> mediump_vec1;



 typedef tvec2<float, mediump> mediump_vec2;



 typedef tvec3<float, mediump> mediump_vec3;



 typedef tvec4<float, mediump> mediump_vec4;



 typedef tvec1<float, mediump> mediump_fvec1;



 typedef tvec2<float, mediump> mediump_fvec2;



 typedef tvec3<float, mediump> mediump_fvec3;



 typedef tvec4<float, mediump> mediump_fvec4;




 typedef tvec1<float, highp> highp_vec1;



 typedef tvec2<float, highp> highp_vec2;



 typedef tvec3<float, highp> highp_vec3;



 typedef tvec4<float, highp> highp_vec4;



 typedef tvec1<float, highp> highp_fvec1;



 typedef tvec2<float, highp> highp_fvec2;



 typedef tvec3<float, highp> highp_fvec3;



 typedef tvec4<float, highp> highp_fvec4;




 typedef tvec1<f32, lowp> lowp_f32vec1;



 typedef tvec2<f32, lowp> lowp_f32vec2;



 typedef tvec3<f32, lowp> lowp_f32vec3;



 typedef tvec4<f32, lowp> lowp_f32vec4;



 typedef tvec1<f32, mediump> mediump_f32vec1;



 typedef tvec2<f32, mediump> mediump_f32vec2;



 typedef tvec3<f32, mediump> mediump_f32vec3;



 typedef tvec4<f32, mediump> mediump_f32vec4;



 typedef tvec1<f32, highp> highp_f32vec1;



 typedef tvec2<f32, highp> highp_f32vec2;



 typedef tvec3<f32, highp> highp_f32vec3;



 typedef tvec4<f32, highp> highp_f32vec4;




 typedef tvec1<f64, lowp> lowp_f64vec1;



 typedef tvec2<f64, lowp> lowp_f64vec2;



 typedef tvec3<f64, lowp> lowp_f64vec3;



 typedef tvec4<f64, lowp> lowp_f64vec4;



 typedef tvec1<f64, mediump> mediump_f64vec1;



 typedef tvec2<f64, mediump> mediump_f64vec2;



 typedef tvec3<f64, mediump> mediump_f64vec3;



 typedef tvec4<f64, mediump> mediump_f64vec4;



 typedef tvec1<f64, highp> highp_f64vec1;



 typedef tvec2<f64, highp> highp_f64vec2;



 typedef tvec3<f64, highp> highp_f64vec3;



 typedef tvec4<f64, highp> highp_f64vec4;
# 1751 "../glm/gtx/../fwd.hpp"
 typedef tmat2x2<f32, lowp> lowp_fmat2x2;



 typedef tmat2x3<f32, lowp> lowp_fmat2x3;



 typedef tmat2x4<f32, lowp> lowp_fmat2x4;



 typedef tmat3x2<f32, lowp> lowp_fmat3x2;



 typedef tmat3x3<f32, lowp> lowp_fmat3x3;



 typedef tmat3x4<f32, lowp> lowp_fmat3x4;



 typedef tmat4x2<f32, lowp> lowp_fmat4x2;



 typedef tmat4x3<f32, lowp> lowp_fmat4x3;



 typedef tmat4x4<f32, lowp> lowp_fmat4x4;







 typedef lowp_fmat2x2 lowp_fmat2;



 typedef lowp_fmat3x3 lowp_fmat3;



 typedef lowp_fmat4x4 lowp_fmat4;
# 1808 "../glm/gtx/../fwd.hpp"
 typedef tmat2x2<f32, mediump> mediump_fmat2x2;



 typedef tmat2x3<f32, mediump> mediump_fmat2x3;



 typedef tmat2x4<f32, mediump> mediump_fmat2x4;



 typedef tmat3x2<f32, mediump> mediump_fmat3x2;



 typedef tmat3x3<f32, mediump> mediump_fmat3x3;



 typedef tmat3x4<f32, mediump> mediump_fmat3x4;



 typedef tmat4x2<f32, mediump> mediump_fmat4x2;



 typedef tmat4x3<f32, mediump> mediump_fmat4x3;



 typedef tmat4x4<f32, mediump> mediump_fmat4x4;







 typedef mediump_fmat2x2 mediump_fmat2;



 typedef mediump_fmat3x3 mediump_fmat3;



 typedef mediump_fmat4x4 mediump_fmat4;
# 1865 "../glm/gtx/../fwd.hpp"
 typedef tmat2x2<f32, highp> highp_fmat2x2;



 typedef tmat2x3<f32, highp> highp_fmat2x3;



 typedef tmat2x4<f32, highp> highp_fmat2x4;



 typedef tmat3x2<f32, highp> highp_fmat3x2;



 typedef tmat3x3<f32, highp> highp_fmat3x3;



 typedef tmat3x4<f32, highp> highp_fmat3x4;



 typedef tmat4x2<f32, highp> highp_fmat4x2;



 typedef tmat4x3<f32, highp> highp_fmat4x3;



 typedef tmat4x4<f32, highp> highp_fmat4x4;







 typedef highp_fmat2x2 highp_fmat2;



 typedef highp_fmat3x3 highp_fmat3;



 typedef highp_fmat4x4 highp_fmat4;
# 1922 "../glm/gtx/../fwd.hpp"
 typedef tmat2x2<f32, lowp> lowp_f32mat2x2;



 typedef tmat2x3<f32, lowp> lowp_f32mat2x3;



 typedef tmat2x4<f32, lowp> lowp_f32mat2x4;



 typedef tmat3x2<f32, lowp> lowp_f32mat3x2;



 typedef tmat3x3<f32, lowp> lowp_f32mat3x3;



 typedef tmat3x4<f32, lowp> lowp_f32mat3x4;



 typedef tmat4x2<f32, lowp> lowp_f32mat4x2;



 typedef tmat4x3<f32, lowp> lowp_f32mat4x3;



 typedef tmat4x4<f32, lowp> lowp_f32mat4x4;







 typedef lowp_f32mat2x2 lowp_f32mat2;



 typedef lowp_f32mat3x3 lowp_f32mat3;



 typedef lowp_f32mat4x4 lowp_f32mat4;
# 1979 "../glm/gtx/../fwd.hpp"
 typedef tmat2x2<f32, mediump> mediump_f32mat2x2;



 typedef tmat2x3<f32, mediump> mediump_f32mat2x3;



 typedef tmat2x4<f32, mediump> mediump_f32mat2x4;



 typedef tmat3x2<f32, mediump> mediump_f32mat3x2;



 typedef tmat3x3<f32, mediump> mediump_f32mat3x3;



 typedef tmat3x4<f32, mediump> mediump_f32mat3x4;



 typedef tmat4x2<f32, mediump> mediump_f32mat4x2;



 typedef tmat4x3<f32, mediump> mediump_f32mat4x3;



 typedef tmat4x4<f32, mediump> mediump_f32mat4x4;







 typedef mediump_f32mat2x2 mediump_f32mat2;



 typedef mediump_f32mat3x3 mediump_f32mat3;



 typedef mediump_f32mat4x4 mediump_f32mat4;
# 2036 "../glm/gtx/../fwd.hpp"
 typedef tmat2x2<f32, highp> highp_f32mat2x2;



 typedef tmat2x3<f32, highp> highp_f32mat2x3;



 typedef tmat2x4<f32, highp> highp_f32mat2x4;



 typedef tmat3x2<f32, highp> highp_f32mat3x2;



 typedef tmat3x3<f32, highp> highp_f32mat3x3;



 typedef tmat3x4<f32, highp> highp_f32mat3x4;



 typedef tmat4x2<f32, highp> highp_f32mat4x2;



 typedef tmat4x3<f32, highp> highp_f32mat4x3;



 typedef tmat4x4<f32, highp> highp_f32mat4x4;







 typedef highp_f32mat2x2 highp_f32mat2;



 typedef highp_f32mat3x3 highp_f32mat3;



 typedef highp_f32mat4x4 highp_f32mat4;
# 2093 "../glm/gtx/../fwd.hpp"
 typedef tmat2x2<f64, lowp> lowp_f64mat2x2;



 typedef tmat2x3<f64, lowp> lowp_f64mat2x3;



 typedef tmat2x4<f64, lowp> lowp_f64mat2x4;



 typedef tmat3x2<f64, lowp> lowp_f64mat3x2;



 typedef tmat3x3<f64, lowp> lowp_f64mat3x3;



 typedef tmat3x4<f64, lowp> lowp_f64mat3x4;



 typedef tmat4x2<f64, lowp> lowp_f64mat4x2;



 typedef tmat4x3<f64, lowp> lowp_f64mat4x3;



 typedef tmat4x4<f64, lowp> lowp_f64mat4x4;







 typedef lowp_f64mat2x2 lowp_f64mat2;



 typedef lowp_f64mat3x3 lowp_f64mat3;



 typedef lowp_f64mat4x4 lowp_f64mat4;
# 2150 "../glm/gtx/../fwd.hpp"
 typedef tmat2x2<f64, mediump> mediump_f64mat2x2;



 typedef tmat2x3<f64, mediump> mediump_f64mat2x3;



 typedef tmat2x4<f64, mediump> mediump_f64mat2x4;



 typedef tmat3x2<f64, mediump> mediump_f64mat3x2;



 typedef tmat3x3<f64, mediump> mediump_f64mat3x3;



 typedef tmat3x4<f64, mediump> mediump_f64mat3x4;



 typedef tmat4x2<f64, mediump> mediump_f64mat4x2;



 typedef tmat4x3<f64, mediump> mediump_f64mat4x3;



 typedef tmat4x4<f64, mediump> mediump_f64mat4x4;







 typedef mediump_f64mat2x2 mediump_f64mat2;



 typedef mediump_f64mat3x3 mediump_f64mat3;



 typedef mediump_f64mat4x4 mediump_f64mat4;







 typedef tmat2x2<f64, highp> highp_f64mat2x2;



 typedef tmat2x3<f64, highp> highp_f64mat2x3;



 typedef tmat2x4<f64, highp> highp_f64mat2x4;



 typedef tmat3x2<f64, highp> highp_f64mat3x2;



 typedef tmat3x3<f64, highp> highp_f64mat3x3;



 typedef tmat3x4<f64, highp> highp_f64mat3x4;



 typedef tmat4x2<f64, highp> highp_f64mat4x2;



 typedef tmat4x3<f64, highp> highp_f64mat4x3;



 typedef tmat4x4<f64, highp> highp_f64mat4x4;







 typedef highp_f64mat2x2 highp_f64mat2;



 typedef highp_f64mat3x3 highp_f64mat3;



 typedef highp_f64mat4x4 highp_f64mat4;






 typedef tquat<f32, lowp> lowp_f32quat;



 typedef tquat<f64, lowp> lowp_f64quat;



 typedef tquat<f32, mediump> mediump_f32quat;



 typedef tquat<f64, mediump> mediump_f64quat;



 typedef tquat<f32, highp> highp_f32quat;



 typedef tquat<f64, highp> highp_f64quat;
# 2359 "../glm/gtx/../fwd.hpp"
 typedef highp_f32vec1 fvec1;



 typedef highp_f32vec2 fvec2;



 typedef highp_f32vec3 fvec3;



 typedef highp_f32vec4 fvec4;



 typedef highp_f32mat2x2 fmat2x2;



 typedef highp_f32mat2x3 fmat2x3;



 typedef highp_f32mat2x4 fmat2x4;



 typedef highp_f32mat3x2 fmat3x2;



 typedef highp_f32mat3x3 fmat3x3;



 typedef highp_f32mat3x4 fmat3x4;



 typedef highp_f32mat4x2 fmat4x2;



 typedef highp_f32mat4x3 fmat4x3;



 typedef highp_f32mat4x4 fmat4x4;



 typedef fmat2x2 fmat2;



 typedef fmat3x3 fmat3;



 typedef fmat4x4 fmat4;



 typedef highp_fquat fquat;





 typedef highp_f32vec1 f32vec1;



 typedef highp_f32vec2 f32vec2;



 typedef highp_f32vec3 f32vec3;



 typedef highp_f32vec4 f32vec4;



 typedef highp_f32mat2x2 f32mat2x2;



 typedef highp_f32mat2x3 f32mat2x3;



 typedef highp_f32mat2x4 f32mat2x4;



 typedef highp_f32mat3x2 f32mat3x2;



 typedef highp_f32mat3x3 f32mat3x3;



 typedef highp_f32mat3x4 f32mat3x4;



 typedef highp_f32mat4x2 f32mat4x2;



 typedef highp_f32mat4x3 f32mat4x3;



 typedef highp_f32mat4x4 f32mat4x4;



 typedef f32mat2x2 f32mat2;



 typedef f32mat3x3 f32mat3;



 typedef f32mat4x4 f32mat4;



 typedef highp_f32quat f32quat;
# 2535 "../glm/gtx/../fwd.hpp"
 typedef highp_f64vec1 f64vec1;



 typedef highp_f64vec2 f64vec2;



 typedef highp_f64vec3 f64vec3;



 typedef highp_f64vec4 f64vec4;



 typedef highp_f64mat2x2 f64mat2x2;



 typedef highp_f64mat2x3 f64mat2x3;



 typedef highp_f64mat2x4 f64mat2x4;



 typedef highp_f64mat3x2 f64mat3x2;



 typedef highp_f64mat3x3 f64mat3x3;



 typedef highp_f64mat3x4 f64mat3x4;



 typedef highp_f64mat4x2 f64mat4x2;



 typedef highp_f64mat4x3 f64mat4x3;



 typedef highp_f64mat4x4 f64mat4x4;



 typedef f64mat2x2 f64mat2;



 typedef f64mat3x3 f64mat3;



 typedef f64mat4x4 f64mat4;



 typedef highp_f64quat f64quat;

}
# 91 "../glm/gtx/../glm.hpp" 2






# 1 "../glm/gtx/../vec2.hpp" 1
# 33 "../glm/gtx/../vec2.hpp"
       

# 1 "../glm/gtx/../detail/type_vec2.hpp" 1
# 33 "../glm/gtx/../detail/type_vec2.hpp"
       
# 46 "../glm/gtx/../detail/type_vec2.hpp"
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tvec2
 {



  typedef tvec2<T, P> type;
  typedef tvec2<bool, P> bool_type;
  typedef T value_type;
# 81 "../glm/gtx/../detail/type_vec2.hpp"
   union {T x, r, s;};
   union {T y, g, t;};
# 101 "../glm/gtx/../detail/type_vec2.hpp"
   typedef length_t length_type;
   constexpr length_type length() const;

   T & operator[](length_type i);
   T const & operator[](length_type i) const;





  tvec2();
  template <precision Q>
  tvec2(tvec2<T, Q> const & v);




  explicit tvec2(ctor);
  explicit tvec2(T const & s);
  tvec2(T const & s1, T const & s2);





  template <typename A, typename B>
  tvec2(A const & x, B const & y);
  template <typename A, typename B>
  tvec2(tvec1<A, P> const & v1, tvec1<B, P> const & v2);





  template <typename U, precision Q>
  explicit tvec2(tvec3<U, Q> const & v);

  template <typename U, precision Q>
  explicit tvec2(tvec4<U, Q> const & v);







   template <typename U, precision Q>
   tvec2(tvec2<U, Q> const & v);
# 165 "../glm/gtx/../detail/type_vec2.hpp"
  template <typename U>
  tvec2<T, P> & operator=(tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator+=(U s);
  template <typename U>
  tvec2<T, P> & operator+=(tvec1<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator+=(tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator-=(U s);
  template <typename U>
  tvec2<T, P> & operator-=(tvec1<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator-=(tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator*=(U s);
  template <typename U>
  tvec2<T, P> & operator*=(tvec1<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator*=(tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator/=(U s);
  template <typename U>
  tvec2<T, P> & operator/=(tvec1<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator/=(tvec2<U, P> const & v);




  tvec2<T, P> & operator++();
  tvec2<T, P> & operator--();
  tvec2<T, P> operator++(int);
  tvec2<T, P> operator--(int);




  template <typename U>
  tvec2<T, P> & operator%= (U s);
  template <typename U>
  tvec2<T, P> & operator%= (tvec1<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator%= (tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator&= (U s);
  template <typename U>
  tvec2<T, P> & operator&= (tvec1<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator&= (tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator|= (U s);
  template <typename U>
  tvec2<T, P> & operator|= (tvec1<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator|= (tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator^= (U s);
  template <typename U>
  tvec2<T, P> & operator^= (tvec1<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator^= (tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator<<=(U s);
  template <typename U>
  tvec2<T, P> & operator<<=(tvec1<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator<<=(tvec2<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator>>=(U s);
  template <typename U>
  tvec2<T, P> & operator>>=(tvec1<U, P> const & v);
  template <typename U>
  tvec2<T, P> & operator>>=(tvec2<U, P> const & v);
 };

 template <typename T, precision P>
 tvec2<T, P> operator+(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator+(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator+(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator-(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator-(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator-(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator*(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator*(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator*(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator/(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator/(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator/(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator-(tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator%(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator%(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator%(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator&(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator&(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator&(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator|(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator|(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator|(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator^(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator^(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator^(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator<<(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator<<(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator<<(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator>>(tvec2<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator>>(T const & s, tvec2<T, P> const & v);

 template <typename T, precision P>
 tvec2<T, P> operator>>(tvec1<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec2<T, P> const & v2);

 template <typename T, precision P>
 tvec2<T, P> operator~(tvec2<T, P> const & v);
}


# 1 "../glm/gtx/../detail/type_vec2.inl" 1
# 33 "../glm/gtx/../detail/type_vec2.inl"
namespace glm
{



 template <typename T, precision P>
 inline tvec2<T, P>::tvec2()

   : x(0), y(0)

 {}

 template <typename T, precision P>
 template <precision Q>
 inline tvec2<T, P>::tvec2(tvec2<T, Q> const & v)
  : x(v.x), y(v.y)
 {}




 template <typename T, precision P>
 inline tvec2<T, P>::tvec2(ctor)
 {}

 template <typename T, precision P>
 inline tvec2<T, P>::tvec2(T const & s)
  : x(s), y(s)
 {}

 template <typename T, precision P>
 inline tvec2<T, P>::tvec2(T const & a, T const & b)
  : x(a), y(b)
 {}




 template <typename T, precision P>
 template <typename A, typename B>
 inline tvec2<T, P>::tvec2(A const & a, B const & b)
  : x(static_cast<T>(a))
  , y(static_cast<T>(b))
 {}

 template <typename T, precision P>
 template <typename A, typename B>
 inline tvec2<T, P>::tvec2(tvec1<A, P> const & a, tvec1<B, P> const & b)
  : x(static_cast<T>(a.x))
  , y(static_cast<T>(b.x))
 {}




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec2<T, P>::tvec2(tvec2<U, Q> const & v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec2<T, P>::tvec2(tvec3<U, Q> const & v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec2<T, P>::tvec2(tvec4<U, Q> const & v)
  : x(static_cast<T>(v.x))
  , y(static_cast<T>(v.y))
 {}
# 133 "../glm/gtx/../detail/type_vec2.inl"
  template <typename T, precision P>
  inline constexpr typename tvec2<T, P>::length_type tvec2<T, P>::length() const
  {
   return 2;
  }

  template <typename T, precision P>
  inline T & tvec2<T, P>::operator[](typename tvec2<T, P>::length_type i)
  {
   ((i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)) ? (void)0 : __assert2("../glm/gtx/../detail/type_vec2.inl", 142, __PRETTY_FUNCTION__, "i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)"));
   return (&x)[i];
  }

  template <typename T, precision P>
  inline T const & tvec2<T, P>::operator[](typename tvec2<T, P>::length_type i) const
  {
   ((i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)) ? (void)0 : __assert2("../glm/gtx/../detail/type_vec2.inl", 149, __PRETTY_FUNCTION__, "i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)"));
   return (&x)[i];
  }





 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator=(tvec2<U, P> const & v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator+=(U s)
 {
  this->x += static_cast<T>(s);
  this->y += static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator+=(tvec1<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator+=(tvec2<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator-=(U s)
 {
  this->x -= static_cast<T>(s);
  this->y -= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator-=(tvec1<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator-=(tvec2<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator*=(U s)
 {
  this->x *= static_cast<T>(s);
  this->y *= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator*=(tvec1<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator*=(tvec2<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator/=(U s)
 {
  this->x /= static_cast<T>(s);
  this->y /= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator/=(tvec1<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator/=(tvec2<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  return *this;
 }




 template <typename T, precision P>
 inline tvec2<T, P> & tvec2<T, P>::operator++()
 {
  ++this->x;
  ++this->y;
  return *this;
 }

 template <typename T, precision P>
 inline tvec2<T, P> & tvec2<T, P>::operator--()
 {
  --this->x;
  --this->y;
  return *this;
 }

 template <typename T, precision P>
 inline tvec2<T, P> tvec2<T, P>::operator++(int)
 {
  tvec2<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tvec2<T, P> tvec2<T, P>::operator--(int)
 {
  tvec2<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline bool operator==(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return (v1.x == v2.x) && (v1.y == v2.y);
 }

 template <typename T, precision P>
 inline bool operator!=(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return (v1.x != v2.x) || (v1.y != v2.y);
 }




 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator%=(U s)
 {
  this->x %= static_cast<T>(s);
  this->y %= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator%=(tvec1<U, P> const & v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator%=(tvec2<U, P> const & v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator&=(U s)
 {
  this->x &= static_cast<T>(s);
  this->y &= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator&=(tvec1<U, P> const & v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator&=(tvec2<U, P> const & v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator|=(U s)
 {
  this->x |= static_cast<T>(s);
  this->y |= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator|=(tvec1<U, P> const & v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator|=(tvec2<U, P> const & v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator^=(U s)
 {
  this->x ^= static_cast<T>(s);
  this->y ^= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator^=(tvec1<U, P> const & v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator^=(tvec2<U, P> const & v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator<<=(U s)
 {
  this->x <<= static_cast<T>(s);
  this->y <<= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator<<=(tvec1<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator<<=(tvec2<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator>>=(U s)
 {
  this->x >>= static_cast<T>(s);
  this->y >>= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator>>=(tvec1<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec2<T, P> & tvec2<T, P>::operator>>=(tvec2<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  return *this;
 }




 template <typename T, precision P>
 inline tvec2<T, P> operator+(tvec2<T, P> const & v, T const & s)
 {
  return tvec2<T, P>(
   v.x + s,
   v.y + s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x + v2.x,
   v1.y + v2.x);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator+(T const & s, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   s + v.x,
   s + v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator+(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x + v2.x,
   v1.x + v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator+(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x + v2.x,
   v1.y + v2.y);
 }


 template <typename T, precision P>
 inline tvec2<T, P> operator-(tvec2<T, P> const & v, T const & s)
 {
  return tvec2<T, P>(
   v.x - s,
   v.y - s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x - v2.x,
   v1.y - v2.x);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator-(T const & s, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   s - v.x,
   s - v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator-(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x - v2.x,
   v1.x - v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator-(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x - v2.x,
   v1.y - v2.y);
 }


 template <typename T, precision P>
 inline tvec2<T, P> operator*(tvec2<T, P> const & v1, T const & v2)
 {
  return tvec2<T, P>(
   v1.x * v2,
   v1.y * v2);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x * v2.x,
   v1.y * v2.x);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator*(T const & s, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   s * v.x,
   s * v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator*(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x * v2.x,
   v1.x * v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator*(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x * v2.x,
   v1.y * v2.y);
 }


 template <typename T, precision P>
 inline tvec2<T, P> operator/(tvec2<T, P> const & v, T const & s)
 {
  return tvec2<T, P>(
   v.x / s,
   v.y / s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x / v2.x,
   v1.y / v2.x);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator/(T const & s, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   s / v.x,
   s / v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator/(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x / v2.x,
   v1.x / v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator/(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x / v2.x,
   v1.y / v2.y);
 }


 template <typename T, precision P>
 inline tvec2<T, P> operator-(tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   -v.x,
   -v.y);
 }




 template <typename T, precision P>
 inline tvec2<T, P> operator%(tvec2<T, P> const & v, T const & s)
 {
  return tvec2<T, P>(
   v.x % s,
   v.y % s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x % v2.x,
   v1.y % v2.x);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator%(T const & s, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   s % v.x,
   s % v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator%(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x % v2.x,
   v1.x % v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator%(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x % v2.x,
   v1.y % v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator&(tvec2<T, P> const & v, T const & s)
 {
  return tvec2<T, P>(
   v.x & s,
   v.y & s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x & v2.x,
   v1.y & v2.x);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator&(T const & s, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   s & v.x,
   s & v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator&(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x & v2.x,
   v1.x & v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator&(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x & v2.x,
   v1.y & v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator|(tvec2<T, P> const & v, T const & s)
 {
  return tvec2<T, P>(
   v.x | s,
   v.y | s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x | v2.x,
   v1.y | v2.x);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator|(T const & s, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   s | v.x,
   s | v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator|(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x | v2.x,
   v1.x | v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator|(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x | v2.x,
   v1.y | v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator^(tvec2<T, P> const & v, T const & s)
 {
  return tvec2<T, P>(
   v.x ^ s,
   v.y ^ s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x ^ v2.x,
   v1.y ^ v2.x);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator^(T const & s, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   s ^ v.x,
   s ^ v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator^(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x ^ v2.x,
   v1.x ^ v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator^(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x ^ v2.x,
   v1.y ^ v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator<<(tvec2<T, P> const & v, T const & s)
 {
  return tvec2<T, P>(
   v.x << s,
   v.y << s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x << v2.x,
   v1.y << v2.x);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator<<(T const & s, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   s << v.x,
   s << v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator<<(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x << v2.x,
   v1.x << v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator<<(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x << v2.x,
   v1.y << v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator>>(tvec2<T, P> const & v, T const & s)
 {
  return tvec2<T, P>(
   v.x >> s,
   v.y >> s);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x >> v2.x,
   v1.y >> v2.x);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator>>(T const & s, tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   s >> v.x,
   s >> v.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator>>(tvec1<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x >> v2.x,
   v1.x >> v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator>>(tvec2<T, P> const & v1, tvec2<T, P> const & v2)
 {
  return tvec2<T, P>(
   v1.x >> v2.x,
   v1.y >> v2.y);
 }

 template <typename T, precision P>
 inline tvec2<T, P> operator~(tvec2<T, P> const & v)
 {
  return tvec2<T, P>(
   ~v.x,
   ~v.y);
 }
}
# 400 "../glm/gtx/../detail/type_vec2.hpp" 2
# 36 "../glm/gtx/../vec2.hpp" 2
# 98 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../vec3.hpp" 1
# 33 "../glm/gtx/../vec3.hpp"
       

# 1 "../glm/gtx/../detail/type_vec3.hpp" 1
# 33 "../glm/gtx/../detail/type_vec3.hpp"
       
# 46 "../glm/gtx/../detail/type_vec3.hpp"
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tvec3
 {



  typedef tvec3<T, P> type;
  typedef tvec3<bool, P> bool_type;
  typedef T value_type;
# 81 "../glm/gtx/../detail/type_vec3.hpp"
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
# 102 "../glm/gtx/../detail/type_vec3.hpp"
   typedef length_t length_type;
   constexpr length_type length() const;

   T & operator[](length_type i);
   T const & operator[](length_type i) const;





  tvec3();
  template <precision Q>
  tvec3(tvec3<T, Q> const & v);




  explicit tvec3(ctor);
  explicit tvec3(T const & s);
  tvec3(T const & a, T const & b, T const & c);





  template <typename A, typename B, typename C>
  tvec3(A const & a, B const & b, C const & c);
  template <typename A, typename B, typename C>
  tvec3(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c);





  template <typename A, typename B, precision Q>
  explicit tvec3(tvec2<A, Q> const & a, B const & b);

  template <typename A, typename B, precision Q>
  explicit tvec3(tvec2<A, Q> const & a, tvec1<B, Q> const & b);

  template <typename A, typename B, precision Q>
  explicit tvec3(A const & a, tvec2<B, Q> const & b);

  template <typename A, typename B, precision Q>
  explicit tvec3(tvec1<A, Q> const & a, tvec2<B, Q> const & b);

  template <typename U, precision Q>
  explicit tvec3(tvec4<U, Q> const & v);







   template <typename U, precision Q>
   tvec3(tvec3<U, Q> const & v);
# 187 "../glm/gtx/../detail/type_vec3.hpp"
  template <typename U>
  tvec3<T, P> & operator=(tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator+=(U s);
  template <typename U>
  tvec3<T, P> & operator+=(tvec1<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator+=(tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator-=(U s);
  template <typename U>
  tvec3<T, P> & operator-=(tvec1<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator-=(tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator*=(U s);
  template <typename U>
  tvec3<T, P> & operator*=(tvec1<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator*=(tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator/=(U s);
  template <typename U>
  tvec3<T, P> & operator/=(tvec1<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator/=(tvec3<U, P> const & v);




  tvec3<T, P> & operator++();
  tvec3<T, P> & operator--();
  tvec3<T, P> operator++(int);
  tvec3<T, P> operator--(int);




  template <typename U>
  tvec3<T, P> & operator%=(U s);
  template <typename U>
  tvec3<T, P> & operator%=(tvec1<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator%=(tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator&=(U s);
  template <typename U>
  tvec3<T, P> & operator&=(tvec1<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator&=(tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator|=(U s);
  template <typename U>
  tvec3<T, P> & operator|=(tvec1<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator|=(tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator^=(U s);
  template <typename U>
  tvec3<T, P> & operator^=(tvec1<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator^=(tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator<<=(U s);
  template <typename U>
  tvec3<T, P> & operator<<=(tvec1<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator<<=(tvec3<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator>>=(U s);
  template <typename U>
  tvec3<T, P> & operator>>=(tvec1<U, P> const & v);
  template <typename U>
  tvec3<T, P> & operator>>=(tvec3<U, P> const & v);
 };

 template <typename T, precision P>
 tvec3<T, P> operator+(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator+(tvec3<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec3<T, P> operator+(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator+(tvec1<T, P> const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator-(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator-(tvec3<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec3<T, P> operator-(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator-(tvec1<T, P> const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator*(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator*(tvec3<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec3<T, P> operator*(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator*(tvec1<T, P> const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator/(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator/(tvec3<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec3<T, P> operator/(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator/(tvec1<T, P> const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator-(tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator%(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator%(tvec3<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec3<T, P> operator%(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator%(tvec1<T, P> const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator&(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator&(tvec3<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec3<T, P> operator&(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator&(tvec1<T, P> const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator|(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator|(tvec3<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec3<T, P> operator|(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator|(tvec1<T, P> const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator^(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator^(tvec3<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec3<T, P> operator^(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator^(tvec1<T, P> const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator<<(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator<<(tvec3<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec3<T, P> operator<<(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator<<(tvec1<T, P> const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator>>(tvec3<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec3<T, P> operator>>(tvec3<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec3<T, P> operator>>(T const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator>>(tvec1<T, P> const & s, tvec3<T, P> const & v);

 template <typename T, precision P>
 tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2);

 template <typename T, precision P>
 tvec3<T, P> operator~(tvec3<T, P> const & v);
}


# 1 "../glm/gtx/../detail/type_vec3.inl" 1
# 33 "../glm/gtx/../detail/type_vec3.inl"
namespace glm
{



 template <typename T, precision P>
 inline tvec3<T, P>::tvec3()

   : x(0), y(0), z(0)

 {}

 template <typename T, precision P>
 template <precision Q>
 inline tvec3<T, P>::tvec3(tvec3<T, Q> const & v)
  : x(v.x), y(v.y), z(v.z)
 {}




 template <typename T, precision P>
 inline tvec3<T, P>::tvec3(ctor)
 {}

 template <typename T, precision P>
 inline tvec3<T, P>::tvec3(T const & s)
  : x(s), y(s), z(s)
 {}

 template <typename T, precision P>
 inline tvec3<T, P>::tvec3(T const & a, T const & b, T const & c)
  : x(a), y(b), z(c)
 {}




 template <typename T, precision P>
 template <typename A, typename B, typename C>
 inline tvec3<T, P>::tvec3(A const & a, B const & b, C const & c) :
  x(static_cast<T>(a)),
  y(static_cast<T>(b)),
  z(static_cast<T>(c))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C>
 inline tvec3<T, P>::tvec3(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c) :
  x(static_cast<T>(a)),
  y(static_cast<T>(b)),
  z(static_cast<T>(c))
 {}




 template <typename T, precision P>
 template <typename A, typename B, precision Q>
 inline tvec3<T, P>::tvec3(tvec2<A, Q> const & a, B const & b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(b))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q>
 inline tvec3<T, P>::tvec3(tvec2<A, Q> const & a, tvec1<B, Q> const & b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(b.x))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q>
 inline tvec3<T, P>::tvec3(A const & a, tvec2<B, Q> const & b) :
  x(static_cast<T>(a)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(b.y))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q>
 inline tvec3<T, P>::tvec3(tvec1<A, Q> const & a, tvec2<B, Q> const & b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(b.y))
 {}

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec3<T, P>::tvec3(tvec3<U, Q> const & v) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y)),
  z(static_cast<T>(v.z))
 {}

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec3<T, P>::tvec3(tvec4<U, Q> const & v) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y)),
  z(static_cast<T>(v.z))
 {}
# 162 "../glm/gtx/../detail/type_vec3.inl"
  template <typename T, precision P>
  inline constexpr typename tvec3<T, P>::length_type tvec3<T, P>::length() const
  {
   return 3;
  }

  template <typename T, precision P>
  inline T & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i)
  {
   ((i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)) ? (void)0 : __assert2("../glm/gtx/../detail/type_vec3.inl", 171, __PRETTY_FUNCTION__, "i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)"));
   return (&x)[i];
  }

  template <typename T, precision P>
  inline T const & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i) const
  {
   ((i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)) ? (void)0 : __assert2("../glm/gtx/../detail/type_vec3.inl", 178, __PRETTY_FUNCTION__, "i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)"));
   return (&x)[i];
  }





 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P>& tvec3<T, P>::operator=(tvec3<U, P> const & v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator+=(U s)
 {
  this->x += static_cast<T>(s);
  this->y += static_cast<T>(s);
  this->z += static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator+=(tvec1<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.x);
  this->z += static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator+=(tvec3<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  this->z += static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator-=(U s)
 {
  this->x -= static_cast<T>(s);
  this->y -= static_cast<T>(s);
  this->z -= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator-=(tvec1<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.x);
  this->z -= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator-=(tvec3<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  this->z -= static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator*=(U s)
 {
  this->x *= static_cast<T>(s);
  this->y *= static_cast<T>(s);
  this->z *= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator*=(tvec1<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  this->z *= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator*=(tvec3<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  this->z *= static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator/=(U s)
 {
  this->x /= static_cast<T>(s);
  this->y /= static_cast<T>(s);
  this->z /= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator/=(tvec1<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  this->z /= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator/=(tvec3<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  this->z /= static_cast<T>(v.z);
  return *this;
 }




 template <typename T, precision P>
 inline tvec3<T, P> & tvec3<T, P>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  return *this;
 }

 template <typename T, precision P>
 inline tvec3<T, P> & tvec3<T, P>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  return *this;
 }

 template <typename T, precision P>
 inline tvec3<T, P> tvec3<T, P>::operator++(int)
 {
  tvec3<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tvec3<T, P> tvec3<T, P>::operator--(int)
 {
  tvec3<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator%=(U s)
 {
  this->x %= s;
  this->y %= s;
  this->z %= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator%=(tvec1<U, P> const & v)
 {
  this->x %= v.x;
  this->y %= v.x;
  this->z %= v.x;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator%=(tvec3<U, P> const & v)
 {
  this->x %= v.x;
  this->y %= v.y;
  this->z %= v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator&=(U s)
 {
  this->x &= s;
  this->y &= s;
  this->z &= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator&=(tvec1<U, P> const & v)
 {
  this->x &= v.x;
  this->y &= v.x;
  this->z &= v.x;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator&=(tvec3<U, P> const & v)
 {
  this->x &= v.x;
  this->y &= v.y;
  this->z &= v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator|=(U s)
 {
  this->x |= s;
  this->y |= s;
  this->z |= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator|=(tvec1<U, P> const & v)
 {
  this->x |= v.x;
  this->y |= v.x;
  this->z |= v.x;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator|=(tvec3<U, P> const & v)
 {
  this->x |= v.x;
  this->y |= v.y;
  this->z |= v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator^=(U s)
 {
  this->x ^= s;
  this->y ^= s;
  this->z ^= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator^=(tvec1<U, P> const & v)
 {
  this->x ^= v.x;
  this->y ^= v.x;
  this->z ^= v.x;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator^=(tvec3<U, P> const & v)
 {
  this->x ^= v.x;
  this->y ^= v.y;
  this->z ^= v.z;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator<<=(U s)
 {
  this->x <<= s;
  this->y <<= s;
  this->z <<= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator<<=(tvec1<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  this->z <<= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator<<=(tvec3<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  this->z <<= static_cast<T>(v.z);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator>>=(U s)
 {
  this->x >>= static_cast<T>(s);
  this->y >>= static_cast<T>(s);
  this->z >>= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator>>=(tvec1<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.x);
  this->z >>= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec3<T, P> & tvec3<T, P>::operator>>=(tvec3<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  this->z >>= static_cast<T>(v.z);
  return *this;
 }




 template <typename T, precision P>
 inline bool operator==(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z);
 }

 template <typename T, precision P>
 inline bool operator!=(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z);
 }




 template <typename T, precision P>
 inline tvec3<T, P> operator+(tvec3<T, P> const & v, T const & s)
 {
  return tvec3<T, P>(
   v.x + s,
   v.y + s,
   v.z + s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator+(tvec3<T, P> const & v, tvec1<T, P> const & s)
 {
  return tvec3<T, P>(
   v.x + s.x,
   v.y + s.x,
   v.z + s.x);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator+(T const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s + v.x,
   s + v.y,
   s + v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator+(tvec1<T, P> const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s.x + v.x,
   s.x + v.y,
   s.x + v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x + v2.x,
   v1.y + v2.y,
   v1.z + v2.z);
 }


 template <typename T, precision P>
 inline tvec3<T, P> operator-(tvec3<T, P> const & v, T const & s)
 {
  return tvec3<T, P>(
   v.x - s,
   v.y - s,
   v.z - s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator-(tvec3<T, P> const & v, tvec1<T, P> const & s)
 {
  return tvec3<T, P>(
   v.x - s.x,
   v.y - s.x,
   v.z - s.x);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator-(T const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s - v.x,
   s - v.y,
   s - v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator-(tvec1<T, P> const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s.x - v.x,
   s.x - v.y,
   s.x - v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x - v2.x,
   v1.y - v2.y,
   v1.z - v2.z);
 }


 template <typename T, precision P>
 inline tvec3<T, P> operator*(tvec3<T, P> const & v, T const & s)
 {
  return tvec3<T, P>(
   v.x * s,
   v.y * s,
   v.z * s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator*(tvec3<T, P> const & v, tvec1<T, P> const & s)
 {
  return tvec3<T, P>(
   v.x * s.x,
   v.y * s.x,
   v.z * s.x);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator*(T const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s * v.x,
   s * v.y,
   s * v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator*(tvec1<T, P> const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s.x * v.x,
   s.x * v.y,
   s.x * v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x * v2.x,
   v1.y * v2.y,
   v1.z * v2.z);
 }


 template <typename T, precision P>
 inline tvec3<T, P> operator/(tvec3<T, P> const & v, T const & s)
 {
  return tvec3<T, P>(
   v.x / s,
   v.y / s,
   v.z / s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator/(tvec3<T, P> const & v, tvec1<T, P> const & s)
 {
  return tvec3<T, P>(
   v.x / s.x,
   v.y / s.x,
   v.z / s.x);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator/(T const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s / v.x,
   s / v.y,
   s / v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator/(tvec1<T, P> const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s.x / v.x,
   s.x / v.y,
   s.x / v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x / v2.x,
   v1.y / v2.y,
   v1.z / v2.z);
 }


 template <typename T, precision P>
 inline tvec3<T, P> operator-(tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   -v.x,
   -v.y,
   -v.z);
 }




 template <typename T, precision P>
 inline tvec3<T, P> operator%(tvec3<T, P> const & v, T const & s)
 {
  return tvec3<T, P>(
   v.x % s,
   v.y % s,
   v.z % s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator%(tvec3<T, P> const & v, tvec1<T, P> const & s)
 {
  return tvec3<T, P>(
   v.x % s.x,
   v.y % s.x,
   v.z % s.x);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator%(T const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s % v.x,
   s % v.y,
   s % v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator%(tvec1<T, P> const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s.x % v.x,
   s.x % v.y,
   s.x % v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x % v2.x,
   v1.y % v2.y,
   v1.z % v2.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator&(tvec3<T, P> const & v, T const & s)
 {
  return tvec3<T, P>(
   v.x & s,
   v.y & s,
   v.z & s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator&(tvec3<T, P> const & v, tvec1<T, P> const & s)
 {
  return tvec3<T, P>(
   v.x & s.x,
   v.y & s.x,
   v.z & s.x);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator&(T const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s & v.x,
   s & v.y,
   s & v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator&(tvec1<T, P> const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s.x & v.x,
   s.x & v.y,
   s.x & v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x & v2.x,
   v1.y & v2.y,
   v1.z & v2.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator|(tvec3<T, P> const & v, T const & s)
 {
  return tvec3<T, P>(
   v.x | s,
   v.y | s,
   v.z | s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator|(tvec3<T, P> const & v, tvec1<T, P> const & s)
 {
  return tvec3<T, P>(
   v.x | s.x,
   v.y | s.x,
   v.z | s.x);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator|(T const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s | v.x,
   s | v.y,
   s | v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator|(tvec1<T, P> const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s.x | v.x,
   s.x | v.y,
   s.x | v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x | v2.x,
   v1.y | v2.y,
   v1.z | v2.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator^(tvec3<T, P> const & v, T const & s)
 {
  return tvec3<T, P>(
   v.x ^ s,
   v.y ^ s,
   v.z ^ s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator^(tvec3<T, P> const & v, tvec1<T, P> const & s)
 {
  return tvec3<T, P>(
   v.x ^ s.x,
   v.y ^ s.x,
   v.z ^ s.x);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator^(T const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s ^ v.x,
   s ^ v.y,
   s ^ v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator^(tvec1<T, P> const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s.x ^ v.x,
   s.x ^ v.y,
   s.x ^ v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x ^ v2.x,
   v1.y ^ v2.y,
   v1.z ^ v2.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator<<(tvec3<T, P> const & v, T const & s)
 {
  return tvec3<T, P>(
   v.x << s,
   v.y << s,
   v.z << s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator<<(tvec3<T, P> const & v, tvec1<T, P> const & s)
 {
  return tvec3<T, P>(
   v.x << s.x,
   v.y << s.x,
   v.z << s.x);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator<<(T const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s << v.x,
   s << v.y,
   s << v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator<<(tvec1<T, P> const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s.x << v.x,
   s.x << v.y,
   s.x << v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x << v2.x,
   v1.y << v2.y,
   v1.z << v2.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator>>(tvec3<T, P> const & v, T const & s)
 {
  return tvec3<T, P>(
   v.x >> s,
   v.y >> s,
   v.z >> s);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator>>(tvec3<T, P> const & v, tvec1<T, P> const & s)
 {
  return tvec3<T, P>(
   v.x >> s.x,
   v.y >> s.x,
   v.z >> s.x);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator>>(T const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s >> v.x,
   s >> v.y,
   s >> v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator>>(tvec1<T, P> const & s, tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   s.x >> v.x,
   s.x >> v.y,
   s.x >> v.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2)
 {
  return tvec3<T, P>(
   v1.x >> v2.x,
   v1.y >> v2.y,
   v1.z >> v2.z);
 }

 template <typename T, precision P>
 inline tvec3<T, P> operator~(tvec3<T, P> const & v)
 {
  return tvec3<T, P>(
   ~v.x,
   ~v.y,
   ~v.z);
 }
}
# 422 "../glm/gtx/../detail/type_vec3.hpp" 2
# 36 "../glm/gtx/../vec3.hpp" 2
# 99 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../vec4.hpp" 1
# 33 "../glm/gtx/../vec4.hpp"
       

# 1 "../glm/gtx/../detail/type_vec4.hpp" 1
# 33 "../glm/gtx/../detail/type_vec4.hpp"
       
# 47 "../glm/gtx/../detail/type_vec4.hpp"
namespace glm{
namespace detail
{
 template <typename T>
 struct simd
 {
  typedef T type[4];
 };
# 100 "../glm/gtx/../detail/type_vec4.hpp"
}

 template <typename T, precision P = defaultp>
 struct tvec4
 {



  typedef tvec4<T, P> type;
  typedef tvec4<bool, P> bool_type;
  typedef T value_type;
# 136 "../glm/gtx/../detail/type_vec4.hpp"
   union { T x, r, s; };
   union { T y, g, t; };
   union { T z, b, p; };
   union { T w, a, q; };
# 158 "../glm/gtx/../detail/type_vec4.hpp"
   typedef length_t length_type;
   constexpr length_type length() const;

   T & operator[](length_type i);
   T const & operator[](length_type i) const;





  tvec4();
  template <precision Q>
  tvec4(tvec4<T, Q> const & v);




  explicit tvec4(ctor);
  explicit tvec4(T s);
  tvec4(T a, T b, T c, T d);
  ~tvec4(){}





  template <typename A, typename B, typename C, typename D>
  tvec4(A a, B b, C c, D d);
  template <typename A, typename B, typename C, typename D>
  tvec4(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c, tvec1<D, P> const & d);





  template <typename A, typename B, typename C, precision Q>
  explicit tvec4(tvec2<A, Q> const & a, B b, C c);

  template <typename A, typename B, typename C, precision Q>
  explicit tvec4(tvec2<A, Q> const & a, tvec1<B, Q> const & b, tvec1<C, Q> const & c);

  template <typename A, typename B, typename C, precision Q>
  explicit tvec4(A a, tvec2<B, Q> const & b, C c);

  template <typename A, typename B, typename C, precision Q>
  explicit tvec4(tvec1<A, Q> const & a, tvec2<B, Q> const & b, tvec1<C, Q> const & c);

  template <typename A, typename B, typename C, precision Q>
  explicit tvec4(A a, B b, tvec2<C, Q> const & c);

  template <typename A, typename B, typename C, precision Q>
  explicit tvec4(tvec1<A, Q> const & a, tvec1<B, Q> const & b, tvec2<C, Q> const & c);

  template <typename A, typename B, precision Q>
  explicit tvec4(tvec3<A, Q> const & a, B b);

  template <typename A, typename B, precision Q>
  explicit tvec4(tvec3<A, Q> const & a, tvec1<B, Q> const & b);

  template <typename A, typename B, precision Q>
  explicit tvec4(A a, tvec3<B, Q> const & b);

  template <typename A, typename B, precision Q>
  explicit tvec4(tvec1<A, Q> const & a, tvec3<B, Q> const & b);

  template <typename A, typename B, precision Q>
  explicit tvec4(tvec2<A, Q> const & a, tvec2<B, Q> const & b);







   template <typename U, precision Q>
   tvec4(tvec4<U, Q> const & v);
# 286 "../glm/gtx/../detail/type_vec4.hpp"
  template <typename U>
  tvec4<T, P> & operator=(tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator+=(U scalar);
  template <typename U>
  tvec4<T, P> & operator+=(tvec1<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator+=(tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator-=(U scalar);
  template <typename U>
  tvec4<T, P> & operator-=(tvec1<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator-=(tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator*=(U scalar);
  template <typename U>
  tvec4<T, P> & operator*=(tvec1<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator*=(tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator/=(U scalar);
  template <typename U>
  tvec4<T, P> & operator/=(tvec1<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator/=(tvec4<U, P> const & v);




  tvec4<T, P> & operator++();
  tvec4<T, P> & operator--();
  tvec4<T, P> operator++(int);
  tvec4<T, P> operator--(int);




  template <typename U>
  tvec4<T, P> & operator%=(U scalar);
  template <typename U>
  tvec4<T, P> & operator%=(tvec1<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator%=(tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator&=(U scalar);
  template <typename U>
  tvec4<T, P> & operator&=(tvec1<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator&=(tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator|=(U scalar);
  template <typename U>
  tvec4<T, P> & operator|=(tvec1<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator|=(tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator^=(U scalar);
  template <typename U>
  tvec4<T, P> & operator^=(tvec1<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator^=(tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator<<=(U scalar);
  template <typename U>
  tvec4<T, P> & operator<<=(tvec1<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator<<=(tvec4<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator>>=(U scalar);
  template <typename U>
  tvec4<T, P> & operator>>=(tvec1<U, P> const & v);
  template <typename U>
  tvec4<T, P> & operator>>=(tvec4<U, P> const & v);
 };

 template <typename T, precision P>
 tvec4<T, P> operator+(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
 tvec4<T, P> operator+(tvec4<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec4<T, P> operator+(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator+(tvec1<T, P> const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator-(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
 tvec4<T, P> operator-(tvec4<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec4<T, P> operator-(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator-(tvec1<T, P> const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator*(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
 tvec4<T, P> operator*(tvec4<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec4<T, P> operator*(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator*(tvec1<T, P> const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator/(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
 tvec4<T, P> operator/(tvec4<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec4<T, P> operator/(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator/(tvec1<T, P> const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator-(tvec4<T, P> const & v);

 template <typename T, precision P>
 bool operator==(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 bool operator!=(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator%(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
 tvec4<T, P> operator%(tvec4<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec4<T, P> operator%(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator%(tvec1<T, P> const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator&(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
 tvec4<T, P> operator&(tvec4<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec4<T, P> operator&(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator&(tvec1<T, P> const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator&(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator|(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
 tvec4<T, P> operator|(tvec4<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec4<T, P> operator|(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator|(tvec1<T, P> const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator^(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
 tvec4<T, P> operator^(tvec4<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec4<T, P> operator^(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator^(tvec1<T, P> const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator<<(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
 tvec4<T, P> operator<<(tvec4<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec4<T, P> operator<<(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator<<(tvec1<T, P> const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator>>(tvec4<T, P> const & v, T scalar);

 template <typename T, precision P>
 tvec4<T, P> operator>>(tvec4<T, P> const & v, tvec1<T, P> const & s);

 template <typename T, precision P>
 tvec4<T, P> operator>>(T scalar, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator>>(tvec1<T, P> const & s, tvec4<T, P> const & v);

 template <typename T, precision P>
 tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec4<T, P> const & v2);

 template <typename T, precision P>
 tvec4<T, P> operator~(tvec4<T, P> const & v);
}


# 1 "../glm/gtx/../detail/type_vec4.inl" 1
# 33 "../glm/gtx/../detail/type_vec4.inl"
namespace glm
{



 template <typename T, precision P>
 inline tvec4<T, P>::tvec4()

   : x(0), y(0), z(0), w(0)

 {}

 template <typename T, precision P>
 template <precision Q>
 inline tvec4<T, P>::tvec4(tvec4<T, Q> const & v)
  : x(v.x), y(v.y), z(v.z), w(v.w)
 {}




 template <typename T, precision P>
 inline tvec4<T, P>::tvec4(ctor)
 {}

 template <typename T, precision P>
 inline tvec4<T, P>::tvec4(T s)
  : x(s), y(s), z(s), w(s)
 {}

 template <typename T, precision P>
 inline tvec4<T, P>::tvec4(T a, T b, T c, T d)
  : x(a), y(b), z(c), w(d)
 {}




 template <typename T, precision P>
 template <typename A, typename B, typename C, typename D>
 inline tvec4<T, P>::tvec4(A a, B b, C c, D d) :
  x(static_cast<T>(a)),
  y(static_cast<T>(b)),
  z(static_cast<T>(c)),
  w(static_cast<T>(d))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, typename D>
 inline tvec4<T, P>::tvec4(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c, tvec1<D, P> const & d) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(c.x)),
  w(static_cast<T>(d.x))
 {}




 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q>
 inline tvec4<T, P>::tvec4(tvec2<A, Q> const & a, B b, C c) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(b)),
  w(static_cast<T>(c))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q>
 inline tvec4<T, P>::tvec4(tvec2<A, Q> const & a, tvec1<B, Q> const & b, tvec1<C, Q> const & c) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(b.x)),
  w(static_cast<T>(c.x))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q>
 inline tvec4<T, P>::tvec4(A s1, tvec2<B, Q> const & v, C s2) :
  x(static_cast<T>(s1)),
  y(static_cast<T>(v.x)),
  z(static_cast<T>(v.y)),
  w(static_cast<T>(s2))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q>
 inline tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec2<B, Q> const & b, tvec1<C, Q> const & c) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(b.y)),
  w(static_cast<T>(c.x))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q>
 inline tvec4<T, P>::tvec4(A s1, B s2, tvec2<C, Q> const & v) :
  x(static_cast<T>(s1)),
  y(static_cast<T>(s2)),
  z(static_cast<T>(v.x)),
  w(static_cast<T>(v.y))
 {}

 template <typename T, precision P>
 template <typename A, typename B, typename C, precision Q>
 inline tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec1<B, Q> const & b, tvec2<C, Q> const & c) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(c.x)),
  w(static_cast<T>(c.y))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q>
 inline tvec4<T, P>::tvec4(tvec3<A, Q> const & a, B b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(a.z)),
  w(static_cast<T>(b))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q>
 inline tvec4<T, P>::tvec4(tvec3<A, Q> const & a, tvec1<B, Q> const & b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(a.z)),
  w(static_cast<T>(b.x))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q>
 inline tvec4<T, P>::tvec4(A a, tvec3<B, Q> const & b) :
  x(static_cast<T>(a)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(b.y)),
  w(static_cast<T>(b.z))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q>
 inline tvec4<T, P>::tvec4(tvec1<A, Q> const & a, tvec3<B, Q> const & b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(b.x)),
  z(static_cast<T>(b.y)),
  w(static_cast<T>(b.z))
 {}

 template <typename T, precision P>
 template <typename A, typename B, precision Q>
 inline tvec4<T, P>::tvec4(tvec2<A, Q> const & a, tvec2<B, Q> const & b) :
  x(static_cast<T>(a.x)),
  y(static_cast<T>(a.y)),
  z(static_cast<T>(b.x)),
  w(static_cast<T>(b.y))
 {}

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec4<T, P>::tvec4(tvec4<U, Q> const & v) :
  x(static_cast<T>(v.x)),
  y(static_cast<T>(v.y)),
  z(static_cast<T>(v.z)),
  w(static_cast<T>(v.w))
 {}
# 224 "../glm/gtx/../detail/type_vec4.inl"
  template <typename T, precision P>
  inline constexpr typename tvec4<T, P>::length_type tvec4<T, P>::length() const
  {
   return 4;
  }

  template <typename T, precision P>
  inline T & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i)
  {
   ((i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)) ? (void)0 : __assert2("../glm/gtx/../detail/type_vec4.inl", 233, __PRETTY_FUNCTION__, "i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)"));
   return (&x)[i];
  }

  template <typename T, precision P>
  inline T const & tvec4<T, P>::operator[](typename tvec4<T, P>::length_type i) const
  {
   ((i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)) ? (void)0 : __assert2("../glm/gtx/../detail/type_vec4.inl", 240, __PRETTY_FUNCTION__, "i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)"));
   return (&x)[i];
  }





 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator=(tvec4<U, P> const & v)
 {
  this->x = static_cast<T>(v.x);
  this->y = static_cast<T>(v.y);
  this->z = static_cast<T>(v.z);
  this->w = static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator+=(U scalar)
 {
  this->x += static_cast<T>(scalar);
  this->y += static_cast<T>(scalar);
  this->z += static_cast<T>(scalar);
  this->w += static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator+=(tvec1<U, P> const & v)
 {
  T const scalar = static_cast<T>(v.x);
  this->x += scalar;
  this->y += scalar;
  this->z += scalar;
  this->w += scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator+=(tvec4<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  this->y += static_cast<T>(v.y);
  this->z += static_cast<T>(v.z);
  this->w += static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator-=(U scalar)
 {
  this->x -= static_cast<T>(scalar);
  this->y -= static_cast<T>(scalar);
  this->z -= static_cast<T>(scalar);
  this->w -= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator-=(tvec1<U, P> const & v)
 {
  T const scalar = static_cast<T>(v.x);
  this->x -= scalar;
  this->y -= scalar;
  this->z -= scalar;
  this->w -= scalar;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator-=(tvec4<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  this->y -= static_cast<T>(v.y);
  this->z -= static_cast<T>(v.z);
  this->w -= static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator*=(U s)
 {
  this->x *= static_cast<T>(s);
  this->y *= static_cast<T>(s);
  this->z *= static_cast<T>(s);
  this->w *= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator*=(tvec1<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.x);
  this->z *= static_cast<T>(v.x);
  this->w *= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator*=(tvec4<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  this->y *= static_cast<T>(v.y);
  this->z *= static_cast<T>(v.z);
  this->w *= static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator/=(U s)
 {
  this->x /= static_cast<T>(s);
  this->y /= static_cast<T>(s);
  this->z /= static_cast<T>(s);
  this->w /= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator/=(tvec1<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.x);
  this->z /= static_cast<T>(v.x);
  this->w /= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator/=(tvec4<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  this->y /= static_cast<T>(v.y);
  this->z /= static_cast<T>(v.z);
  this->w /= static_cast<T>(v.w);
  return *this;
 }




 template <typename T, precision P>
 inline tvec4<T, P> & tvec4<T, P>::operator++()
 {
  ++this->x;
  ++this->y;
  ++this->z;
  ++this->w;
  return *this;
 }

 template <typename T, precision P>
 inline tvec4<T, P> & tvec4<T, P>::operator--()
 {
  --this->x;
  --this->y;
  --this->z;
  --this->w;
  return *this;
 }

 template <typename T, precision P>
 inline tvec4<T, P> tvec4<T, P>::operator++(int)
 {
  tvec4<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tvec4<T, P> tvec4<T, P>::operator--(int)
 {
  tvec4<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator%=(U scalar)
 {
  this->x %= static_cast<T>(scalar);
  this->y %= static_cast<T>(scalar);
  this->z %= static_cast<T>(scalar);
  this->w %= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator%=(tvec1<U, P> const & v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.x);
  this->z %= static_cast<T>(v.x);
  this->w %= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator%=(tvec4<U, P> const & v)
 {
  this->x %= static_cast<T>(v.x);
  this->y %= static_cast<T>(v.y);
  this->z %= static_cast<T>(v.z);
  this->w %= static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator&=(U scalar)
 {
  this->x &= static_cast<T>(scalar);
  this->y &= static_cast<T>(scalar);
  this->z &= static_cast<T>(scalar);
  this->w &= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator&=(tvec1<U, P> const & v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.x);
  this->z &= static_cast<T>(v.x);
  this->w &= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator&=(tvec4<U, P> const & v)
 {
  this->x &= static_cast<T>(v.x);
  this->y &= static_cast<T>(v.y);
  this->z &= static_cast<T>(v.z);
  this->w &= static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator|=(U scalar)
 {
  this->x |= static_cast<T>(scalar);
  this->y |= static_cast<T>(scalar);
  this->z |= static_cast<T>(scalar);
  this->w |= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator|=(tvec1<U, P> const & v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.x);
  this->z |= static_cast<T>(v.x);
  this->w |= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator|=(tvec4<U, P> const & v)
 {
  this->x |= static_cast<T>(v.x);
  this->y |= static_cast<T>(v.y);
  this->z |= static_cast<T>(v.z);
  this->w |= static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator^=(U scalar)
 {
  this->x ^= static_cast<T>(scalar);
  this->y ^= static_cast<T>(scalar);
  this->z ^= static_cast<T>(scalar);
  this->w ^= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator^=(tvec1<U, P> const & v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.x);
  this->z ^= static_cast<T>(v.x);
  this->w ^= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator^=(tvec4<U, P> const & v)
 {
  this->x ^= static_cast<T>(v.x);
  this->y ^= static_cast<T>(v.y);
  this->z ^= static_cast<T>(v.z);
  this->w ^= static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator<<=(U scalar)
 {
  this->x <<= static_cast<T>(scalar);
  this->y <<= static_cast<T>(scalar);
  this->z <<= static_cast<T>(scalar);
  this->w <<= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator<<=(tvec1<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.x);
  this->z <<= static_cast<T>(v.x);
  this->w <<= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator<<=(tvec4<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  this->y <<= static_cast<T>(v.y);
  this->z <<= static_cast<T>(v.z);
  this->w <<= static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator>>=(U scalar)
 {
  this->x >>= static_cast<T>(scalar);
  this->y >>= static_cast<T>(scalar);
  this->z >>= static_cast<T>(scalar);
  this->w >>= static_cast<T>(scalar);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator>>=(tvec1<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  this->z >>= static_cast<T>(v.z);
  this->w >>= static_cast<T>(v.w);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec4<T, P> & tvec4<T, P>::operator>>=(tvec4<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  this->y >>= static_cast<T>(v.y);
  this->z >>= static_cast<T>(v.z);
  this->w >>= static_cast<T>(v.w);
  return *this;
 }




 template <typename T, precision P>
 inline bool operator==(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z) && (v1.w == v2.w);
 }

 template <typename T, precision P>
 inline bool operator!=(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z) || (v1.w != v2.w);
 }




 template <typename T, precision P>
 inline tvec4<T, P> operator+(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(
   v.x + scalar,
   v.y + scalar,
   v.z + scalar,
   v.w + scalar);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator+(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   scalar + v.x,
   scalar + v.y,
   scalar + v.z,
   scalar + v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator+(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(
   v1.x + v2.x,
   v1.y + v2.y,
   v1.z + v2.z,
   v1.w + v2.w);
 }


 template <typename T, precision P>
 inline tvec4<T, P> operator-(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(
   v.x - scalar,
   v.y - scalar,
   v.z - scalar,
   v.w - scalar);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator-(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   scalar - v.x,
   scalar - v.y,
   scalar - v.z,
   scalar - v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator-(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(
   v1.x - v2.x,
   v1.y - v2.y,
   v1.z - v2.z,
   v1.w - v2.w);
 }


 template <typename T, precision P>
 inline tvec4<T, P> operator*(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(
   v.x * scalar,
   v.y * scalar,
   v.z * scalar,
   v.w * scalar);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator*(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   scalar * v.x,
   scalar * v.y,
   scalar * v.z,
   scalar * v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator*(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(
   v1.x * v2.x,
   v1.y * v2.y,
   v1.z * v2.z,
   v1.w * v2.w);
 }


 template <typename T, precision P>
 inline tvec4<T, P> operator/(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(
   v.x / scalar,
   v.y / scalar,
   v.z / scalar,
   v.w / scalar);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator/(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   scalar / v.x,
   scalar / v.y,
   scalar / v.z,
   scalar / v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator/(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(
   v1.x / v2.x,
   v1.y / v2.y,
   v1.z / v2.z,
   v1.w / v2.w);
 }


 template <typename T, precision P>
 inline tvec4<T, P> operator-(tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   -v.x,
   -v.y,
   -v.z,
   -v.w);
 }




 template <typename T, precision P>
 inline tvec4<T, P> operator%(tvec4<T, P> const & v, T s)
 {
  return tvec4<T, P>(
   v.x % s,
   v.y % s,
   v.z % s,
   v.w % s);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator%(tvec4<T, P> const & v, tvec1<T, P> const & s)
 {
  return tvec4<T, P>(
   v.x % s.x,
   v.y % s.x,
   v.z % s.x,
   v.w % s.x);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator%(T s, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   s % v.x,
   s % v.y,
   s % v.z,
   s % v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator%(tvec1<T, P> const & s, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   s.x % v.x,
   s.x % v.y,
   s.x % v.z,
   s.x % v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator%(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(
   v1.x % v2.x,
   v1.y % v2.y,
   v1.z % v2.z,
   v1.w % v2.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator&(tvec4<T, P> const & v, T s)
 {
  return tvec4<T, P>(
   v.x & s,
   v.y & s,
   v.z & s,
   v.w & s);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator&(tvec4<T, P> const & v, tvec1<T, P> const & s)
 {
  return tvec4<T, P>(
   v.x & s.x,
   v.y & s.x,
   v.z & s.x,
   v.w & s.x);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator&(T s, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   s & v.x,
   s & v.y,
   s & v.z,
   s & v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator&(tvec1<T, P> const & s, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   s.x & v.x,
   s.x & v.y,
   s.x & v.z,
   s.x & v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator&(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(
   v1.x & v2.x,
   v1.y & v2.y,
   v1.z & v2.z,
   v1.w & v2.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator|(tvec4<T, P> const & v, T s)
 {
  return tvec4<T, P>(
   v.x | s,
   v.y | s,
   v.z | s,
   v.w | s);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator|(tvec4<T, P> const & v, tvec1<T, P> const & s)
 {
  return tvec4<T, P>(
   v.x | s.x,
   v.y | s.x,
   v.z | s.x,
   v.w | s.x);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator|(T s, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   s | v.x,
   s | v.y,
   s | v.z,
   s | v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator|(tvec1<T, P> const & s, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   s.x | v.x,
   s.x | v.y,
   s.x | v.z,
   s.x | v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator|(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(
   v1.x | v2.x,
   v1.y | v2.y,
   v1.z | v2.z,
   v1.w | v2.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator^(tvec4<T, P> const & v, T s)
 {
  return tvec4<T, P>(
   v.x ^ s,
   v.y ^ s,
   v.z ^ s,
   v.w ^ s);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator^(tvec4<T, P> const & v, tvec1<T, P> const & s)
 {
  return tvec4<T, P>(
   v.x ^ s.x,
   v.y ^ s.x,
   v.z ^ s.x,
   v.w ^ s.x);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator^(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   scalar ^ v.x,
   scalar ^ v.y,
   scalar ^ v.z,
   scalar ^ v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator^(tvec1<T, P> const & s, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   s.x ^ v.x,
   s.x ^ v.y,
   s.x ^ v.z,
   s.x ^ v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator^(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(
   v1.x ^ v2.x,
   v1.y ^ v2.y,
   v1.z ^ v2.z,
   v1.w ^ v2.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator<<(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(
   v.x << scalar,
   v.y << scalar,
   v.z << scalar,
   v.w << scalar);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator<<(tvec4<T, P> const & v, tvec1<T, P> const & s)
 {
  return tvec4<T, P>(
   v.x << s.x,
   v.y << s.x,
   v.z << s.x,
   v.w << s.x);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator<<(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   scalar << v.x,
   scalar << v.y,
   scalar << v.z,
   scalar << v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator<<(tvec1<T, P> const & s, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   s.x << v.x,
   s.x << v.y,
   s.x << v.z,
   s.x << v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator<<(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(
   v1.x << v2.x,
   v1.y << v2.y,
   v1.z << v2.z,
   v1.w << v2.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator>>(tvec4<T, P> const & v, T scalar)
 {
  return tvec4<T, P>(
   v.x >> scalar,
   v.y >> scalar,
   v.z >> scalar,
   v.w >> scalar);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator>>(tvec4<T, P> const & v, tvec1<T, P> const & s)
 {
  return tvec4<T, P>(
   v.x >> s.x,
   v.y >> s.x,
   v.z >> s.x,
   v.w >> s.x);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator>>(T scalar, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   scalar >> v.x,
   scalar >> v.y,
   scalar >> v.z,
   scalar >> v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator>>(tvec1<T, P> const & s, tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   s.x >> v.x,
   s.x >> v.y,
   s.x >> v.z,
   s.x >> v.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator>>(tvec4<T, P> const & v1, tvec4<T, P> const & v2)
 {
  return tvec4<T, P>(
   v1.x >> v2.x,
   v1.y >> v2.y,
   v1.z >> v2.z,
   v1.w >> v2.w);
 }

 template <typename T, precision P>
 inline tvec4<T, P> operator~(tvec4<T, P> const & v)
 {
  return tvec4<T, P>(
   ~v.x,
   ~v.y,
   ~v.z,
   ~v.w);
 }
}
# 527 "../glm/gtx/../detail/type_vec4.hpp" 2
# 36 "../glm/gtx/../vec4.hpp" 2
# 100 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../mat2x2.hpp" 1
# 33 "../glm/gtx/../mat2x2.hpp"
       

# 1 "../glm/gtx/../detail/type_mat2x2.hpp" 1
# 33 "../glm/gtx/../detail/type_mat2x2.hpp"
       







namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat2x2
 {
  typedef tvec2<T, P> col_type;
  typedef tvec2<T, P> row_type;
  typedef tmat2x2<T, P> type;
  typedef tmat2x2<T, P> transpose_type;
  typedef T value_type;

  template <typename U, precision Q>
  friend tvec2<U, Q> operator/(tmat2x2<U, Q> const & m, tvec2<U, Q> const & v);
  template <typename U, precision Q>
  friend tvec2<U, Q> operator/(tvec2<U, Q> const & v, tmat2x2<U, Q> const & m);

 private:

  col_type value[2];


 public:


  tmat2x2();
  template <precision Q>
  tmat2x2(tmat2x2<T, Q> const & m);

  explicit tmat2x2(ctor);
  explicit tmat2x2(T const & x);
  tmat2x2(
   T const & x1, T const & y1,
   T const & x2, T const & y2);
  tmat2x2(
   col_type const & v1,
   col_type const & v2);



  template <typename U, typename V, typename M, typename N>
  tmat2x2(
   U const & x1, V const & y1,
   M const & x2, N const & y2);

  template <typename U, typename V>
  tmat2x2(
   tvec2<U, P> const & v1,
   tvec2<V, P> const & v2);
# 97 "../glm/gtx/../detail/type_mat2x2.hpp"
   template <typename U, precision Q>
   tmat2x2(tmat2x2<U, Q> const & m);


  explicit tmat2x2(tmat3x3<T, P> const & x);
  explicit tmat2x2(tmat4x4<T, P> const & x);
  explicit tmat2x2(tmat2x3<T, P> const & x);
  explicit tmat2x2(tmat3x2<T, P> const & x);
  explicit tmat2x2(tmat2x4<T, P> const & x);
  explicit tmat2x2(tmat4x2<T, P> const & x);
  explicit tmat2x2(tmat3x4<T, P> const & x);
  explicit tmat2x2(tmat4x3<T, P> const & x);
# 120 "../glm/gtx/../detail/type_mat2x2.hpp"
   typedef length_t length_type;
   constexpr length_type length() const;

   col_type & operator[](length_type i);
   col_type const & operator[](length_type i) const;





  template <typename U>
  tmat2x2<T, P> & operator=(tmat2x2<U, P> const & m);
  template <typename U>
  tmat2x2<T, P> & operator+=(U s);
  template <typename U>
  tmat2x2<T, P> & operator+=(tmat2x2<U, P> const & m);
  template <typename U>
  tmat2x2<T, P> & operator-=(U s);
  template <typename U>
  tmat2x2<T, P> & operator-=(tmat2x2<U, P> const & m);
  template <typename U>
  tmat2x2<T, P> & operator*=(U s);
  template <typename U>
  tmat2x2<T, P> & operator*=(tmat2x2<U, P> const & m);
  template <typename U>
  tmat2x2<T, P> & operator/=(U s);
  template <typename U>
  tmat2x2<T, P> & operator/=(tmat2x2<U, P> const & m);




  tmat2x2<T, P> & operator++ ();
  tmat2x2<T, P> & operator-- ();
  tmat2x2<T, P> operator++(int);
  tmat2x2<T, P> operator--(int);
 };


 template <typename T, precision P>
 tmat2x2<T, P> operator+(tmat2x2<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat2x2<T, P> operator+(T const & s, tmat2x2<T, P> const & m);

 template <typename T, precision P>
 tmat2x2<T, P> operator+(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

 template <typename T, precision P>
 tmat2x2<T, P> operator-(tmat2x2<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat2x2<T, P> operator-(T const & s, tmat2x2<T, P> const & m);

 template <typename T, precision P>
 tmat2x2<T, P> operator-(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

 template <typename T, precision P>
 tmat2x2<T, P> operator*(tmat2x2<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat2x2<T, P> operator*(T const & s, tmat2x2<T, P> const & m);

 template <typename T, precision P>
 typename tmat2x2<T, P>::col_type operator*(tmat2x2<T, P> const & m, typename tmat2x2<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat2x2<T, P>::row_type operator*(typename tmat2x2<T, P>::col_type const & v, tmat2x2<T, P> const & m);

 template <typename T, precision P>
 tmat2x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);

 template <typename T, precision P>
 tmat3x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat3x2<T, P> const & m2);

 template <typename T, precision P>
 tmat4x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat4x2<T, P> const & m2);

 template <typename T, precision P>
 tmat2x2<T, P> operator/(tmat2x2<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat2x2<T, P> operator/(T const & s, tmat2x2<T, P> const & m);

 template <typename T, precision P>
 typename tmat2x2<T, P>::col_type operator/(tmat2x2<T, P> const & m, typename tmat2x2<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat2x2<T, P>::row_type operator/(typename tmat2x2<T, P>::col_type const & v, tmat2x2<T, P> const & m);

 template <typename T, precision P>
 tmat2x2<T, P> operator/(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2);


 template <typename T, precision P>
 tmat2x2<T, P> const operator-(tmat2x2<T, P> const & m);
}


# 1 "../glm/gtx/../detail/type_mat2x2.inl" 1
# 33 "../glm/gtx/../detail/type_mat2x2.inl"
namespace glm{
namespace detail
{
 template <typename T, precision P>
 inline tmat2x2<T, P> compute_inverse(tmat2x2<T, P> const & m)
 {
  T OneOverDeterminant = static_cast<T>(1) / (
   + m[0][0] * m[1][1]
   - m[1][0] * m[0][1]);

  tmat2x2<T, P> Inverse(
   + m[1][1] * OneOverDeterminant,
   - m[0][1] * OneOverDeterminant,
   - m[1][0] * OneOverDeterminant,
   + m[0][0] * OneOverDeterminant);

  return Inverse;
 }
}




 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2()
 {

   this->value[0] = col_type(1, 0);
   this->value[1] = col_type(0, 1);

 }

 template <typename T, precision P>
 template <precision Q>
 inline tmat2x2<T, P>::tmat2x2(tmat2x2<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2(ctor)
 {}

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2(T const & s)
 {
  this->value[0] = col_type(s, 0);
  this->value[1] = col_type(0, s);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2
 (
  T const & x0, T const & y0,
  T const & x1, T const & y1
 )
 {
  this->value[0] = col_type(x0, y0);
  this->value[1] = col_type(x1, y1);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2(col_type const & v0, col_type const & v1)
 {
  this->value[0] = v0;
  this->value[1] = v1;
 }



 template <typename T, precision P>
 template <typename X1, typename Y1, typename X2, typename Y2>
 inline tmat2x2<T, P>::tmat2x2
 (
  X1 const & x1, Y1 const & y1,
  X2 const & x2, Y2 const & y2
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
 }

 template <typename T, precision P>
 template <typename V1, typename V2>
 inline tmat2x2<T, P>::tmat2x2(tvec2<V1, P> const & v1, tvec2<V2, P> const & v2)
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
 }




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat2x2<T, P>::tmat2x2(tmat2x2<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2(tmat3x2<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2(tmat4x2<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>::tmat2x2(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }
# 215 "../glm/gtx/../detail/type_mat2x2.inl"
  template <typename T, precision P>
  inline constexpr typename tmat2x2<T, P>::length_type tmat2x2<T, P>::length() const
  {
   return 2;
  }

  template <typename T, precision P>
  inline typename tmat2x2<T, P>::col_type & tmat2x2<T, P>::operator[](typename tmat2x2<T, P>::length_type i)
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat2x2.inl", 224, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }

  template <typename T, precision P>
  inline typename tmat2x2<T, P>::col_type const & tmat2x2<T, P>::operator[](typename tmat2x2<T, P>::length_type i) const
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat2x2.inl", 231, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }





 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator=(tmat2x2<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator+=(tmat2x2<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator-=(tmat2x2<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator*=(tmat2x2<U, P> const & m)
 {
  return (*this = *this * m);
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator/=(tmat2x2<U, P> const & m)
 {
  return (*this = *this * detail::compute_inverse<T, P>(m));
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template <typename T, precision P>
 inline tmat2x2<T, P>& tmat2x2<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> tmat2x2<T, P>::operator++(int)
 {
  tmat2x2<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> tmat2x2<T, P>::operator--(int)
 {
  tmat2x2<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline tmat2x2<T, P> operator+(tmat2x2<T, P> const & m, T const & s)
 {
  return tmat2x2<T, P>(
   m[0] + s,
   m[1] + s);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator+(T const & s, tmat2x2<T, P> const & m)
 {
  return tmat2x2<T, P>(
   m[0] + s,
   m[1] + s);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator+(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return tmat2x2<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator-(tmat2x2<T, P> const & m, T const & s)
 {
  return tmat2x2<T, P>(
   m[0] - s,
   m[1] - s);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator-(T const & s, tmat2x2<T, P> const & m)
 {
  return tmat2x2<T, P>(
   s - m[0],
   s - m[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator-(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return tmat2x2<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator*(tmat2x2<T, P> const & m, T const & s)
 {
  return tmat2x2<T, P>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator*(T const & s, tmat2x2<T, P> const & m)
 {
  return tmat2x2<T, P>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T, precision P>
 inline typename tmat2x2<T, P>::col_type operator*
 (
  tmat2x2<T, P> const & m,
  typename tmat2x2<T, P>::row_type const & v
 )
 {
  return tvec2<T, P>(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y);
 }

 template <typename T, precision P>
 inline typename tmat2x2<T, P>::row_type operator*
 (
  typename tmat2x2<T, P>::col_type const & v,
  tmat2x2<T, P> const & m
 )
 {
  return tvec2<T, P>(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return tmat2x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1]);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return tmat3x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator*(tmat2x2<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return tmat4x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator/(tmat2x2<T, P> const & m, T const & s)
 {
  return tmat2x2<T, P>(
   m[0] / s,
   m[1] / s);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator/(T const & s, tmat2x2<T, P> const & m)
 {
  return tmat2x2<T, P>(
   s / m[0],
   s / m[1]);
 }

 template <typename T, precision P>
 inline typename tmat2x2<T, P>::col_type operator/(tmat2x2<T, P> const & m, typename tmat2x2<T, P>::row_type const & v)
 {
  return detail::compute_inverse<T, P>(m) * v;
 }

 template <typename T, precision P>
 inline typename tmat2x2<T, P>::row_type operator/(typename tmat2x2<T, P>::col_type const & v, tmat2x2<T, P> const & m)
 {
  return v * detail::compute_inverse<T, P>(m);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator/(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  tmat2x2<T, P> m1_copy(m1);
  return m1_copy /= m2;
 }


 template <typename T, precision P>
 inline tmat2x2<T, P> const operator-(tmat2x2<T, P> const & m)
 {
  return tmat2x2<T, P>(
   -m[0],
   -m[1]);
 }




 template <typename T, precision P>
 inline bool operator==(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T, precision P>
 inline bool operator!=(tmat2x2<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 220 "../glm/gtx/../detail/type_mat2x2.hpp" 2
# 36 "../glm/gtx/../mat2x2.hpp" 2

namespace glm
{





 typedef tmat2x2<float, lowp> lowp_mat2;






 typedef tmat2x2<float, mediump> mediump_mat2;






 typedef tmat2x2<float, highp> highp_mat2;






 typedef tmat2x2<float, lowp> lowp_mat2x2;






 typedef tmat2x2<float, mediump> mediump_mat2x2;






 typedef tmat2x2<float, highp> highp_mat2x2;

}
# 101 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../mat2x3.hpp" 1
# 33 "../glm/gtx/../mat2x3.hpp"
       

# 1 "../glm/gtx/../detail/type_mat2x3.hpp" 1
# 33 "../glm/gtx/../detail/type_mat2x3.hpp"
       
# 42 "../glm/gtx/../detail/type_mat2x3.hpp"
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat2x3
 {
  typedef tvec3<T, P> col_type;
  typedef tvec2<T, P> row_type;
  typedef tmat2x3<T, P> type;
  typedef tmat3x2<T, P> transpose_type;
  typedef T value_type;

 private:

  col_type value[2];


 public:

  tmat2x3();
  template <precision Q>
  tmat2x3(tmat2x3<T, Q> const & m);

  explicit tmat2x3(ctor);
  explicit tmat2x3(T const & s);
  tmat2x3(
   T const & x0, T const & y0, T const & z0,
   T const & x1, T const & y1, T const & z1);
  tmat2x3(
   col_type const & v0,
   col_type const & v1);




  template <typename X1, typename Y1, typename Z1, typename X2, typename Y2, typename Z2>
  tmat2x3(
   X1 const & x1, Y1 const & y1, Z1 const & z1,
   X2 const & x2, Y2 const & y2, Z2 const & z2);

  template <typename U, typename V>
  tmat2x3(
   tvec3<U, P> const & v1,
   tvec3<V, P> const & v2);
# 93 "../glm/gtx/../detail/type_mat2x3.hpp"
   template <typename U, precision Q>
   tmat2x3(tmat2x3<U, Q> const & m);


  explicit tmat2x3(tmat2x2<T, P> const & x);
  explicit tmat2x3(tmat3x3<T, P> const & x);
  explicit tmat2x3(tmat4x4<T, P> const & x);
  explicit tmat2x3(tmat2x4<T, P> const & x);
  explicit tmat2x3(tmat3x2<T, P> const & x);
  explicit tmat2x3(tmat3x4<T, P> const & x);
  explicit tmat2x3(tmat4x2<T, P> const & x);
  explicit tmat2x3(tmat4x3<T, P> const & x);
# 116 "../glm/gtx/../detail/type_mat2x3.hpp"
   typedef length_t length_type;
   constexpr length_type length() const;

   col_type & operator[](length_type i);
   col_type const & operator[](length_type i) const;





  template <typename U>
  tmat2x3<T, P> & operator= (tmat2x3<U, P> const & m);
  template <typename U>
  tmat2x3<T, P> & operator+= (U s);
  template <typename U>
  tmat2x3<T, P> & operator+= (tmat2x3<U, P> const & m);
  template <typename U>
  tmat2x3<T, P> & operator-= (U s);
  template <typename U>
  tmat2x3<T, P> & operator-= (tmat2x3<U, P> const & m);
  template <typename U>
  tmat2x3<T, P> & operator*= (U s);
  template <typename U>
  tmat2x3<T, P> & operator/= (U s);




  tmat2x3<T, P> & operator++ ();
  tmat2x3<T, P> & operator-- ();
  tmat2x3<T, P> operator++(int);
  tmat2x3<T, P> operator--(int);
 };



 template <typename T, precision P>
 tmat2x3<T, P> operator+ (
  tmat2x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x3<T, P> operator+ (
  tmat2x3<T, P> const & m1,
  tmat2x3<T, P> const & m2);

 template <typename T, precision P>
 tmat2x3<T, P> operator- (
  tmat2x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x3<T, P> operator- (
  tmat2x3<T, P> const & m1,
  tmat2x3<T, P> const & m2);

 template <typename T, precision P>
 tmat2x3<T, P> operator* (
  tmat2x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x3<T, P> operator* (
  T const & s,
  tmat2x3<T, P> const & m);

 template <typename T, precision P>
 typename tmat2x3<T, P>::col_type operator* (
  tmat2x3<T, P> const & m,
  typename tmat2x3<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat2x3<T, P>::row_type operator* (
  typename tmat2x3<T, P>::col_type const & v,
  tmat2x3<T, P> const & m);

 template <typename T, precision P>
 tmat2x3<T, P> operator* (
  tmat2x3<T, P> const & m1,
  tmat2x2<T, P> const & m2);

 template <typename T, precision P>
 tmat3x3<T, P> operator* (
  tmat2x3<T, P> const & m1,
  tmat3x2<T, P> const & m2);

 template <typename T, precision P>
 tmat4x3<T, P> operator* (
  tmat2x3<T, P> const & m1,
  tmat4x2<T, P> const & m2);

 template <typename T, precision P>
 tmat2x3<T, P> operator/ (
  tmat2x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x3<T, P> operator/ (
  T const & s,
  tmat2x3<T, P> const & m);


 template <typename T, precision P>
 tmat2x3<T, P> const operator- (
  tmat2x3<T, P> const & m);
}


# 1 "../glm/gtx/../detail/type_mat2x3.inl" 1
# 33 "../glm/gtx/../detail/type_mat2x3.inl"
namespace glm
{



 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3()
 {

   this->value[0] = col_type(1, 0, 0);
   this->value[1] = col_type(0, 1, 0);

 }

 template <typename T, precision P>
 template <precision Q>
 inline tmat2x3<T, P>::tmat2x3(tmat2x3<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3(ctor)
 {}

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3(T const & s)
 {
  this->value[0] = col_type(s, 0, 0);
  this->value[1] = col_type(0, s, 0);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3
 (
  T const & x0, T const & y0, T const & z0,
  T const & x1, T const & y1, T const & z1
 )
 {
  this->value[0] = col_type(x0, y0, z0);
  this->value[1] = col_type(x1, y1, z1);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3(col_type const & v0, col_type const & v1)
 {
  this->value[0] = v0;
  this->value[1] = v1;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2>
 inline tmat2x3<T, P>::tmat2x3
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1,
  X2 const & x2, Y2 const & y2, Z2 const & z2
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
 }

 template <typename T, precision P>
 template <typename V1, typename V2>
 inline tmat2x3<T, P>::tmat2x3(tvec3<V1, P> const & v1, tvec3<V2, P> const & v2)
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
 }




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat2x3<T, P>::tmat2x3(tmat2x3<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P>::tmat2x3(tmat4x3<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }
# 199 "../glm/gtx/../detail/type_mat2x3.inl"
  template <typename T, precision P>
  inline constexpr typename tmat2x3<T, P>::length_type tmat2x3<T, P>::length() const
  {
   return 2;
  }

  template <typename T, precision P>
  inline typename tmat2x3<T, P>::col_type & tmat2x3<T, P>::operator[](typename tmat2x3<T, P>::length_type i)
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat2x3.inl", 208, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }

  template <typename T, precision P>
  inline typename tmat2x3<T, P>::col_type const & tmat2x3<T, P>::operator[](typename tmat2x3<T, P>::length_type i) const
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat2x3.inl", 215, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }





 template <typename T, precision P>
 template <typename U>
 inline tmat2x3<T, P>& tmat2x3<T, P>::operator=(tmat2x3<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x3<T, P> & tmat2x3<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x3<T, P>& tmat2x3<T, P>::operator+=(tmat2x3<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x3<T, P>& tmat2x3<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x3<T, P>& tmat2x3<T, P>::operator-=(tmat2x3<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x3<T, P>& tmat2x3<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x3<T, P> & tmat2x3<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> & tmat2x3<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> & tmat2x3<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> tmat2x3<T, P>::operator++(int)
 {
  tmat2x3<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> tmat2x3<T, P>::operator--(int)
 {
  tmat2x3<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline tmat2x3<T, P> operator+(tmat2x3<T, P> const & m, T const & s)
 {
  return tmat2x3<T, P>(
   m[0] + s,
   m[1] + s);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator+(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return tmat2x3<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator-(tmat2x3<T, P> const & m, T const & s)
 {
  return tmat2x3<T, P>(
   m[0] - s,
   m[1] - s);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator-(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return tmat2x3<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator*(tmat2x3<T, P> const & m, T const & s)
 {
  return tmat2x3<T, P>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator*(T const & s, tmat2x3<T, P> const & m)
 {
  return tmat2x3<T, P>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T, precision P>
 inline typename tmat2x3<T, P>::col_type operator*
 (
  tmat2x3<T, P> const & m,
  typename tmat2x3<T, P>::row_type const & v)
 {
  return typename tmat2x3<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y);
 }

 template <typename T, precision P>
 inline typename tmat2x3<T, P>::row_type operator*
 (
  typename tmat2x3<T, P>::col_type const & v,
  tmat2x3<T, P> const & m)
 {
  return typename tmat2x3<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return tmat2x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];

  tmat3x3<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  return Result;
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator*(tmat2x3<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator/(tmat2x3<T, P> const & m, T const & s)
 {
  return tmat2x3<T, P>(
   m[0] / s,
   m[1] / s);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator/(T const & s, tmat2x3<T, P> const & m)
 {
  return tmat2x3<T, P>(
   s / m[0],
   s / m[1]);
 }


 template <typename T, precision P>
 inline tmat2x3<T, P> const operator-(tmat2x3<T, P> const & m)
 {
  return tmat2x3<T, P>(
   -m[0],
   -m[1]);
 }




 template <typename T, precision P>
 inline bool operator==(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T, precision P>
 inline bool operator!=(tmat2x3<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 225 "../glm/gtx/../detail/type_mat2x3.hpp" 2
# 36 "../glm/gtx/../mat2x3.hpp" 2

namespace glm
{





 typedef tmat2x3<float, lowp> lowp_mat2x3;






 typedef tmat2x3<float, mediump> mediump_mat2x3;






 typedef tmat2x3<float, highp> highp_mat2x3;

}
# 102 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../mat2x4.hpp" 1
# 33 "../glm/gtx/../mat2x4.hpp"
       

# 1 "../glm/gtx/../detail/type_mat2x4.hpp" 1
# 33 "../glm/gtx/../detail/type_mat2x4.hpp"
       
# 42 "../glm/gtx/../detail/type_mat2x4.hpp"
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat2x4
 {
  typedef tvec4<T, P> col_type;
  typedef tvec2<T, P> row_type;
  typedef tmat2x4<T, P> type;
  typedef tmat4x2<T, P> transpose_type;
  typedef T value_type;

 private:

  col_type value[2];


 public:

  tmat2x4();
  template <precision Q>
  tmat2x4(tmat2x4<T, Q> const & m);

  explicit tmat2x4(ctor);
  explicit tmat2x4(T const & s);
  tmat2x4(
   T const & x0, T const & y0, T const & z0, T const & w0,
   T const & x1, T const & y1, T const & z1, T const & w1);
  tmat2x4(
   col_type const & v0,
   col_type const & v1);



  template <
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2>
  tmat2x4(
   X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
   X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2);

  template <typename U, typename V>
  tmat2x4(
   tvec4<U, P> const & v1,
   tvec4<V, P> const & v2);
# 94 "../glm/gtx/../detail/type_mat2x4.hpp"
   template <typename U, precision Q>
   tmat2x4(tmat2x4<U, Q> const & m);


  explicit tmat2x4(tmat2x2<T, P> const & x);
  explicit tmat2x4(tmat3x3<T, P> const & x);
  explicit tmat2x4(tmat4x4<T, P> const & x);
  explicit tmat2x4(tmat2x3<T, P> const & x);
  explicit tmat2x4(tmat3x2<T, P> const & x);
  explicit tmat2x4(tmat3x4<T, P> const & x);
  explicit tmat2x4(tmat4x2<T, P> const & x);
  explicit tmat2x4(tmat4x3<T, P> const & x);
# 117 "../glm/gtx/../detail/type_mat2x4.hpp"
   typedef length_t length_type;
   constexpr length_type length() const;

   col_type & operator[](length_type i);
   col_type const & operator[](length_type i) const;





  template <typename U>
  tmat2x4<T, P>& operator= (tmat2x4<U, P> const & m);
  template <typename U>
  tmat2x4<T, P>& operator+= (U s);
  template <typename U>
  tmat2x4<T, P>& operator+= (tmat2x4<U, P> const & m);
  template <typename U>
  tmat2x4<T, P>& operator-= (U s);
  template <typename U>
  tmat2x4<T, P>& operator-= (tmat2x4<U, P> const & m);
  template <typename U>
  tmat2x4<T, P>& operator*= (U s);
  template <typename U>
  tmat2x4<T, P>& operator/= (U s);




  tmat2x4<T, P> & operator++ ();
  tmat2x4<T, P> & operator-- ();
  tmat2x4<T, P> operator++(int);
  tmat2x4<T, P> operator--(int);
 };



 template <typename T, precision P>
 tmat2x4<T, P> operator+ (
  tmat2x4<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x4<T, P> operator+ (
  tmat2x4<T, P> const & m1,
  tmat2x4<T, P> const & m2);

 template <typename T, precision P>
 tmat2x4<T, P> operator- (
  tmat2x4<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x4<T, P> operator- (
  tmat2x4<T, P> const & m1,
  tmat2x4<T, P> const & m2);

 template <typename T, precision P>
 tmat2x4<T, P> operator* (
  tmat2x4<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat2x4<T, P> operator* (
  T const & s,
  tmat2x4<T, P> const & m);

 template <typename T, precision P>
 typename tmat2x4<T, P>::col_type operator* (
  tmat2x4<T, P> const & m,
  typename tmat2x4<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat2x4<T, P>::row_type operator* (
  typename tmat2x4<T, P>::col_type const & v,
  tmat2x4<T, P> const & m);

 template <typename T, precision P>
 tmat4x4<T, P> operator* (
  tmat2x4<T, P> const & m1,
  tmat4x2<T, P> const & m2);

 template <typename T, precision P>
 tmat2x4<T, P> operator* (
  tmat2x4<T, P> const & m1,
  tmat2x2<T, P> const & m2);

 template <typename T, precision P>
 tmat3x4<T, P> operator* (
  tmat2x4<T, P> const & m1,
  tmat3x2<T, P> const & m2);

 template <typename T, precision P>
 tmat2x4<T, P> operator/ (
  tmat2x4<T, P> const & m,
  T s);

 template <typename T, precision P>
 tmat2x4<T, P> operator/ (
  T s,
  tmat2x4<T, P> const & m);


 template <typename T, precision P>
 tmat2x4<T, P> const operator- (
  tmat2x4<T, P> const & m);
}


# 1 "../glm/gtx/../detail/type_mat2x4.inl" 1
# 33 "../glm/gtx/../detail/type_mat2x4.inl"
namespace glm
{



 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4()
 {

   this->value[0] = col_type(1, 0, 0, 0);
   this->value[1] = col_type(0, 1, 0, 0);

 }

 template <typename T, precision P>
 template <precision Q>
 inline tmat2x4<T, P>::tmat2x4(tmat2x4<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4(ctor)
 {}

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4(T const & s)
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero, Zero, Zero);
  this->value[1] = col_type(Zero, s, Zero, Zero);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4
 (
  T const & x0, T const & y0, T const & z0, T const & w0,
  T const & x1, T const & y1, T const & z1, T const & w1
 )
 {
  this->value[0] = col_type(x0, y0, z0, w0);
  this->value[1] = col_type(x1, y1, z1, w1);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4(col_type const & v0, col_type const & v1)
 {
  this->value[0] = v0;
  this->value[1] = v1;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2>
 inline tmat2x4<T, P>::tmat2x4
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
  X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
 }

 template <typename T, precision P>
 template <typename V1, typename V2>
 inline tmat2x4<T, P>::tmat2x4(tvec4<V1, P> const & v1, tvec4<V2, P> const & v2)
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
 }




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat2x4<T, P>::tmat2x4(tmat2x4<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4(tmat3x4<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>::tmat2x4(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
 }
# 200 "../glm/gtx/../detail/type_mat2x4.inl"
  template <typename T, precision P>
  inline constexpr typename tmat2x4<T, P>::length_type tmat2x4<T, P>::length() const
  {
   return 2;
  }

  template <typename T, precision P>
  inline typename tmat2x4<T, P>::col_type & tmat2x4<T, P>::operator[](typename tmat2x4<T, P>::length_type i)
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat2x4.inl", 209, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }

  template <typename T, precision P>
  inline typename tmat2x4<T, P>::col_type const & tmat2x4<T, P>::operator[](typename tmat2x4<T, P>::length_type i) const
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat2x4.inl", 216, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }





 template <typename T, precision P>
 template <typename U>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator=(tmat2x4<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator+=(tmat2x4<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator-=(tmat2x4<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat2x4<T, P> & tmat2x4<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  return *this;
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  return *this;
 }

 template <typename T, precision P>
 inline tmat2x4<T, P>& tmat2x4<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  return *this;
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> tmat2x4<T, P>::operator++(int)
 {
  tmat2x4<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> tmat2x4<T, P>::operator--(int)
 {
  tmat2x4<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline tmat2x4<T, P> operator+(tmat2x4<T, P> const & m, T const & s)
 {
  return tmat2x4<T, P>(
   m[0] + s,
   m[1] + s);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator+(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return tmat2x4<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1]);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator-(tmat2x4<T, P> const & m, T const & s)
 {
  return tmat2x4<T, P>(
   m[0] - s,
   m[1] - s);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator-(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return tmat2x4<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1]);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator*(tmat2x4<T, P> const & m, T const & s)
 {
  return tmat2x4<T, P>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator*(T const & s, tmat2x4<T, P> const & m)
 {
  return tmat2x4<T, P>(
   m[0] * s,
   m[1] * s);
 }

 template <typename T, precision P>
 inline typename tmat2x4<T, P>::col_type operator*(tmat2x4<T, P> const & m, typename tmat2x4<T, P>::row_type const & v)
 {
  return typename tmat2x4<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y,
   m[0][1] * v.x + m[1][1] * v.y,
   m[0][2] * v.x + m[1][2] * v.y,
   m[0][3] * v.x + m[1][3] * v.y);
 }

 template <typename T, precision P>
 inline typename tmat2x4<T, P>::row_type operator*(typename tmat2x4<T, P>::col_type const & v, tmat2x4<T, P> const & m)
 {
  return typename tmat2x4<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3]);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  T SrcA00 = m1[0][0];
  T SrcA01 = m1[0][1];
  T SrcA02 = m1[0][2];
  T SrcA03 = m1[0][3];
  T SrcA10 = m1[1][0];
  T SrcA11 = m1[1][1];
  T SrcA12 = m1[1][2];
  T SrcA13 = m1[1][3];

  T SrcB00 = m2[0][0];
  T SrcB01 = m2[0][1];
  T SrcB10 = m2[1][0];
  T SrcB11 = m2[1][1];
  T SrcB20 = m2[2][0];
  T SrcB21 = m2[2][1];
  T SrcB30 = m2[3][0];
  T SrcB31 = m2[3][1];

  tmat4x4<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31;
  return Result;
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat2x2<T, P> const & m2)
 {
  return tmat2x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1]);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator*(tmat2x4<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return tmat3x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1]);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator/(tmat2x4<T, P> const & m, T s)
 {
  return tmat2x4<T, P>(
   m[0] / s,
   m[1] / s);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator/(T s, tmat2x4<T, P> const & m)
 {
  return tmat2x4<T, P>(
   s / m[0],
   s / m[1]);
 }


 template <typename T, precision P>
 inline tmat2x4<T, P> const operator-(tmat2x4<T, P> const & m)
 {
  return tmat2x4<T, P>(
   -m[0],
   -m[1]);
 }




 template <typename T, precision P>
 inline bool operator==(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]);
 }

 template <typename T, precision P>
 inline bool operator!=(tmat2x4<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]);
 }
}
# 226 "../glm/gtx/../detail/type_mat2x4.hpp" 2
# 36 "../glm/gtx/../mat2x4.hpp" 2

namespace glm
{





 typedef tmat2x4<float, lowp> lowp_mat2x4;






 typedef tmat2x4<float, mediump> mediump_mat2x4;






 typedef tmat2x4<float, highp> highp_mat2x4;

}
# 103 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../mat3x2.hpp" 1
# 33 "../glm/gtx/../mat3x2.hpp"
       

# 1 "../glm/gtx/../detail/type_mat3x2.hpp" 1
# 33 "../glm/gtx/../detail/type_mat3x2.hpp"
       
# 42 "../glm/gtx/../detail/type_mat3x2.hpp"
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat3x2
 {
  typedef tvec2<T, P> col_type;
  typedef tvec3<T, P> row_type;
  typedef tmat3x2<T, P> type;
  typedef tmat2x3<T, P> transpose_type;
  typedef T value_type;

 private:

  col_type value[3];


 public:

  tmat3x2();
  template <precision Q>
  tmat3x2(tmat3x2<T, Q> const & m);

  explicit tmat3x2(ctor);
  explicit tmat3x2(T const & s);
  tmat3x2(
   T const & x0, T const & y0,
   T const & x1, T const & y1,
   T const & x2, T const & y2);
  tmat3x2(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);




  template<
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3>
  tmat3x2(
   X1 const & x1, Y1 const & y1,
   X2 const & x2, Y2 const & y2,
   X3 const & x3, Y3 const & y3);

  template <typename V1, typename V2, typename V3>
  tmat3x2(
   tvec2<V1, P> const & v1,
   tvec2<V2, P> const & v2,
   tvec2<V3, P> const & v3);
# 100 "../glm/gtx/../detail/type_mat3x2.hpp"
   template <typename U, precision Q>
   tmat3x2(tmat3x2<U, Q> const & m);


  explicit tmat3x2(tmat2x2<T, P> const & x);
  explicit tmat3x2(tmat3x3<T, P> const & x);
  explicit tmat3x2(tmat4x4<T, P> const & x);
  explicit tmat3x2(tmat2x3<T, P> const & x);
  explicit tmat3x2(tmat2x4<T, P> const & x);
  explicit tmat3x2(tmat3x4<T, P> const & x);
  explicit tmat3x2(tmat4x2<T, P> const & x);
  explicit tmat3x2(tmat4x3<T, P> const & x);
# 123 "../glm/gtx/../detail/type_mat3x2.hpp"
   typedef length_t length_type;
   constexpr length_type length() const;

   col_type & operator[](length_type i);
   col_type const & operator[](length_type i) const;





  template <typename U>
  tmat3x2<T, P> & operator= (tmat3x2<U, P> const & m);
  template <typename U>
  tmat3x2<T, P> & operator+= (U s);
  template <typename U>
  tmat3x2<T, P> & operator+= (tmat3x2<U, P> const & m);
  template <typename U>
  tmat3x2<T, P> & operator-= (U s);
  template <typename U>
  tmat3x2<T, P> & operator-= (tmat3x2<U, P> const & m);
  template <typename U>
  tmat3x2<T, P> & operator*= (U s);
  template <typename U>
  tmat3x2<T, P> & operator/= (U s);




  tmat3x2<T, P> & operator++ ();
  tmat3x2<T, P> & operator-- ();
  tmat3x2<T, P> operator++(int);
  tmat3x2<T, P> operator--(int);
 };


 template <typename T, precision P>
 tmat3x2<T, P> operator+ (
  tmat3x2<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x2<T, P> operator+ (
  tmat3x2<T, P> const & m1,
  tmat3x2<T, P> const & m2);

 template <typename T, precision P>
 tmat3x2<T, P> operator- (
  tmat3x2<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x2<T, P> operator- (
  tmat3x2<T, P> const & m1,
  tmat3x2<T, P> const & m2);

 template <typename T, precision P>
 tmat3x2<T, P> operator* (
  tmat3x2<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x2<T, P> operator* (
  T const & s,
  tmat3x2<T, P> const & m);

 template <typename T, precision P>
 typename tmat3x2<T, P>::col_type operator* (
  tmat3x2<T, P> const & m,
  typename tmat3x2<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat3x2<T, P>::row_type operator* (
  typename tmat3x2<T, P>::col_type const & v,
  tmat3x2<T, P> const & m);

 template <typename T, precision P>
 tmat2x2<T, P> operator* (
  tmat3x2<T, P> const & m1,
  tmat2x3<T, P> const & m2);

 template <typename T, precision P>
 tmat3x2<T, P> operator* (
  tmat3x2<T, P> const & m1,
  tmat3x3<T, P> const & m2);

 template <typename T, precision P>
 tmat4x2<T, P> operator* (
  tmat3x2<T, P> const & m1,
  tmat4x3<T, P> const & m2);

 template <typename T, precision P>
 tmat3x2<T, P> operator/ (
  tmat3x2<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x2<T, P> operator/ (
  T const & s,
  tmat3x2<T, P> const & m);


 template <typename T, precision P>
 tmat3x2<T, P> const operator-(
  tmat3x2<T, P> const & m);
}


# 1 "../glm/gtx/../detail/type_mat3x2.inl" 1
# 33 "../glm/gtx/../detail/type_mat3x2.inl"
namespace glm
{



 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2()
 {

   this->value[0] = col_type(1, 0);
   this->value[1] = col_type(0, 1);
   this->value[2] = col_type(0, 0);

 }

 template <typename T, precision P>
 template <precision Q>
 inline tmat3x2<T, P>::tmat3x2(tmat3x2<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2(ctor)
 {}

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2(T const & s)
 {
  this->value[0] = col_type(s, 0);
  this->value[1] = col_type(0, s);
  this->value[2] = col_type(0, 0);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2
 (
  T const & x0, T const & y0,
  T const & x1, T const & y1,
  T const & x2, T const & y2
 )
 {
  this->value[0] = col_type(x0, y0);
  this->value[1] = col_type(x1, y1);
  this->value[2] = col_type(x2, y2);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3>
 inline tmat3x2<T, P>::tmat3x2
 (
  X1 const & x1, Y1 const & y1,
  X2 const & x2, Y2 const & y2,
  X3 const & x3, Y3 const & y3
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3>
 inline tmat3x2<T, P>::tmat3x2
 (
  tvec2<V1, P> const & v1,
  tvec2<V2, P> const & v2,
  tvec2<V3, P> const & v3
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
 }




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat3x2<T, P>::tmat3x2(tmat3x2<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2(tmat2x2<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = col_type(0);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(T(0));
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(T(0));
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2(tmat4x2<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>::tmat3x2(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }
# 228 "../glm/gtx/../detail/type_mat3x2.inl"
  template <typename T, precision P>
  inline constexpr typename tmat3x2<T, P>::length_type tmat3x2<T, P>::length() const
  {
   return 3;
  }

  template <typename T, precision P>
  inline typename tmat3x2<T, P>::col_type & tmat3x2<T, P>::operator[](typename tmat3x2<T, P>::length_type i)
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat3x2.inl", 237, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }

  template <typename T, precision P>
  inline typename tmat3x2<T, P>::col_type const & tmat3x2<T, P>::operator[](typename tmat3x2<T, P>::length_type i) const
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat3x2.inl", 244, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }





 template <typename T, precision P>
 template <typename U>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator=(tmat3x2<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator+=(tmat3x2<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator-=(tmat3x2<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x2<T, P> & tmat3x2<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template <typename T, precision P>
 inline tmat3x2<T, P>& tmat3x2<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> tmat3x2<T, P>::operator++(int)
 {
  tmat3x2<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> tmat3x2<T, P>::operator--(int)
 {
  tmat3x2<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline tmat3x2<T, P> operator+(tmat3x2<T, P> const & m, T const & s)
 {
  return tmat3x2<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator+(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return tmat3x2<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator-(tmat3x2<T, P> const & m, T const & s)
 {
  return tmat3x2<T, P>(
   m[0] - s,
   m[1] - s,
   m[2] - s);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator-(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return tmat3x2<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator*(tmat3x2<T, P> const & m, T const & s)
 {
  return tmat3x2<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator*(T const & s, tmat3x2<T, P> const & m)
 {
  return tmat3x2<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T, precision P>
 inline typename tmat3x2<T, P>::col_type operator*(tmat3x2<T, P> const & m, typename tmat3x2<T, P>::row_type const & v)
 {
  return typename tmat3x2<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z);
 }

 template <typename T, precision P>
 inline typename tmat3x2<T, P>::row_type operator*(typename tmat3x2<T, P>::col_type const & v, tmat3x2<T, P> const & m)
 {
  return typename tmat3x2<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];

  tmat2x2<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  return Result;
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return tmat3x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator*(tmat3x2<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return tmat4x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2]);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator/(tmat3x2<T, P> const & m, T const & s)
 {
  return tmat3x2<T, P>(
   m[0] / s,
   m[1] / s,
   m[2] / s);
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator/(T const & s, tmat3x2<T, P> const & m)
 {
  return tmat3x2<T, P>(
   s / m[0],
   s / m[1],
   s / m[2]);
 }


 template <typename T, precision P>
 inline tmat3x2<T, P> const operator-(tmat3x2<T, P> const & m)
 {
  return tmat3x2<T, P>(
   -m[0],
   -m[1],
   -m[2]);
 }




 template <typename T, precision P>
 inline bool operator==(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T, precision P>
 inline bool operator!=(tmat3x2<T, P> const & m1, tmat3x2<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 231 "../glm/gtx/../detail/type_mat3x2.hpp" 2
# 36 "../glm/gtx/../mat3x2.hpp" 2

namespace glm
{





 typedef tmat3x2<float, lowp> lowp_mat3x2;






 typedef tmat3x2<float, mediump> mediump_mat3x2;






 typedef tmat3x2<float, highp> highp_mat3x2;

}
# 104 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../mat3x3.hpp" 1
# 33 "../glm/gtx/../mat3x3.hpp"
       

# 1 "../glm/gtx/../detail/type_mat3x3.hpp" 1
# 33 "../glm/gtx/../detail/type_mat3x3.hpp"
       







namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat3x3
 {
  typedef tvec3<T, P> col_type;
  typedef tvec3<T, P> row_type;
  typedef tmat3x3<T, P> type;
  typedef tmat3x3<T, P> transpose_type;
  typedef T value_type;

  template <typename U, precision Q>
  friend tvec3<U, Q> operator/(tmat3x3<U, Q> const & m, tvec3<U, Q> const & v);
  template <typename U, precision Q>
  friend tvec3<U, Q> operator/(tvec3<U, Q> const & v, tmat3x3<U, Q> const & m);

 private:

  col_type value[3];


 public:

  tmat3x3();
  template <precision Q>
  tmat3x3(tmat3x3<T, Q> const & m);

  explicit tmat3x3(ctor);
  explicit tmat3x3(T const & s);
  tmat3x3(
   T const & x0, T const & y0, T const & z0,
   T const & x1, T const & y1, T const & z1,
   T const & x2, T const & y2, T const & z2);
  tmat3x3(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);




  template<
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3>
  tmat3x3(
   X1 const & x1, Y1 const & y1, Z1 const & z1,
   X2 const & x2, Y2 const & y2, Z2 const & z2,
   X3 const & x3, Y3 const & y3, Z3 const & z3);

  template <typename V1, typename V2, typename V3>
  tmat3x3(
   tvec3<V1, P> const & v1,
   tvec3<V2, P> const & v2,
   tvec3<V3, P> const & v3);
# 104 "../glm/gtx/../detail/type_mat3x3.hpp"
   template <typename U, precision Q>
   tmat3x3(tmat3x3<U, Q> const & m);


  explicit tmat3x3(tmat2x2<T, P> const & x);
  explicit tmat3x3(tmat4x4<T, P> const & x);
  explicit tmat3x3(tmat2x3<T, P> const & x);
  explicit tmat3x3(tmat3x2<T, P> const & x);
  explicit tmat3x3(tmat2x4<T, P> const & x);
  explicit tmat3x3(tmat4x2<T, P> const & x);
  explicit tmat3x3(tmat3x4<T, P> const & x);
  explicit tmat3x3(tmat4x3<T, P> const & x);
# 127 "../glm/gtx/../detail/type_mat3x3.hpp"
   typedef length_t length_type;
   constexpr length_type length() const;

   col_type & operator[](length_type i);
   col_type const & operator[](length_type i) const;





  template <typename U>
  tmat3x3<T, P>& operator= (tmat3x3<U, P> const & m);
  template <typename U>
  tmat3x3<T, P>& operator+= (U s);
  template <typename U>
  tmat3x3<T, P>& operator+= (tmat3x3<U, P> const & m);
  template <typename U>
  tmat3x3<T, P>& operator-= (U s);
  template <typename U>
  tmat3x3<T, P>& operator-= (tmat3x3<U, P> const & m);
  template <typename U>
  tmat3x3<T, P>& operator*= (U s);
  template <typename U>
  tmat3x3<T, P>& operator*= (tmat3x3<U, P> const & m);
  template <typename U>
  tmat3x3<T, P>& operator/= (U s);
  template <typename U>
  tmat3x3<T, P>& operator/= (tmat3x3<U, P> const & m);




  tmat3x3<T, P> & operator++ ();
  tmat3x3<T, P> & operator-- ();
  tmat3x3<T, P> operator++(int);
  tmat3x3<T, P> operator--(int);
 };


 template <typename T, precision P>
 tmat3x3<T, P> operator+ (
  tmat3x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x3<T, P> operator+ (
  T const & s,
  tmat3x3<T, P> const & m);

 template <typename T, precision P>
 tmat3x3<T, P> operator+ (
  tmat3x3<T, P> const & m1,
  tmat3x3<T, P> const & m2);

 template <typename T, precision P>
 tmat3x3<T, P> operator- (
  tmat3x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x3<T, P> operator- (
  T const & s,
  tmat3x3<T, P> const & m);

 template <typename T, precision P>
 tmat3x3<T, P> operator- (
  tmat3x3<T, P> const & m1,
  tmat3x3<T, P> const & m2);

 template <typename T, precision P>
 tmat3x3<T, P> operator* (
  tmat3x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x3<T, P> operator* (
  T const & s,
  tmat3x3<T, P> const & m);

 template <typename T, precision P>
 typename tmat3x3<T, P>::col_type operator* (
  tmat3x3<T, P> const & m,
  typename tmat3x3<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat3x3<T, P>::row_type operator* (
  typename tmat3x3<T, P>::col_type const & v,
  tmat3x3<T, P> const & m);

 template <typename T, precision P>
 tmat3x3<T, P> operator* (
  tmat3x3<T, P> const & m1,
  tmat3x3<T, P> const & m2);

 template <typename T, precision P>
 tmat2x3<T, P> operator* (
  tmat3x3<T, P> const & m1,
  tmat2x3<T, P> const & m2);

 template <typename T, precision P>
 tmat4x3<T, P> operator* (
  tmat3x3<T, P> const & m1,
  tmat4x3<T, P> const & m2);

 template <typename T, precision P>
 tmat3x3<T, P> operator/ (
  tmat3x3<T, P> const & m,
  T const & s);

 template <typename T, precision P>
 tmat3x3<T, P> operator/ (
  T const & s,
  tmat3x3<T, P> const & m);

 template <typename T, precision P>
 typename tmat3x3<T, P>::col_type operator/ (
  tmat3x3<T, P> const & m,
  typename tmat3x3<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat3x3<T, P>::row_type operator/ (
  typename tmat3x3<T, P>::col_type const & v,
  tmat3x3<T, P> const & m);

 template <typename T, precision P>
 tmat3x3<T, P> operator/ (
  tmat3x3<T, P> const & m1,
  tmat3x3<T, P> const & m2);


 template <typename T, precision P>
 tmat3x3<T, P> const operator-(
  tmat3x3<T, P> const & m);
}


# 1 "../glm/gtx/../detail/type_mat3x3.inl" 1
# 33 "../glm/gtx/../detail/type_mat3x3.inl"
namespace glm{
namespace detail
{
 template <typename T, precision P>
 inline tmat3x3<T, P> compute_inverse(tmat3x3<T, P> const & m)
 {
  T OneOverDeterminant = static_cast<T>(1) / (
   + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
   - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
   + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]));

  tmat3x3<T, P> Inverse(uninitialize);
  Inverse[0][0] = + (m[1][1] * m[2][2] - m[2][1] * m[1][2]) * OneOverDeterminant;
  Inverse[1][0] = - (m[1][0] * m[2][2] - m[2][0] * m[1][2]) * OneOverDeterminant;
  Inverse[2][0] = + (m[1][0] * m[2][1] - m[2][0] * m[1][1]) * OneOverDeterminant;
  Inverse[0][1] = - (m[0][1] * m[2][2] - m[2][1] * m[0][2]) * OneOverDeterminant;
  Inverse[1][1] = + (m[0][0] * m[2][2] - m[2][0] * m[0][2]) * OneOverDeterminant;
  Inverse[2][1] = - (m[0][0] * m[2][1] - m[2][0] * m[0][1]) * OneOverDeterminant;
  Inverse[0][2] = + (m[0][1] * m[1][2] - m[1][1] * m[0][2]) * OneOverDeterminant;
  Inverse[1][2] = - (m[0][0] * m[1][2] - m[1][0] * m[0][2]) * OneOverDeterminant;
  Inverse[2][2] = + (m[0][0] * m[1][1] - m[1][0] * m[0][1]) * OneOverDeterminant;

  return Inverse;
 }
}




 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3()
 {

   this->value[0] = col_type(1, 0, 0);
   this->value[1] = col_type(0, 1, 0);
   this->value[2] = col_type(0, 0, 1);

 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3(ctor)
 {}

 template <typename T, precision P>
 template <precision Q>
 inline tmat3x3<T, P>::tmat3x3(tmat3x3<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3(T const & s)
 {
  this->value[0] = col_type(s, 0, 0);
  this->value[1] = col_type(0, s, 0);
  this->value[2] = col_type(0, 0, s);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3
 (
  T const & x0, T const & y0, T const & z0,
  T const & x1, T const & y1, T const & z1,
  T const & x2, T const & y2, T const & z2
 )
 {
  this->value[0] = col_type(x0, y0, z0);
  this->value[1] = col_type(x1, y1, z1);
  this->value[2] = col_type(x2, y2, z2);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3>
 inline tmat3x3<T, P>::tmat3x3
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1,
  X2 const & x2, Y2 const & y2, Z2 const & z2,
  X3 const & x3, Y3 const & y3, Z3 const & z3
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3>
 inline tmat3x3<T, P>::tmat3x3
 (
  tvec3<V1, P> const & v1,
  tvec3<V2, P> const & v2,
  tvec3<V3, P> const & v3
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
 }




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat3x3<T, P>::tmat3x3(tmat3x3<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(0, 0, 1);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3(tmat2x3<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = col_type(0, 0, 1);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 1);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0, 0, 1);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 1);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P>::tmat3x3(tmat4x3<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
 }
# 252 "../glm/gtx/../detail/type_mat3x3.inl"
  template <typename T, precision P>
  inline constexpr typename tmat3x3<T, P>::length_type tmat3x3<T, P>::length() const
  {
   return 3;
  }

  template <typename T, precision P>
  inline typename tmat3x3<T, P>::col_type & tmat3x3<T, P>::operator[](typename tmat3x3<T, P>::length_type i)
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat3x3.inl", 261, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }

  template <typename T, precision P>
  inline typename tmat3x3<T, P>::col_type const & tmat3x3<T, P>::operator[](typename tmat3x3<T, P>::length_type i) const
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat3x3.inl", 268, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }





 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator=(tmat3x3<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator+=(tmat3x3<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator-=(tmat3x3<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator*=(tmat3x3<U, P> const & m)
 {
  return (*this = *this * m);
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator/=(tmat3x3<U, P> const & m)
 {
  return (*this = *this * detail::compute_inverse<T, P>(m));
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> & tmat3x3<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> tmat3x3<T, P>::operator++(int)
 {
  tmat3x3<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> tmat3x3<T, P>::operator--(int)
 {
  tmat3x3<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline tmat3x3<T, P> operator+(tmat3x3<T, P> const & m, T const & s)
 {
  return tmat3x3<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator+(T const & s, tmat3x3<T, P> const & m)
 {
  return tmat3x3<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator+(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return tmat3x3<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator-(tmat3x3<T, P> const & m, T const & s)
 {
  return tmat3x3<T, P>(
   m[0] - s,
   m[1] - s,
   m[2] - s);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator-(T const & s, tmat3x3<T, P> const & m)
 {
  return tmat3x3<T, P>(
   s - m[0],
   s - m[1],
   s - m[2]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator-(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return tmat3x3<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator*(tmat3x3<T, P> const & m, T const & s)
 {
  return tmat3x3<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator*(T const & s, tmat3x3<T, P> const & m)
 {
  return tmat3x3<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T, precision P>
 inline typename tmat3x3<T, P>::col_type operator*(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v)
 {
  return typename tmat3x3<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z);
 }

 template <typename T, precision P>
 inline typename tmat3x3<T, P>::row_type operator*(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m)
 {
  return typename tmat3x3<T, P>::row_type(
   m[0][0] * v.x + m[0][1] * v.y + m[0][2] * v.z,
   m[1][0] * v.x + m[1][1] * v.y + m[1][2] * v.z,
   m[2][0] * v.x + m[2][1] * v.y + m[2][2] * v.z);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];

  tmat3x3<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  return Result;
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return tmat2x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2]);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator*(tmat3x3<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator/(tmat3x3<T, P> const & m, T const & s)
 {
  return tmat3x3<T, P>(
   m[0] / s,
   m[1] / s,
   m[2] / s);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator/(T const & s, tmat3x3<T, P> const & m)
 {
  return tmat3x3<T, P>(
   s / m[0],
   s / m[1],
   s / m[2]);
 }

 template <typename T, precision P>
 inline typename tmat3x3<T, P>::col_type operator/(tmat3x3<T, P> const & m, typename tmat3x3<T, P>::row_type const & v)
 {
  return detail::compute_inverse<T, P>(m) * v;
 }

 template <typename T, precision P>
 inline typename tmat3x3<T, P>::row_type operator/(typename tmat3x3<T, P>::col_type const & v, tmat3x3<T, P> const & m)
 {
  return v * detail::compute_inverse<T, P>(m);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator/(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  tmat3x3<T, P> m1_copy(m1);
  return m1_copy /= m2;
 }


 template <typename T, precision P>
 inline tmat3x3<T, P> const operator-(tmat3x3<T, P> const & m)
 {
  return tmat3x3<T, P>(
   -m[0],
   -m[1],
   -m[2]);
 }




 template <typename T, precision P>
 inline bool operator==(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T, precision P>
 inline bool operator!=(tmat3x3<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 264 "../glm/gtx/../detail/type_mat3x3.hpp" 2
# 36 "../glm/gtx/../mat3x3.hpp" 2

namespace glm
{





 typedef tmat3x3<float, lowp> lowp_mat3;






 typedef tmat3x3<float, mediump> mediump_mat3;






 typedef tmat3x3<float, highp> highp_mat3;






 typedef tmat3x3<float, lowp> lowp_mat3x3;






 typedef tmat3x3<float, mediump> mediump_mat3x3;






 typedef tmat3x3<float, highp> highp_mat3x3;

}
# 105 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../mat3x4.hpp" 1
# 33 "../glm/gtx/../mat3x4.hpp"
       

# 1 "../glm/gtx/../detail/type_mat3x4.hpp" 1
# 33 "../glm/gtx/../detail/type_mat3x4.hpp"
       
# 42 "../glm/gtx/../detail/type_mat3x4.hpp"
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat3x4
 {
  typedef tvec4<T, P> col_type;
  typedef tvec3<T, P> row_type;
  typedef tmat3x4<T, P> type;
  typedef tmat4x3<T, P> transpose_type;
  typedef T value_type;

 private:

  col_type value[3];


 public:

  tmat3x4();
  template <precision Q>
  tmat3x4(tmat3x4<T, Q> const & m);

  explicit tmat3x4(ctor);
  explicit tmat3x4(T const & s);
  tmat3x4(
   T const & x0, T const & y0, T const & z0, T const & w0,
   T const & x1, T const & y1, T const & z1, T const & w1,
   T const & x2, T const & y2, T const & z2, T const & w2);
  tmat3x4(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2);



  template<
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3>
  tmat3x4(
   X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
   X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
   X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3);

  template <typename V1, typename V2, typename V3>
  tmat3x4(
   tvec4<V1, P> const & v1,
   tvec4<V2, P> const & v2,
   tvec4<V3, P> const & v3);
# 99 "../glm/gtx/../detail/type_mat3x4.hpp"
   template <typename U, precision Q>
   tmat3x4(tmat3x4<U, Q> const & m);


  explicit tmat3x4(tmat2x2<T, P> const & x);
  explicit tmat3x4(tmat3x3<T, P> const & x);
  explicit tmat3x4(tmat4x4<T, P> const & x);
  explicit tmat3x4(tmat2x3<T, P> const & x);
  explicit tmat3x4(tmat3x2<T, P> const & x);
  explicit tmat3x4(tmat2x4<T, P> const & x);
  explicit tmat3x4(tmat4x2<T, P> const & x);
  explicit tmat3x4(tmat4x3<T, P> const & x);
# 122 "../glm/gtx/../detail/type_mat3x4.hpp"
   typedef length_t length_type;
   constexpr length_type length() const;

   col_type & operator[](length_type i);
   col_type const & operator[](length_type i) const;





  template <typename U>
  tmat3x4<T, P> & operator=(tmat3x4<U, P> const & m);
  template <typename U>
  tmat3x4<T, P> & operator+=(U s);
  template <typename U>
  tmat3x4<T, P> & operator+=(tmat3x4<U, P> const & m);
  template <typename U>
  tmat3x4<T, P> & operator-=(U s);
  template <typename U>
  tmat3x4<T, P> & operator-=(tmat3x4<U, P> const & m);
  template <typename U>
  tmat3x4<T, P> & operator*=(U s);
  template <typename U>
  tmat3x4<T, P> & operator/=(U s);




  tmat3x4<T, P> & operator++();
  tmat3x4<T, P> & operator--();
  tmat3x4<T, P> operator++(int);
  tmat3x4<T, P> operator--(int);
 };


 template <typename T, precision P>
 tmat3x4<T, P> operator+(tmat3x4<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat3x4<T, P> operator+(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
 tmat3x4<T, P> operator-(tmat3x4<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat3x4<T, P> operator-(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
 tmat3x4<T, P> operator*(tmat3x4<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat3x4<T, P> operator*(T const & s, tmat3x4<T, P> const & m);

 template <typename T, precision P>
 typename tmat3x4<T, P>::col_type operator*(tmat3x4<T, P> const & m, typename tmat3x4<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat3x4<T, P>::row_type operator*(typename tmat3x4<T, P>::col_type const & v, tmat3x4<T, P> const & m);

 template <typename T, precision P>
 tmat4x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat4x3<T, P> const & m2);

 template <typename T, precision P>
 tmat2x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat2x3<T, P> const & m2);

 template <typename T, precision P>
 tmat3x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat3x3<T, P> const & m2);

 template <typename T, precision P>
 tmat3x4<T, P> operator/(tmat3x4<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat3x4<T, P> operator/(T const & s, tmat3x4<T, P> const & m);


 template <typename T, precision P>
 tmat3x4<T, P> const operator-(tmat3x4<T, P> const & m);
}


# 1 "../glm/gtx/../detail/type_mat3x4.inl" 1
# 33 "../glm/gtx/../detail/type_mat3x4.inl"
namespace glm
{



 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4()
 {

   this->value[0] = col_type(1, 0, 0, 0);
   this->value[1] = col_type(0, 1, 0, 0);
   this->value[2] = col_type(0, 0, 1, 0);

 }

 template <typename T, precision P>
 template <precision Q>
 inline tmat3x4<T, P>::tmat3x4(tmat3x4<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4(ctor)
 {}

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4(T const & s)
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero, Zero, Zero);
  this->value[1] = col_type(Zero, s, Zero, Zero);
  this->value[2] = col_type(Zero, Zero, s, Zero);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4
 (
  T const & x0, T const & y0, T const & z0, T const & w0,
  T const & x1, T const & y1, T const & z1, T const & w1,
  T const & x2, T const & y2, T const & z2, T const & w2
 )
 {
  this->value[0] = col_type(x0, y0, z0, w0);
  this->value[1] = col_type(x1, y1, z1, w1);
  this->value[2] = col_type(x2, y2, z2, w2);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3>
 inline tmat3x4<T, P>::tmat3x4
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
  X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
  X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3>
 inline tmat3x4<T, P>::tmat3x4
 (
  tvec4<V1, P> const & v1,
  tvec4<V2, P> const & v2,
  tvec4<V3, P> const & v3
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
 }


 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat3x4<T, P>::tmat3x4(tmat3x4<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(0, 0, 1, 0);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 0);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(0, 0, 1, 0);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(m[2], 0, 1);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0, 0, 1, 0);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(m[2], 1, 0);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>::tmat3x4(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 0);
 }
# 227 "../glm/gtx/../detail/type_mat3x4.inl"
  template <typename T, precision P>
  inline constexpr typename tmat3x4<T, P>::length_type tmat3x4<T, P>::length() const
  {
   return 3;
  }

  template <typename T, precision P>
  inline typename tmat3x4<T, P>::col_type & tmat3x4<T, P>::operator[](typename tmat3x4<T, P>::length_type i)
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat3x4.inl", 236, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }

  template <typename T, precision P>
  inline typename tmat3x4<T, P>::col_type const & tmat3x4<T, P>::operator[](typename tmat3x4<T, P>::length_type i) const
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat3x4.inl", 243, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }





 template <typename T, precision P>
 template <typename U>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator=(tmat3x4<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator+=(tmat3x4<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator-=(tmat3x4<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat3x4<T, P> & tmat3x4<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  return *this;
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  return *this;
 }

 template <typename T, precision P>
 inline tmat3x4<T, P>& tmat3x4<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  return *this;
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> tmat3x4<T, P>::operator++(int)
 {
  tmat3x4<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> tmat3x4<T, P>::operator--(int)
 {
  tmat3x4<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline tmat3x4<T, P> operator+(tmat3x4<T, P> const & m, T const & s)
 {
  return tmat3x4<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator+(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return tmat3x4<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2]);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator-(tmat3x4<T, P> const & m, T const & s)
 {
  return tmat3x4<T, P>(
   m[0] - s,
   m[1] - s,
   m[2] - s);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator-(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return tmat3x4<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2]);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator*(tmat3x4<T, P> const & m, T const & s)
 {
  return tmat3x4<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator*(T const & s, tmat3x4<T, P> const & m)
 {
  return tmat3x4<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s);
 }

 template <typename T, precision P>
 inline typename tmat3x4<T, P>::col_type operator*
 (
  tmat3x4<T, P> const & m,
  typename tmat3x4<T, P>::row_type const & v
 )
 {
  return typename tmat3x4<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z,
   m[0][3] * v.x + m[1][3] * v.y + m[2][3] * v.z);
 }

 template <typename T, precision P>
 inline typename tmat3x4<T, P>::row_type operator*
 (
  typename tmat3x4<T, P>::col_type const & v,
  tmat3x4<T, P> const & m
 )
 {
  return typename tmat3x4<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2] + v.w * m[0][3],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2] + v.w * m[1][3],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2] + v.w * m[2][3]);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  const T SrcA00 = m1[0][0];
  const T SrcA01 = m1[0][1];
  const T SrcA02 = m1[0][2];
  const T SrcA03 = m1[0][3];
  const T SrcA10 = m1[1][0];
  const T SrcA11 = m1[1][1];
  const T SrcA12 = m1[1][2];
  const T SrcA13 = m1[1][3];
  const T SrcA20 = m1[2][0];
  const T SrcA21 = m1[2][1];
  const T SrcA22 = m1[2][2];
  const T SrcA23 = m1[2][3];

  const T SrcB00 = m2[0][0];
  const T SrcB01 = m2[0][1];
  const T SrcB02 = m2[0][2];
  const T SrcB10 = m2[1][0];
  const T SrcB11 = m2[1][1];
  const T SrcB12 = m2[1][2];
  const T SrcB20 = m2[2][0];
  const T SrcB21 = m2[2][1];
  const T SrcB22 = m2[2][2];
  const T SrcB30 = m2[3][0];
  const T SrcB31 = m2[3][1];
  const T SrcB32 = m2[3][2];

  tmat4x4<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02;
  Result[0][3] = SrcA03 * SrcB00 + SrcA13 * SrcB01 + SrcA23 * SrcB02;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12;
  Result[1][3] = SrcA03 * SrcB10 + SrcA13 * SrcB11 + SrcA23 * SrcB12;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22;
  Result[2][3] = SrcA03 * SrcB20 + SrcA13 * SrcB21 + SrcA23 * SrcB22;
  Result[3][0] = SrcA00 * SrcB30 + SrcA10 * SrcB31 + SrcA20 * SrcB32;
  Result[3][1] = SrcA01 * SrcB30 + SrcA11 * SrcB31 + SrcA21 * SrcB32;
  Result[3][2] = SrcA02 * SrcB30 + SrcA12 * SrcB31 + SrcA22 * SrcB32;
  Result[3][3] = SrcA03 * SrcB30 + SrcA13 * SrcB31 + SrcA23 * SrcB32;
  return Result;
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat2x3<T, P> const & m2)
 {
  return tmat2x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2]);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator*(tmat3x4<T, P> const & m1, tmat3x3<T, P> const & m2)
 {
  return tmat3x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2]);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator/(tmat3x4<T, P> const & m, T const & s)
 {
  return tmat3x4<T, P>(
   m[0] / s,
   m[1] / s,
   m[2] / s);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator/(T const & s, tmat3x4<T, P> const & m)
 {
  return tmat3x4<T, P>(
   s / m[0],
   s / m[1],
   s / m[2]);
 }


 template <typename T, precision P>
 inline tmat3x4<T, P> const operator-(tmat3x4<T, P> const & m)
 {
  return tmat3x4<T, P>(
   -m[0],
   -m[1],
   -m[2]);
 }




 template <typename T, precision P>
 inline bool operator==(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]);
 }

 template <typename T, precision P>
 inline bool operator!=(tmat3x4<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]);
 }
}
# 203 "../glm/gtx/../detail/type_mat3x4.hpp" 2
# 36 "../glm/gtx/../mat3x4.hpp" 2

namespace glm
{





 typedef tmat3x4<float, lowp> lowp_mat3x4;






 typedef tmat3x4<float, mediump> mediump_mat3x4;






 typedef tmat3x4<float, highp> highp_mat3x4;

}
# 106 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../mat4x2.hpp" 1
# 33 "../glm/gtx/../mat4x2.hpp"
       

# 1 "../glm/gtx/../detail/type_mat4x2.hpp" 1
# 33 "../glm/gtx/../detail/type_mat4x2.hpp"
       
# 42 "../glm/gtx/../detail/type_mat4x2.hpp"
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat4x2
 {
  typedef tvec2<T, P> col_type;
  typedef tvec4<T, P> row_type;
  typedef tmat4x2<T, P> type;
  typedef tmat2x4<T, P> transpose_type;
  typedef T value_type;

 private:

  col_type value[4];


 public:

  tmat4x2();
  template <precision Q>
  tmat4x2(tmat4x2<T, Q> const & m);

  explicit tmat4x2(ctor);
  explicit tmat4x2(T const & x);
  tmat4x2(
   T const & x0, T const & y0,
   T const & x1, T const & y1,
   T const & x2, T const & y2,
   T const & x3, T const & y3);
  tmat4x2(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);




  template <
   typename X1, typename Y1,
   typename X2, typename Y2,
   typename X3, typename Y3,
   typename X4, typename Y4>
  tmat4x2(
   X1 const & x1, Y1 const & y1,
   X2 const & x2, Y2 const & y2,
   X3 const & x3, Y3 const & y3,
   X4 const & x4, Y4 const & y4);

  template <typename V1, typename V2, typename V3, typename V4>
  tmat4x2(
   tvec2<V1, P> const & v1,
   tvec2<V2, P> const & v2,
   tvec2<V3, P> const & v3,
   tvec2<V4, P> const & v4);
# 105 "../glm/gtx/../detail/type_mat4x2.hpp"
   template <typename U, precision Q>
   tmat4x2(tmat4x2<U, Q> const & m);


  explicit tmat4x2(tmat2x2<T, P> const & x);
  explicit tmat4x2(tmat3x3<T, P> const & x);
  explicit tmat4x2(tmat4x4<T, P> const & x);
  explicit tmat4x2(tmat2x3<T, P> const & x);
  explicit tmat4x2(tmat3x2<T, P> const & x);
  explicit tmat4x2(tmat2x4<T, P> const & x);
  explicit tmat4x2(tmat4x3<T, P> const & x);
  explicit tmat4x2(tmat3x4<T, P> const & x);
# 128 "../glm/gtx/../detail/type_mat4x2.hpp"
   typedef length_t length_type;
   constexpr length_type length() const;

   col_type & operator[](length_type i);
   col_type const & operator[](length_type i) const;





  template <typename U>
  tmat4x2<T, P>& operator=(tmat4x2<U, P> const & m);
  template <typename U>
  tmat4x2<T, P>& operator+=(U s);
  template <typename U>
  tmat4x2<T, P>& operator+=(tmat4x2<U, P> const & m);
  template <typename U>
  tmat4x2<T, P>& operator-=(U s);
  template <typename U>
  tmat4x2<T, P>& operator-=(tmat4x2<U, P> const & m);
  template <typename U>
  tmat4x2<T, P>& operator*=(U s);
  template <typename U>
  tmat4x2<T, P>& operator/=(U s);




  tmat4x2<T, P> & operator++ ();
  tmat4x2<T, P> & operator-- ();
  tmat4x2<T, P> operator++(int);
  tmat4x2<T, P> operator--(int);
 };


 template <typename T, precision P>
 tmat4x2<T, P> operator+(tmat4x2<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat4x2<T, P> operator+(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2);

 template <typename T, precision P>
 tmat4x2<T, P> operator-(tmat4x2<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat4x2<T, P> operator-(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2);

 template <typename T, precision P>
 tmat4x2<T, P> operator*(tmat4x2<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat4x2<T, P> operator*(T const & s, tmat4x2<T, P> const & m);

 template <typename T, precision P>
 typename tmat4x2<T, P>::col_type operator*(tmat4x2<T, P> const & m, typename tmat4x2<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat4x2<T, P>::row_type operator*(typename tmat4x2<T, P>::col_type const & v, tmat4x2<T, P> const & m);

 template <typename T, precision P>
 tmat3x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
 tmat4x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
 tmat2x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat2x4<T, P> const & m2);

 template <typename T, precision P>
 tmat4x2<T, P> operator/(tmat4x2<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat4x2<T, P> operator/(T const & s, tmat4x2<T, P> const & m);


 template <typename T, precision P>
 tmat4x2<T, P> const operator-(tmat4x2<T, P> const & m);
}


# 1 "../glm/gtx/../detail/type_mat4x2.inl" 1
# 33 "../glm/gtx/../detail/type_mat4x2.inl"
namespace glm
{



 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2()
 {

   this->value[0] = col_type(1, 0);
   this->value[1] = col_type(0, 1);
   this->value[2] = col_type(0, 0);
   this->value[3] = col_type(0, 0);

 }

 template <typename T, precision P>
 template <precision Q>
 inline tmat4x2<T, P>::tmat4x2(tmat4x2<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
  this->value[3] = m.value[3];
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2(ctor)
 {}

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2(T const & s)
 {
  value_type const Zero(0);
  this->value[0] = col_type(s, Zero);
  this->value[1] = col_type(Zero, s);
  this->value[2] = col_type(Zero, Zero);
  this->value[3] = col_type(Zero, Zero);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2
 (
  T const & x0, T const & y0,
  T const & x1, T const & y1,
  T const & x2, T const & y2,
  T const & x3, T const & y3
 )
 {
  this->value[0] = col_type(x0, y0);
  this->value[1] = col_type(x1, y1);
  this->value[2] = col_type(x2, y2);
  this->value[3] = col_type(x3, y3);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2,
  col_type const & v3
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
  this->value[3] = v3;
 }




 template <typename T, precision P>
 template <
  typename X1, typename Y1,
  typename X2, typename Y2,
  typename X3, typename Y3,
  typename X4, typename Y4>
 inline tmat4x2<T, P>::tmat4x2
 (
  X1 const & x1, Y1 const & y1,
  X2 const & x2, Y2 const & y2,
  X3 const & x3, Y3 const & y3,
  X4 const & x4, Y4 const & y4
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3));
  this->value[3] = col_type(static_cast<T>(x4), value_type(y4));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3, typename V4>
 inline tmat4x2<T, P>::tmat4x2
 (
  tvec2<V1, P> const & v1,
  tvec2<V2, P> const & v2,
  tvec2<V3, P> const & v3,
  tvec2<V4, P> const & v4
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }



 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat4x2<T, P>::tmat4x2(tmat4x2<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P>::tmat4x2(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(0);
 }
# 250 "../glm/gtx/../detail/type_mat4x2.inl"
  template <typename T, precision P>
  inline constexpr typename tmat4x2<T, P>::length_type tmat4x2<T, P>::length() const
  {
   return 4;
  }

  template <typename T, precision P>
  inline typename tmat4x2<T, P>::col_type & tmat4x2<T, P>::operator[](typename tmat4x2<T, P>::length_type i)
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat4x2.inl", 259, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }

  template <typename T, precision P>
  inline typename tmat4x2<T, P>::col_type const & tmat4x2<T, P>::operator[](typename tmat4x2<T, P>::length_type i) const
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat4x2.inl", 266, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }





 template <typename T, precision P>
 template <typename U>
 inline tmat4x2<T, P>& tmat4x2<T, P>::operator=(tmat4x2<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x2<T, P> & tmat4x2<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x2<T, P> & tmat4x2<T, P>::operator+=(tmat4x2<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x2<T, P> & tmat4x2<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x2<T, P> & tmat4x2<T, P>::operator-=(tmat4x2<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x2<T, P> & tmat4x2<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x2<T, P> & tmat4x2<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> & tmat4x2<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> & tmat4x2<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> tmat4x2<T, P>::operator++(int)
 {
  tmat4x2<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> tmat4x2<T, P>::operator--(int)
 {
  tmat4x2<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline tmat4x2<T, P> operator+(tmat4x2<T, P> const & m, T const & s)
 {
  return tmat4x2<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator+(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return tmat4x2<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator-(tmat4x2<T, P> const & m, T const & s)
 {
  return tmat4x2<T, P>(
   m[0] - s,
   m[1] - s,
   m[2] - s,
   m[3] - s);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator-(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return tmat4x2<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator*(tmat4x2<T, P> const & m, T const & s)
 {
  return tmat4x2<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator*(T const & s, tmat4x2<T, P> const & m)
 {
  return tmat4x2<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P>
 inline typename tmat4x2<T, P>::col_type operator*(tmat4x2<T, P> const & m, typename tmat4x2<T, P>::row_type const & v)
 {
  return typename tmat4x2<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w);
 }

 template <typename T, precision P>
 inline typename tmat4x2<T, P>::row_type operator*(typename tmat4x2<T, P>::col_type const & v, tmat4x2<T, P> const & m)
 {
  return typename tmat4x2<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1],
   v.x * m[1][0] + v.y * m[1][1],
   v.x * m[2][0] + v.y * m[2][1],
   v.x * m[3][0] + v.y * m[3][1]);
 }

 template <typename T, precision P>
 inline tmat2x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];

  tmat2x2<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  return Result;
 }

 template <typename T, precision P>
 inline tmat3x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return tmat3x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator*(tmat4x2<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return tmat4x2<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3]);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator/(tmat4x2<T, P> const & m, T const & s)
 {
  return tmat4x2<T, P>(
   m[0] / s,
   m[1] / s,
   m[2] / s,
   m[3] / s);
 }

 template <typename T, precision P>
 inline tmat4x2<T, P> operator/(T const & s, tmat4x2<T, P> const & m)
 {
  return tmat4x2<T, P>(
   s / m[0],
   s / m[1],
   s / m[2],
   s / m[3]);
 }


 template <typename T, precision P>
 inline tmat4x2<T, P> const operator-(tmat4x2<T, P> const & m)
 {
  return tmat4x2<T, P>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }




 template <typename T, precision P>
 inline bool operator==(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T, precision P>
 inline bool operator!=(tmat4x2<T, P> const & m1, tmat4x2<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 209 "../glm/gtx/../detail/type_mat4x2.hpp" 2
# 36 "../glm/gtx/../mat4x2.hpp" 2

namespace glm
{





 typedef tmat4x2<float, lowp> lowp_mat4x2;






 typedef tmat4x2<float, mediump> mediump_mat4x2;






 typedef tmat4x2<float, highp> highp_mat4x2;

}
# 107 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../mat4x3.hpp" 1
# 33 "../glm/gtx/../mat4x3.hpp"
       

# 1 "../glm/gtx/../detail/type_mat4x3.hpp" 1
# 33 "../glm/gtx/../detail/type_mat4x3.hpp"
       
# 42 "../glm/gtx/../detail/type_mat4x3.hpp"
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat4x3
 {
  typedef tvec3<T, P> col_type;
  typedef tvec4<T, P> row_type;
  typedef tmat4x3<T, P> type;
  typedef tmat3x4<T, P> transpose_type;
  typedef T value_type;

 private:

  col_type value[4];

 public:

  tmat4x3();
  template <precision Q>
  tmat4x3(tmat4x3<T, Q> const & m);

  explicit tmat4x3(ctor);
  explicit tmat4x3(T const & x);
  tmat4x3(
   T const & x0, T const & y0, T const & z0,
   T const & x1, T const & y1, T const & z1,
   T const & x2, T const & y2, T const & z2,
   T const & x3, T const & y3, T const & z3);
  tmat4x3(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);




  template <
   typename X1, typename Y1, typename Z1,
   typename X2, typename Y2, typename Z2,
   typename X3, typename Y3, typename Z3,
   typename X4, typename Y4, typename Z4>
  tmat4x3(
   X1 const & x1, Y1 const & y1, Z1 const & z1,
   X2 const & x2, Y2 const & y2, Z2 const & z2,
   X3 const & x3, Y3 const & y3, Z3 const & z3,
   X4 const & x4, Y4 const & y4, Z4 const & z4);

  template <typename V1, typename V2, typename V3, typename V4>
  tmat4x3(
   tvec3<V1, P> const & v1,
   tvec3<V2, P> const & v2,
   tvec3<V3, P> const & v3,
   tvec3<V4, P> const & v4);
# 104 "../glm/gtx/../detail/type_mat4x3.hpp"
   template <typename U, precision Q>
   tmat4x3(tmat4x3<U, Q> const & m);


  explicit tmat4x3(tmat2x2<T, P> const & x);
  explicit tmat4x3(tmat3x3<T, P> const & x);
  explicit tmat4x3(tmat4x4<T, P> const & x);
  explicit tmat4x3(tmat2x3<T, P> const & x);
  explicit tmat4x3(tmat3x2<T, P> const & x);
  explicit tmat4x3(tmat2x4<T, P> const & x);
  explicit tmat4x3(tmat4x2<T, P> const & x);
  explicit tmat4x3(tmat3x4<T, P> const & x);
# 127 "../glm/gtx/../detail/type_mat4x3.hpp"
   typedef length_t length_type;
   constexpr length_type length() const;

   col_type & operator[](length_type i);
   col_type const & operator[](length_type i) const;





  template <typename U>
  tmat4x3<T, P> & operator=(tmat4x3<U, P> const & m);
  template <typename U>
  tmat4x3<T, P> & operator+=(U s);
  template <typename U>
  tmat4x3<T, P> & operator+=(tmat4x3<U, P> const & m);
  template <typename U>
  tmat4x3<T, P> & operator-=(U s);
  template <typename U>
  tmat4x3<T, P> & operator-=(tmat4x3<U, P> const & m);
  template <typename U>
  tmat4x3<T, P> & operator*=(U s);
  template <typename U>
  tmat4x3<T, P> & operator/=(U s);




  tmat4x3<T, P> & operator++();
  tmat4x3<T, P> & operator--();
  tmat4x3<T, P> operator++(int);
  tmat4x3<T, P> operator--(int);
 };


 template <typename T, precision P>
 tmat4x3<T, P> operator+(tmat4x3<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat4x3<T, P> operator+(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2);

 template <typename T, precision P>
 tmat4x3<T, P> operator-(tmat4x3<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat4x3<T, P> operator-(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2);

 template <typename T, precision P>
 tmat4x3<T, P> operator*(tmat4x3<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat4x3<T, P> operator*(T const & s, tmat4x3<T, P> const & m);

 template <typename T, precision P>
 typename tmat4x3<T, P>::col_type operator*(tmat4x3<T, P> const & m, typename tmat4x3<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat4x3<T, P>::row_type operator*(typename tmat4x3<T, P>::col_type const & v, tmat4x3<T, P> const & m);

 template <typename T, precision P>
 tmat2x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat2x4<T, P> const & m2);

 template <typename T, precision P>
 tmat3x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
 tmat4x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
 tmat4x3<T, P> operator/(tmat4x3<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat4x3<T, P> operator/(T const & s, tmat4x3<T, P> const & m);


 template <typename T, precision P>
 tmat4x3<T, P> const operator-(tmat4x3<T, P> const & m);
}


# 1 "../glm/gtx/../detail/type_mat4x3.inl" 1
# 33 "../glm/gtx/../detail/type_mat4x3.inl"
namespace glm
{



 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3()
 {

   this->value[0] = col_type(1, 0, 0);
   this->value[1] = col_type(0, 1, 0);
   this->value[2] = col_type(0, 0, 1);
   this->value[3] = col_type(0, 0, 0);

 }

 template <typename T, precision P>
 template <precision Q>
 inline tmat4x3<T, P>::tmat4x3(tmat4x3<T, Q> const & m)
 {
  this->value[0] = m.value[0];
  this->value[1] = m.value[1];
  this->value[2] = m.value[2];
  this->value[3] = m.value[3];
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3(ctor)
 {}

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3(T const & s)
 {
  this->value[0] = col_type(s, 0, 0);
  this->value[1] = col_type(0, s, 0);
  this->value[2] = col_type(0, 0, s);
  this->value[3] = col_type(0, 0, 0);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3
 (
  T const & x0, T const & y0, T const & z0,
  T const & x1, T const & y1, T const & z1,
  T const & x2, T const & y2, T const & z2,
  T const & x3, T const & y3, T const & z3
 )
 {
  this->value[0] = col_type(x0, y0, z0);
  this->value[1] = col_type(x1, y1, z1);
  this->value[2] = col_type(x2, y2, z2);
  this->value[3] = col_type(x3, y3, z3);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2,
  col_type const & v3
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
  this->value[3] = v3;
 }




 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1,
  typename X2, typename Y2, typename Z2,
  typename X3, typename Y3, typename Z3,
  typename X4, typename Y4, typename Z4>
 inline tmat4x3<T, P>::tmat4x3
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1,
  X2 const & x2, Y2 const & y2, Z2 const & z2,
  X3 const & x3, Y3 const & y3, Z3 const & z3,
  X4 const & x4, Y4 const & y4, Z4 const & z4
 )
 {
  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3));
  this->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3, typename V4>
 inline tmat4x3<T, P>::tmat4x3
 (
  tvec3<V1, P> const & v1,
  tvec3<V2, P> const & v2,
  tvec3<V3, P> const & v3,
  tvec3<V4, P> const & v4
 )
 {
  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat4x3<T, P>::tmat4x3(tmat4x3<U, Q> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 1);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3(tmat4x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0, 0, 1);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 1);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3(tmat2x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(0, 0, 1);
  this->value[3] = col_type(0);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 1);
  this->value[3] = col_type(m[3], 0);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P>::tmat4x3(tmat3x4<T, P> const & m)
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(0);
 }
# 250 "../glm/gtx/../detail/type_mat4x3.inl"
  template <typename T, precision P>
  inline constexpr typename tmat4x3<T, P>::length_type tmat4x3<T, P>::length() const
  {
   return 4;
  }

  template <typename T, precision P>
  inline typename tmat4x3<T, P>::col_type & tmat4x3<T, P>::operator[](typename tmat4x3<T, P>::length_type i)
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat4x3.inl", 259, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }

  template <typename T, precision P>
  inline typename tmat4x3<T, P>::col_type const & tmat4x3<T, P>::operator[](typename tmat4x3<T, P>::length_type i) const
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat4x3.inl", 266, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }





 template <typename T, precision P>
 template <typename U>
 inline tmat4x3<T, P>& tmat4x3<T, P>::operator=(tmat4x3<U, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x3<T, P> & tmat4x3<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x3<T, P> & tmat4x3<T, P>::operator+=(tmat4x3<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x3<T, P> & tmat4x3<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x3<T, P> & tmat4x3<T, P>::operator-=(tmat4x3<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x3<T, P> & tmat4x3<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x3<T, P> & tmat4x3<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> & tmat4x3<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> & tmat4x3<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }




 template <typename T, precision P>
 inline tmat4x3<T, P> operator+(tmat4x3<T, P> const & m, T const & s)
 {
  return tmat4x3<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator+(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator-(tmat4x3<T, P> const & m, T const & s)
 {
  return tmat4x3<T, P>(
   m[0] - s,
   m[1] - s,
   m[2] - s,
   m[3] - s);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator-(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator*(tmat4x3<T, P> const & m, T const & s)
 {
  return tmat4x3<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator*(T const & s, tmat4x3<T, P> const & m)
 {
  return tmat4x3<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P>
 inline typename tmat4x3<T, P>::col_type operator*
 (
  tmat4x3<T, P> const & m,
  typename tmat4x3<T, P>::row_type const & v)
 {
  return typename tmat4x3<T, P>::col_type(
   m[0][0] * v.x + m[1][0] * v.y + m[2][0] * v.z + m[3][0] * v.w,
   m[0][1] * v.x + m[1][1] * v.y + m[2][1] * v.z + m[3][1] * v.w,
   m[0][2] * v.x + m[1][2] * v.y + m[2][2] * v.z + m[3][2] * v.w);
 }

 template <typename T, precision P>
 inline typename tmat4x3<T, P>::row_type operator*
 (
  typename tmat4x3<T, P>::col_type const & v,
  tmat4x3<T, P> const & m)
 {
  return typename tmat4x3<T, P>::row_type(
   v.x * m[0][0] + v.y * m[0][1] + v.z * m[0][2],
   v.x * m[1][0] + v.y * m[1][1] + v.z * m[1][2],
   v.x * m[2][0] + v.y * m[2][1] + v.z * m[2][2],
   v.x * m[3][0] + v.y * m[3][1] + v.z * m[3][2]);
 }

 template <typename T, precision P>
 inline tmat2x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return tmat2x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3]);
 }

 template <typename T, precision P>
 inline tmat3x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  T const SrcA00 = m1[0][0];
  T const SrcA01 = m1[0][1];
  T const SrcA02 = m1[0][2];
  T const SrcA10 = m1[1][0];
  T const SrcA11 = m1[1][1];
  T const SrcA12 = m1[1][2];
  T const SrcA20 = m1[2][0];
  T const SrcA21 = m1[2][1];
  T const SrcA22 = m1[2][2];
  T const SrcA30 = m1[3][0];
  T const SrcA31 = m1[3][1];
  T const SrcA32 = m1[3][2];

  T const SrcB00 = m2[0][0];
  T const SrcB01 = m2[0][1];
  T const SrcB02 = m2[0][2];
  T const SrcB03 = m2[0][3];
  T const SrcB10 = m2[1][0];
  T const SrcB11 = m2[1][1];
  T const SrcB12 = m2[1][2];
  T const SrcB13 = m2[1][3];
  T const SrcB20 = m2[2][0];
  T const SrcB21 = m2[2][1];
  T const SrcB22 = m2[2][2];
  T const SrcB23 = m2[2][3];

  tmat3x3<T, P> Result(uninitialize);
  Result[0][0] = SrcA00 * SrcB00 + SrcA10 * SrcB01 + SrcA20 * SrcB02 + SrcA30 * SrcB03;
  Result[0][1] = SrcA01 * SrcB00 + SrcA11 * SrcB01 + SrcA21 * SrcB02 + SrcA31 * SrcB03;
  Result[0][2] = SrcA02 * SrcB00 + SrcA12 * SrcB01 + SrcA22 * SrcB02 + SrcA32 * SrcB03;
  Result[1][0] = SrcA00 * SrcB10 + SrcA10 * SrcB11 + SrcA20 * SrcB12 + SrcA30 * SrcB13;
  Result[1][1] = SrcA01 * SrcB10 + SrcA11 * SrcB11 + SrcA21 * SrcB12 + SrcA31 * SrcB13;
  Result[1][2] = SrcA02 * SrcB10 + SrcA12 * SrcB11 + SrcA22 * SrcB12 + SrcA32 * SrcB13;
  Result[2][0] = SrcA00 * SrcB20 + SrcA10 * SrcB21 + SrcA20 * SrcB22 + SrcA30 * SrcB23;
  Result[2][1] = SrcA01 * SrcB20 + SrcA11 * SrcB21 + SrcA21 * SrcB22 + SrcA31 * SrcB23;
  Result[2][2] = SrcA02 * SrcB20 + SrcA12 * SrcB21 + SrcA22 * SrcB22 + SrcA32 * SrcB23;
  return Result;
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator*(tmat4x3<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return tmat4x3<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][0] * m2[3][0] + m1[1][0] * m2[3][1] + m1[2][0] * m2[3][2] + m1[3][0] * m2[3][3],
   m1[0][1] * m2[3][0] + m1[1][1] * m2[3][1] + m1[2][1] * m2[3][2] + m1[3][1] * m2[3][3],
   m1[0][2] * m2[3][0] + m1[1][2] * m2[3][1] + m1[2][2] * m2[3][2] + m1[3][2] * m2[3][3]);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator/(tmat4x3<T, P> const & m, T const & s)
 {
  return tmat4x3<T, P>(
   m[0] / s,
   m[1] / s,
   m[2] / s,
   m[3] / s);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> operator/(T const & s, tmat4x3<T, P> const & m)
 {
  return tmat4x3<T, P>(
   s / m[0],
   s / m[1],
   s / m[2],
   s / m[3]);
 }


 template <typename T, precision P>
 inline tmat4x3<T, P> const operator-(tmat4x3<T, P> const & m)
 {
  return tmat4x3<T, P>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> const operator++(tmat4x3<T, P> const & m, int)
 {
  return tmat4x3<T, P>(
   m[0] + T(1),
   m[1] + T(1),
   m[2] + T(1),
   m[3] + T(1));
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> const operator--(tmat4x3<T, P> const & m, int)
 {
  return tmat4x3<T, P>(
   m[0] - T(1),
   m[1] - T(1),
   m[2] - T(1),
   m[3] - T(1));
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> tmat4x3<T, P>::operator++(int)
 {
  tmat4x3<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat4x3<T, P> tmat4x3<T, P>::operator--(int)
 {
  tmat4x3<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline bool operator==(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T, precision P>
 inline bool operator!=(tmat4x3<T, P> const & m1, tmat4x3<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 208 "../glm/gtx/../detail/type_mat4x3.hpp" 2
# 36 "../glm/gtx/../mat4x3.hpp" 2

namespace glm
{





 typedef tmat4x3<float, lowp> lowp_mat4x3;






 typedef tmat4x3<float, mediump> mediump_mat4x3;






 typedef tmat4x3<float, highp> highp_mat4x3;

}
# 108 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../mat4x4.hpp" 1
# 33 "../glm/gtx/../mat4x4.hpp"
       

# 1 "../glm/gtx/../detail/type_mat4x4.hpp" 1
# 33 "../glm/gtx/../detail/type_mat4x4.hpp"
       







namespace glm
{
 template <typename T, precision P = defaultp>
 struct tmat4x4
 {
  typedef tvec4<T, P> col_type;
  typedef tvec4<T, P> row_type;
  typedef tmat4x4<T, P> type;
  typedef tmat4x4<T, P> transpose_type;
  typedef T value_type;

  template <typename U, precision Q>
  friend tvec4<U, Q> operator/(tmat4x4<U, Q> const & m, tvec4<U, Q> const & v);
  template <typename U, precision Q>
  friend tvec4<U, Q> operator/(tvec4<U, Q> const & v, tmat4x4<U, Q> const & m);

 private:

  col_type value[4];


 public:

  tmat4x4();
  template <precision Q>
  tmat4x4(tmat4x4<T, Q> const & m);

  explicit tmat4x4(ctor);
  explicit tmat4x4(T const & x);
  tmat4x4(
   T const & x0, T const & y0, T const & z0, T const & w0,
   T const & x1, T const & y1, T const & z1, T const & w1,
   T const & x2, T const & y2, T const & z2, T const & w2,
   T const & x3, T const & y3, T const & z3, T const & w3);
  tmat4x4(
   col_type const & v0,
   col_type const & v1,
   col_type const & v2,
   col_type const & v3);




  template <
   typename X1, typename Y1, typename Z1, typename W1,
   typename X2, typename Y2, typename Z2, typename W2,
   typename X3, typename Y3, typename Z3, typename W3,
   typename X4, typename Y4, typename Z4, typename W4>
  tmat4x4(
   X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
   X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
   X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,
   X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4);

  template <typename V1, typename V2, typename V3, typename V4>
  tmat4x4(
   tvec4<V1, P> const & v1,
   tvec4<V2, P> const & v2,
   tvec4<V3, P> const & v3,
   tvec4<V4, P> const & v4);
# 109 "../glm/gtx/../detail/type_mat4x4.hpp"
   template <typename U, precision Q>
   tmat4x4(tmat4x4<U, Q> const & m);


  explicit tmat4x4(tmat2x2<T, P> const & x);
  explicit tmat4x4(tmat3x3<T, P> const & x);
  explicit tmat4x4(tmat2x3<T, P> const & x);
  explicit tmat4x4(tmat3x2<T, P> const & x);
  explicit tmat4x4(tmat2x4<T, P> const & x);
  explicit tmat4x4(tmat4x2<T, P> const & x);
  explicit tmat4x4(tmat3x4<T, P> const & x);
  explicit tmat4x4(tmat4x3<T, P> const & x);
# 132 "../glm/gtx/../detail/type_mat4x4.hpp"
   typedef length_t length_type;
   constexpr length_type length() const;

   col_type & operator[](length_type i);
   col_type const & operator[](length_type i) const;





  template <typename U>
  tmat4x4<T, P> & operator=(tmat4x4<U, P> const & m);
  template <typename U>
  tmat4x4<T, P> & operator+=(U s);
  template <typename U>
  tmat4x4<T, P> & operator+=(tmat4x4<U, P> const & m);
  template <typename U>
  tmat4x4<T, P> & operator-=(U s);
  template <typename U>
  tmat4x4<T, P> & operator-=(tmat4x4<U, P> const & m);
  template <typename U>
  tmat4x4<T, P> & operator*=(U s);
  template <typename U>
  tmat4x4<T, P> & operator*=(tmat4x4<U, P> const & m);
  template <typename U>
  tmat4x4<T, P> & operator/=(U s);
  template <typename U>
  tmat4x4<T, P> & operator/=(tmat4x4<U, P> const & m);




  tmat4x4<T, P> & operator++();
  tmat4x4<T, P> & operator--();
  tmat4x4<T, P> operator++(int);
  tmat4x4<T, P> operator--(int);
 };


 template <typename T, precision P>
 tmat4x4<T, P> operator+(tmat4x4<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat4x4<T, P> operator+(T const & s, tmat4x4<T, P> const & m);

 template <typename T, precision P>
 tmat4x4<T, P> operator+(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
 tmat4x4<T, P> operator-(tmat4x4<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat4x4<T, P> operator-(T const & s, tmat4x4<T, P> const & m);

 template <typename T, precision P>
 tmat4x4<T, P> operator-(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
 tmat4x4<T, P> operator*(tmat4x4<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat4x4<T, P> operator*(T const & s, tmat4x4<T, P> const & m);

 template <typename T, precision P>
 typename tmat4x4<T, P>::col_type operator*(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat4x4<T, P>::row_type operator*(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m);

 template <typename T, precision P>
 tmat2x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat2x4<T, P> const & m2);

 template <typename T, precision P>
 tmat3x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat3x4<T, P> const & m2);

 template <typename T, precision P>
 tmat4x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);

 template <typename T, precision P>
 tmat4x4<T, P> operator/(tmat4x4<T, P> const & m, T const & s);

 template <typename T, precision P>
 tmat4x4<T, P> operator/(T const & s, tmat4x4<T, P> const & m);

 template <typename T, precision P>
 typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v);

 template <typename T, precision P>
 typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type & v, tmat4x4<T, P> const & m);

 template <typename T, precision P>
 tmat4x4<T, P> operator/(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2);


 template <typename T, precision P>
 tmat4x4<T, P> const operator-(tmat4x4<T, P> const & m);
}


# 1 "../glm/gtx/../detail/type_mat4x4.inl" 1
# 33 "../glm/gtx/../detail/type_mat4x4.inl"
namespace glm{
namespace detail
{
 template <typename T, precision P>
 inline tmat4x4<T, P> compute_inverse(tmat4x4<T, P> const & m)
 {
  T Coef00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
  T Coef02 = m[1][2] * m[3][3] - m[3][2] * m[1][3];
  T Coef03 = m[1][2] * m[2][3] - m[2][2] * m[1][3];

  T Coef04 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
  T Coef06 = m[1][1] * m[3][3] - m[3][1] * m[1][3];
  T Coef07 = m[1][1] * m[2][3] - m[2][1] * m[1][3];

  T Coef08 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
  T Coef10 = m[1][1] * m[3][2] - m[3][1] * m[1][2];
  T Coef11 = m[1][1] * m[2][2] - m[2][1] * m[1][2];

  T Coef12 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
  T Coef14 = m[1][0] * m[3][3] - m[3][0] * m[1][3];
  T Coef15 = m[1][0] * m[2][3] - m[2][0] * m[1][3];

  T Coef16 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
  T Coef18 = m[1][0] * m[3][2] - m[3][0] * m[1][2];
  T Coef19 = m[1][0] * m[2][2] - m[2][0] * m[1][2];

  T Coef20 = m[2][0] * m[3][1] - m[3][0] * m[2][1];
  T Coef22 = m[1][0] * m[3][1] - m[3][0] * m[1][1];
  T Coef23 = m[1][0] * m[2][1] - m[2][0] * m[1][1];

  tvec4<T, P> Fac0(Coef00, Coef00, Coef02, Coef03);
  tvec4<T, P> Fac1(Coef04, Coef04, Coef06, Coef07);
  tvec4<T, P> Fac2(Coef08, Coef08, Coef10, Coef11);
  tvec4<T, P> Fac3(Coef12, Coef12, Coef14, Coef15);
  tvec4<T, P> Fac4(Coef16, Coef16, Coef18, Coef19);
  tvec4<T, P> Fac5(Coef20, Coef20, Coef22, Coef23);

  tvec4<T, P> Vec0(m[1][0], m[0][0], m[0][0], m[0][0]);
  tvec4<T, P> Vec1(m[1][1], m[0][1], m[0][1], m[0][1]);
  tvec4<T, P> Vec2(m[1][2], m[0][2], m[0][2], m[0][2]);
  tvec4<T, P> Vec3(m[1][3], m[0][3], m[0][3], m[0][3]);

  tvec4<T, P> Inv0(Vec1 * Fac0 - Vec2 * Fac1 + Vec3 * Fac2);
  tvec4<T, P> Inv1(Vec0 * Fac0 - Vec2 * Fac3 + Vec3 * Fac4);
  tvec4<T, P> Inv2(Vec0 * Fac1 - Vec1 * Fac3 + Vec3 * Fac5);
  tvec4<T, P> Inv3(Vec0 * Fac2 - Vec1 * Fac4 + Vec2 * Fac5);

  tvec4<T, P> SignA(+1, -1, +1, -1);
  tvec4<T, P> SignB(-1, +1, -1, +1);
  tmat4x4<T, P> Inverse(Inv0 * SignA, Inv1 * SignB, Inv2 * SignA, Inv3 * SignB);

  tvec4<T, P> Row0(Inverse[0][0], Inverse[1][0], Inverse[2][0], Inverse[3][0]);

  tvec4<T, P> Dot0(m[0] * Row0);
  T Dot1 = (Dot0.x + Dot0.y) + (Dot0.z + Dot0.w);

  T OneOverDeterminant = static_cast<T>(1) / Dot1;

  return Inverse * OneOverDeterminant;
 }
}




 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4()
 {

   this->value[0] = col_type(1, 0, 0, 0);
   this->value[1] = col_type(0, 1, 0, 0);
   this->value[2] = col_type(0, 0, 1, 0);
   this->value[3] = col_type(0, 0, 0, 1);

 }

 template <typename T, precision P>
 template <precision Q>
 inline tmat4x4<T, P>::tmat4x4(tmat4x4<T, Q> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4(ctor)
 {}

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4(T const & s)
 {
  this->value[0] = col_type(s, 0, 0, 0);
  this->value[1] = col_type(0, s, 0, 0);
  this->value[2] = col_type(0, 0, s, 0);
  this->value[3] = col_type(0, 0, 0, s);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4
 (
  T const & x0, T const & y0, T const & z0, T const & w0,
  T const & x1, T const & y1, T const & z1, T const & w1,
  T const & x2, T const & y2, T const & z2, T const & w2,
  T const & x3, T const & y3, T const & z3, T const & w3
 )
 {
  this->value[0] = col_type(x0, y0, z0, w0);
  this->value[1] = col_type(x1, y1, z1, w1);
  this->value[2] = col_type(x2, y2, z2, w2);
  this->value[3] = col_type(x3, y3, z3, w3);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4
 (
  col_type const & v0,
  col_type const & v1,
  col_type const & v2,
  col_type const & v3
 )
 {
  this->value[0] = v0;
  this->value[1] = v1;
  this->value[2] = v2;
  this->value[3] = v3;
 }

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tmat4x4<T, P>::tmat4x4
 (
  tmat4x4<U, Q> const & m
 )
 {
  this->value[0] = col_type(m[0]);
  this->value[1] = col_type(m[1]);
  this->value[2] = col_type(m[2]);
  this->value[3] = col_type(m[3]);
 }



 template <typename T, precision P>
 template <
  typename X1, typename Y1, typename Z1, typename W1,
  typename X2, typename Y2, typename Z2, typename W2,
  typename X3, typename Y3, typename Z3, typename W3,
  typename X4, typename Y4, typename Z4, typename W4>
 inline tmat4x4<T, P>::tmat4x4
 (
  X1 const & x1, Y1 const & y1, Z1 const & z1, W1 const & w1,
  X2 const & x2, Y2 const & y2, Z2 const & z2, W2 const & w2,
  X3 const & x3, Y3 const & y3, Z3 const & z3, W3 const & w3,
  X4 const & x4, Y4 const & y4, Z4 const & z4, W4 const & w4
 )
 {
  static_assert(std::numeric_limits<X1>::is_iec559 || std::numeric_limits<X1>::is_integer, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
  static_assert(std::numeric_limits<Y1>::is_iec559 || std::numeric_limits<Y1>::is_integer, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
  static_assert(std::numeric_limits<Z1>::is_iec559 || std::numeric_limits<Z1>::is_integer, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
  static_assert(std::numeric_limits<W1>::is_iec559 || std::numeric_limits<W1>::is_integer, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");

  static_assert(std::numeric_limits<X2>::is_iec559 || std::numeric_limits<X2>::is_integer, "*mat4x4 constructor only takes float and integer types, 5th parameter type invalid.");
  static_assert(std::numeric_limits<Y2>::is_iec559 || std::numeric_limits<Y2>::is_integer, "*mat4x4 constructor only takes float and integer types, 6th parameter type invalid.");
  static_assert(std::numeric_limits<Z2>::is_iec559 || std::numeric_limits<Z2>::is_integer, "*mat4x4 constructor only takes float and integer types, 7th parameter type invalid.");
  static_assert(std::numeric_limits<W2>::is_iec559 || std::numeric_limits<W2>::is_integer, "*mat4x4 constructor only takes float and integer types, 8th parameter type invalid.");

  static_assert(std::numeric_limits<X3>::is_iec559 || std::numeric_limits<X3>::is_integer, "*mat4x4 constructor only takes float and integer types, 9th parameter type invalid.");
  static_assert(std::numeric_limits<Y3>::is_iec559 || std::numeric_limits<Y3>::is_integer, "*mat4x4 constructor only takes float and integer types, 10th parameter type invalid.");
  static_assert(std::numeric_limits<Z3>::is_iec559 || std::numeric_limits<Z3>::is_integer, "*mat4x4 constructor only takes float and integer types, 11th parameter type invalid.");
  static_assert(std::numeric_limits<W3>::is_iec559 || std::numeric_limits<W3>::is_integer, "*mat4x4 constructor only takes float and integer types, 12th parameter type invalid.");

  static_assert(std::numeric_limits<X4>::is_iec559 || std::numeric_limits<X4>::is_integer, "*mat4x4 constructor only takes float and integer types, 13th parameter type invalid.");
  static_assert(std::numeric_limits<Y4>::is_iec559 || std::numeric_limits<Y4>::is_integer, "*mat4x4 constructor only takes float and integer types, 14th parameter type invalid.");
  static_assert(std::numeric_limits<Z4>::is_iec559 || std::numeric_limits<Z4>::is_integer, "*mat4x4 constructor only takes float and integer types, 15th parameter type invalid.");
  static_assert(std::numeric_limits<W4>::is_iec559 || std::numeric_limits<W4>::is_integer, "*mat4x4 constructor only takes float and integer types, 16th parameter type invalid.");

  this->value[0] = col_type(static_cast<T>(x1), value_type(y1), value_type(z1), value_type(w1));
  this->value[1] = col_type(static_cast<T>(x2), value_type(y2), value_type(z2), value_type(w2));
  this->value[2] = col_type(static_cast<T>(x3), value_type(y3), value_type(z3), value_type(w3));
  this->value[3] = col_type(static_cast<T>(x4), value_type(y4), value_type(z4), value_type(w4));
 }

 template <typename T, precision P>
 template <typename V1, typename V2, typename V3, typename V4>
 inline tmat4x4<T, P>::tmat4x4
 (
  tvec4<V1, P> const & v1,
  tvec4<V2, P> const & v2,
  tvec4<V3, P> const & v3,
  tvec4<V4, P> const & v4
 )
 {
  static_assert(std::numeric_limits<V1>::is_iec559 || std::numeric_limits<V1>::is_integer, "*mat4x4 constructor only takes float and integer types, 1st parameter type invalid.");
  static_assert(std::numeric_limits<V2>::is_iec559 || std::numeric_limits<V2>::is_integer, "*mat4x4 constructor only takes float and integer types, 2nd parameter type invalid.");
  static_assert(std::numeric_limits<V3>::is_iec559 || std::numeric_limits<V3>::is_integer, "*mat4x4 constructor only takes float and integer types, 3rd parameter type invalid.");
  static_assert(std::numeric_limits<V4>::is_iec559 || std::numeric_limits<V4>::is_integer, "*mat4x4 constructor only takes float and integer types, 4th parameter type invalid.");

  this->value[0] = col_type(v1);
  this->value[1] = col_type(v2);
  this->value[2] = col_type(v3);
  this->value[3] = col_type(v4);
 }



 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4(tmat2x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4(tmat3x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4(tmat2x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4(tmat3x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(m[2], 0, 0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4(tmat2x4<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = col_type(0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4(tmat4x2<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0, 0);
  this->value[1] = col_type(m[1], 0, 0);
  this->value[2] = col_type(0);
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4(tmat3x4<T, P> const & m)
 {
  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = col_type(0, 0, 0, 1);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P>::tmat4x4(tmat4x3<T, P> const & m)
 {
  this->value[0] = col_type(m[0], 0);
  this->value[1] = col_type(m[1], 0);
  this->value[2] = col_type(m[2], 0);
  this->value[3] = col_type(m[3], 1);
 }
# 336 "../glm/gtx/../detail/type_mat4x4.inl"
  template <typename T, precision P>
  inline constexpr typename tmat4x4<T, P>::length_type tmat4x4<T, P>::length() const
  {
   return 4;
  }

  template <typename T, precision P>
  inline typename tmat4x4<T, P>::col_type & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i)
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat4x4.inl", 345, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }

  template <typename T, precision P>
  inline typename tmat4x4<T, P>::col_type const & tmat4x4<T, P>::operator[](typename tmat4x4<T, P>::length_type i) const
  {
   ((i < this->length()) ? (void)0 : __assert2("../glm/gtx/../detail/type_mat4x4.inl", 352, __PRETTY_FUNCTION__, "i < this->length()"));
   return this->value[i];
  }





 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P>& tmat4x4<T, P>::operator=(tmat4x4<U, P> const & m)
 {


  this->value[0] = m[0];
  this->value[1] = m[1];
  this->value[2] = m[2];
  this->value[3] = m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P>& tmat4x4<T, P>::operator+=(U s)
 {
  this->value[0] += s;
  this->value[1] += s;
  this->value[2] += s;
  this->value[3] += s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P>& tmat4x4<T, P>::operator+=(tmat4x4<U, P> const & m)
 {
  this->value[0] += m[0];
  this->value[1] += m[1];
  this->value[2] += m[2];
  this->value[3] += m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P> & tmat4x4<T, P>::operator-=(U s)
 {
  this->value[0] -= s;
  this->value[1] -= s;
  this->value[2] -= s;
  this->value[3] -= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P> & tmat4x4<T, P>::operator-=(tmat4x4<U, P> const & m)
 {
  this->value[0] -= m[0];
  this->value[1] -= m[1];
  this->value[2] -= m[2];
  this->value[3] -= m[3];
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P> & tmat4x4<T, P>::operator*=(U s)
 {
  this->value[0] *= s;
  this->value[1] *= s;
  this->value[2] *= s;
  this->value[3] *= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P> & tmat4x4<T, P>::operator*=(tmat4x4<U, P> const & m)
 {
  return (*this = *this * m);
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P> & tmat4x4<T, P>::operator/=(U s)
 {
  this->value[0] /= s;
  this->value[1] /= s;
  this->value[2] /= s;
  this->value[3] /= s;
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tmat4x4<T, P> & tmat4x4<T, P>::operator/=(tmat4x4<U, P> const & m)
 {
  return (*this = *this * detail::compute_inverse<T, P>(m));
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> & tmat4x4<T, P>::operator++()
 {
  ++this->value[0];
  ++this->value[1];
  ++this->value[2];
  ++this->value[3];
  return *this;
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> & tmat4x4<T, P>::operator--()
 {
  --this->value[0];
  --this->value[1];
  --this->value[2];
  --this->value[3];
  return *this;
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> tmat4x4<T, P>::operator++(int)
 {
  tmat4x4<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> tmat4x4<T, P>::operator--(int)
 {
  tmat4x4<T, P> Result(*this);
  --*this;
  return Result;
 }


 template <typename T, precision P>
 inline tmat4x4<T, P> operator+(tmat4x4<T, P> const & m, T const & s)
 {
  return tmat4x4<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator+(T const & s, tmat4x4<T, P> const & m)
 {
  return tmat4x4<T, P>(
   m[0] + s,
   m[1] + s,
   m[2] + s,
   m[3] + s);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator+(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return tmat4x4<T, P>(
   m1[0] + m2[0],
   m1[1] + m2[1],
   m1[2] + m2[2],
   m1[3] + m2[3]);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator-(tmat4x4<T, P> const & m, T const & s)
 {
  return tmat4x4<T, P>(
   m[0] - s,
   m[1] - s,
   m[2] - s,
   m[3] - s);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator-(T const & s, tmat4x4<T, P> const & m)
 {
  return tmat4x4<T, P>(
   s - m[0],
   s - m[1],
   s - m[2],
   s - m[3]);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator-(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return tmat4x4<T, P>(
   m1[0] - m2[0],
   m1[1] - m2[1],
   m1[2] - m2[2],
   m1[3] - m2[3]);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator*(tmat4x4<T, P> const & m, T const & s)
 {
  return tmat4x4<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator*(T const & s, tmat4x4<T, P> const & m)
 {
  return tmat4x4<T, P>(
   m[0] * s,
   m[1] * s,
   m[2] * s,
   m[3] * s);
 }

 template <typename T, precision P>
 inline typename tmat4x4<T, P>::col_type operator*
 (
  tmat4x4<T, P> const & m,
  typename tmat4x4<T, P>::row_type const & v
 )
 {
# 596 "../glm/gtx/../detail/type_mat4x4.inl"
  typename tmat4x4<T, P>::col_type const Mov0(v[0]);
  typename tmat4x4<T, P>::col_type const Mov1(v[1]);
  typename tmat4x4<T, P>::col_type const Mul0 = m[0] * Mov0;
  typename tmat4x4<T, P>::col_type const Mul1 = m[1] * Mov1;
  typename tmat4x4<T, P>::col_type const Add0 = Mul0 + Mul1;
  typename tmat4x4<T, P>::col_type const Mov2(v[2]);
  typename tmat4x4<T, P>::col_type const Mov3(v[3]);
  typename tmat4x4<T, P>::col_type const Mul2 = m[2] * Mov2;
  typename tmat4x4<T, P>::col_type const Mul3 = m[3] * Mov3;
  typename tmat4x4<T, P>::col_type const Add1 = Mul2 + Mul3;
  typename tmat4x4<T, P>::col_type const Add2 = Add0 + Add1;
  return Add2;
# 616 "../glm/gtx/../detail/type_mat4x4.inl"
 }

 template <typename T, precision P>
 inline typename tmat4x4<T, P>::row_type operator*
 (
  typename tmat4x4<T, P>::col_type const & v,
  tmat4x4<T, P> const & m
 )
 {
  return typename tmat4x4<T, P>::row_type(
   m[0][0] * v[0] + m[0][1] * v[1] + m[0][2] * v[2] + m[0][3] * v[3],
   m[1][0] * v[0] + m[1][1] * v[1] + m[1][2] * v[2] + m[1][3] * v[3],
   m[2][0] * v[0] + m[2][1] * v[1] + m[2][2] * v[2] + m[2][3] * v[3],
   m[3][0] * v[0] + m[3][1] * v[1] + m[3][2] * v[2] + m[3][3] * v[3]);
 }

 template <typename T, precision P>
 inline tmat2x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat2x4<T, P> const & m2)
 {
  return tmat2x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3]);
 }

 template <typename T, precision P>
 inline tmat3x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat3x4<T, P> const & m2)
 {
  return tmat3x4<T, P>(
   m1[0][0] * m2[0][0] + m1[1][0] * m2[0][1] + m1[2][0] * m2[0][2] + m1[3][0] * m2[0][3],
   m1[0][1] * m2[0][0] + m1[1][1] * m2[0][1] + m1[2][1] * m2[0][2] + m1[3][1] * m2[0][3],
   m1[0][2] * m2[0][0] + m1[1][2] * m2[0][1] + m1[2][2] * m2[0][2] + m1[3][2] * m2[0][3],
   m1[0][3] * m2[0][0] + m1[1][3] * m2[0][1] + m1[2][3] * m2[0][2] + m1[3][3] * m2[0][3],
   m1[0][0] * m2[1][0] + m1[1][0] * m2[1][1] + m1[2][0] * m2[1][2] + m1[3][0] * m2[1][3],
   m1[0][1] * m2[1][0] + m1[1][1] * m2[1][1] + m1[2][1] * m2[1][2] + m1[3][1] * m2[1][3],
   m1[0][2] * m2[1][0] + m1[1][2] * m2[1][1] + m1[2][2] * m2[1][2] + m1[3][2] * m2[1][3],
   m1[0][3] * m2[1][0] + m1[1][3] * m2[1][1] + m1[2][3] * m2[1][2] + m1[3][3] * m2[1][3],
   m1[0][0] * m2[2][0] + m1[1][0] * m2[2][1] + m1[2][0] * m2[2][2] + m1[3][0] * m2[2][3],
   m1[0][1] * m2[2][0] + m1[1][1] * m2[2][1] + m1[2][1] * m2[2][2] + m1[3][1] * m2[2][3],
   m1[0][2] * m2[2][0] + m1[1][2] * m2[2][1] + m1[2][2] * m2[2][2] + m1[3][2] * m2[2][3],
   m1[0][3] * m2[2][0] + m1[1][3] * m2[2][1] + m1[2][3] * m2[2][2] + m1[3][3] * m2[2][3]);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator*(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  typename tmat4x4<T, P>::col_type const SrcA0 = m1[0];
  typename tmat4x4<T, P>::col_type const SrcA1 = m1[1];
  typename tmat4x4<T, P>::col_type const SrcA2 = m1[2];
  typename tmat4x4<T, P>::col_type const SrcA3 = m1[3];

  typename tmat4x4<T, P>::col_type const SrcB0 = m2[0];
  typename tmat4x4<T, P>::col_type const SrcB1 = m2[1];
  typename tmat4x4<T, P>::col_type const SrcB2 = m2[2];
  typename tmat4x4<T, P>::col_type const SrcB3 = m2[3];

  tmat4x4<T, P> Result(uninitialize);
  Result[0] = SrcA0 * SrcB0[0] + SrcA1 * SrcB0[1] + SrcA2 * SrcB0[2] + SrcA3 * SrcB0[3];
  Result[1] = SrcA0 * SrcB1[0] + SrcA1 * SrcB1[1] + SrcA2 * SrcB1[2] + SrcA3 * SrcB1[3];
  Result[2] = SrcA0 * SrcB2[0] + SrcA1 * SrcB2[1] + SrcA2 * SrcB2[2] + SrcA3 * SrcB2[3];
  Result[3] = SrcA0 * SrcB3[0] + SrcA1 * SrcB3[1] + SrcA2 * SrcB3[2] + SrcA3 * SrcB3[3];
  return Result;
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator/(tmat4x4<T, P> const & m, T const & s)
 {
  return tmat4x4<T, P>(
   m[0] / s,
   m[1] / s,
   m[2] / s,
   m[3] / s);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator/(T const & s, tmat4x4<T, P> const & m)
 {
  return tmat4x4<T, P>(
   s / m[0],
   s / m[1],
   s / m[2],
   s / m[3]);
 }

 template <typename T, precision P>
 inline typename tmat4x4<T, P>::col_type operator/(tmat4x4<T, P> const & m, typename tmat4x4<T, P>::row_type const & v)
 {
  return detail::compute_inverse<T, P>(m) * v;
 }

 template <typename T, precision P>
 inline typename tmat4x4<T, P>::row_type operator/(typename tmat4x4<T, P>::col_type const & v, tmat4x4<T, P> const & m)
 {
  return v * detail::compute_inverse<T, P>(m);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> operator/(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  tmat4x4<T, P> m1_copy(m1);
  return m1_copy /= m2;
 }


 template <typename T, precision P>
 inline tmat4x4<T, P> const operator-(tmat4x4<T, P> const & m)
 {
  return tmat4x4<T, P>(
   -m[0],
   -m[1],
   -m[2],
   -m[3]);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> const operator++(tmat4x4<T, P> const & m, int)
 {
  return tmat4x4<T, P>(
   m[0] + static_cast<T>(1),
   m[1] + static_cast<T>(1),
   m[2] + static_cast<T>(1),
   m[3] + static_cast<T>(1));
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> const operator--(tmat4x4<T, P> const & m, int)
 {
  return tmat4x4<T, P>(
   m[0] - static_cast<T>(1),
   m[1] - static_cast<T>(1),
   m[2] - static_cast<T>(1),
   m[3] - static_cast<T>(1));
 }




 template <typename T, precision P>
 inline bool operator==(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return (m1[0] == m2[0]) && (m1[1] == m2[1]) && (m1[2] == m2[2]) && (m1[3] == m2[3]);
 }

 template <typename T, precision P>
 inline bool operator!=(tmat4x4<T, P> const & m1, tmat4x4<T, P> const & m2)
 {
  return (m1[0] != m2[0]) || (m1[1] != m2[1]) || (m1[2] != m2[2]) || (m1[3] != m2[3]);
 }
}
# 232 "../glm/gtx/../detail/type_mat4x4.hpp" 2
# 36 "../glm/gtx/../mat4x4.hpp" 2

namespace glm
{





 typedef tmat4x4<float, lowp> lowp_mat4;






 typedef tmat4x4<float, mediump> mediump_mat4;






 typedef tmat4x4<float, highp> highp_mat4;






 typedef tmat4x4<float, lowp> lowp_mat4x4;






 typedef tmat4x4<float, mediump> mediump_mat4x4;






 typedef tmat4x4<float, highp> highp_mat4x4;

}
# 109 "../glm/gtx/../glm.hpp" 2

# 1 "../glm/gtx/../trigonometric.hpp" 1
# 33 "../glm/gtx/../trigonometric.hpp"
       

# 1 "../glm/gtx/../detail/func_trigonometric.hpp" 1
# 44 "../glm/gtx/../detail/func_trigonometric.hpp"
       




namespace glm
{
# 60 "../glm/gtx/../detail/func_trigonometric.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> radians(vecType<T, P> const & degrees);







 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> degrees(vecType<T, P> const & radians);
# 79 "../glm/gtx/../detail/func_trigonometric.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> sin(vecType<T, P> const & angle);
# 89 "../glm/gtx/../detail/func_trigonometric.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> cos(vecType<T, P> const & angle);







 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> tan(vecType<T, P> const & angle);
# 109 "../glm/gtx/../detail/func_trigonometric.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> asin(vecType<T, P> const & x);
# 120 "../glm/gtx/../detail/func_trigonometric.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> acos(vecType<T, P> const & x);
# 133 "../glm/gtx/../detail/func_trigonometric.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> atan(vecType<T, P> const & y, vecType<T, P> const & x);
# 143 "../glm/gtx/../detail/func_trigonometric.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> atan(vecType<T, P> const & y_over_x);







 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> sinh(vecType<T, P> const & angle);







 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> cosh(vecType<T, P> const & angle);







 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> tanh(vecType<T, P> const & angle);







 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> asinh(vecType<T, P> const & x);
# 189 "../glm/gtx/../detail/func_trigonometric.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> acosh(vecType<T, P> const & x);
# 199 "../glm/gtx/../detail/func_trigonometric.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> atanh(vecType<T, P> const & x);


}

# 1 "../glm/gtx/../detail/func_trigonometric.inl" 1
# 33 "../glm/gtx/../detail/func_trigonometric.inl"
# 1 "../glm/gtx/../detail/_vectorize.hpp" 1
# 33 "../glm/gtx/../detail/_vectorize.hpp"
       

# 1 "../glm/gtx/../detail/type_vec1.hpp" 1
# 33 "../glm/gtx/../detail/type_vec1.hpp"
       
# 46 "../glm/gtx/../detail/type_vec1.hpp"
namespace glm
{
 template <typename T, precision P = defaultp>
 struct tvec1
 {



  typedef tvec1<T, P> type;
  typedef tvec1<bool, P> bool_type;
  typedef T value_type;
# 81 "../glm/gtx/../detail/type_vec1.hpp"
   union {T x, r, s;};
# 100 "../glm/gtx/../detail/type_vec1.hpp"
   typedef length_t length_type;
   constexpr length_type length() const;

   T & operator[](length_type i);
   T const & operator[](length_type i) const;





  tvec1();
  template <precision Q>
  tvec1(tvec1<T, Q> const & v);




  explicit tvec1(ctor);
  explicit tvec1(T const & s);





  template <typename U, precision Q>
  explicit tvec1(tvec2<U, Q> const & v);

  template <typename U, precision Q>
  explicit tvec1(tvec3<U, Q> const & v);

  template <typename U, precision Q>
  explicit tvec1(tvec4<U, Q> const & v);







   template <typename U, precision Q>
   tvec1(tvec1<U, Q> const & v);
# 157 "../glm/gtx/../detail/type_vec1.hpp"
  template <typename U>
  tvec1<T, P> & operator=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator+=(U const & s);
  template <typename U>
  tvec1<T, P> & operator+=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator-=(U const & s);
  template <typename U>
  tvec1<T, P> & operator-=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator*=(U const & s);
  template <typename U>
  tvec1<T, P> & operator*=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator/=(U const & s);
  template <typename U>
  tvec1<T, P> & operator/=(tvec1<U, P> const & v);




  tvec1<T, P> & operator++();
  tvec1<T, P> & operator--();
  tvec1<T, P> operator++(int);
  tvec1<T, P> operator--(int);




  template <typename U>
  tvec1<T, P> & operator%=(U const & s);
  template <typename U>
  tvec1<T, P> & operator%=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator&=(U const & s);
  template <typename U>
  tvec1<T, P> & operator&=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator|=(U const & s);
  template <typename U>
  tvec1<T, P> & operator|=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator^=(U const & s);
  template <typename U>
  tvec1<T, P> & operator^=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator<<=(U const & s);
  template <typename U>
  tvec1<T, P> & operator<<=(tvec1<U, P> const & v);
  template <typename U>
  tvec1<T, P> & operator>>=(U const & s);
  template <typename U>
  tvec1<T, P> & operator>>=(tvec1<U, P> const & v);
 };


 template <typename T, precision P>
 tvec1<T, P> operator+(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator+(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator+(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator-(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator-(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator- (tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator*(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator*(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator*(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator/(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator/(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator/(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator-(tvec1<T, P> const & v);

 template <typename T, precision P>
 bool operator==(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 bool operator!=(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator%(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator%(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator%(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator&(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator&(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator&(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator|(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator|(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator|(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator^(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator^(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator^(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator<<(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator<<(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator<<(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator>>(tvec1<T, P> const & v, T const & s);

 template <typename T, precision P>
 tvec1<T, P> operator>>(T const & s, tvec1<T, P> const & v);

 template <typename T, precision P>
 tvec1<T, P> operator>>(tvec1<T, P> const & v1, tvec1<T, P> const & v2);

 template <typename T, precision P>
 tvec1<T, P> operator~(tvec1<T, P> const & v);
}


# 1 "../glm/gtx/../detail/type_vec1.inl" 1
# 33 "../glm/gtx/../detail/type_vec1.inl"
namespace glm
{



 template <typename T, precision P>
 inline tvec1<T, P>::tvec1()

   : x(0)

 {}

 template <typename T, precision P>
 template <precision Q>
 inline tvec1<T, P>::tvec1(tvec1<T, Q> const & v)
  : x(v.x)
 {}




 template <typename T, precision P>
 inline tvec1<T, P>::tvec1(ctor)
 {}

 template <typename T, precision P>
 inline tvec1<T, P>::tvec1(T const & s)
  : x(s)
 {}




 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec1<T, P>::tvec1(tvec1<U, Q> const & v)
  : x(static_cast<T>(v.x))
 {}

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec1<T, P>::tvec1(tvec2<U, Q> const & v)
  : x(static_cast<T>(v.x))
 {}

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec1<T, P>::tvec1(tvec3<U, Q> const & v)
  : x(static_cast<T>(v.x))
 {}

 template <typename T, precision P>
 template <typename U, precision Q>
 inline tvec1<T, P>::tvec1(tvec4<U, Q> const & v)
  : x(static_cast<T>(v.x))
 {}
# 114 "../glm/gtx/../detail/type_vec1.inl"
  template <typename T, precision P>
  inline constexpr typename tvec1<T, P>::length_type tvec1<T, P>::length() const
  {
   return 1;
  }

  template <typename T, precision P>
  inline T & tvec1<T, P>::operator[](typename tvec1<T, P>::length_type i)
  {
   ((i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)) ? (void)0 : __assert2("../glm/gtx/../detail/type_vec1.inl", 123, __PRETTY_FUNCTION__, "i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)"));
   return (&x)[i];
  }

  template <typename T, precision P>
  inline T const & tvec1<T, P>::operator[](typename tvec1<T, P>::length_type i) const
  {
   ((i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)) ? (void)0 : __assert2("../glm/gtx/../detail/type_vec1.inl", 130, __PRETTY_FUNCTION__, "i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this)"));
   return (&x)[i];
  }





 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator=(tvec1<U, P> const & v)
 {
  this->x = static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator+=(U const & s)
 {
  this->x += static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator+=(tvec1<U, P> const & v)
 {
  this->x += static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator-=(U const & s)
 {
  this->x -= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator-=(tvec1<U, P> const & v)
 {
  this->x -= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator*=(U const & s)
 {
  this->x *= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator*=(tvec1<U, P> const & v)
 {
  this->x *= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator/=(U const & s)
 {
  this->x /= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator/=(tvec1<U, P> const & v)
 {
  this->x /= static_cast<T>(v.x);
  return *this;
 }




 template <typename T, precision P>
 inline tvec1<T, P> & tvec1<T, P>::operator++()
 {
  ++this->x;
  return *this;
 }

 template <typename T, precision P>
 inline tvec1<T, P> & tvec1<T, P>::operator--()
 {
  --this->x;
  return *this;
 }

 template <typename T, precision P>
 inline tvec1<T, P> tvec1<T, P>::operator++(int)
 {
  tvec1<T, P> Result(*this);
  ++*this;
  return Result;
 }

 template <typename T, precision P>
 inline tvec1<T, P> tvec1<T, P>::operator--(int)
 {
  tvec1<T, P> Result(*this);
  --*this;
  return Result;
 }




 template <typename T, precision P>
 inline bool operator==(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return (v1.x == v2.x);
 }

 template <typename T, precision P>
 inline bool operator!=(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return (v1.x != v2.x);
 }




 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator%=(U const & s)
 {
  this->x %= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator%=(tvec1<U, P> const & v)
 {
  this->x %= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator&=(U const & s)
 {
  this->x &= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator&=(tvec1<U, P> const & v)
 {
  this->x &= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator|=(U const & s)
 {
  this->x |= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator|=(tvec1<U, P> const & v)
 {
  this->x |= U(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator^=(U const & s)
 {
  this->x ^= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator^=(tvec1<U, P> const & v)
 {
  this->x ^= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator<<=(U const & s)
 {
  this->x <<= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator<<=(tvec1<U, P> const & v)
 {
  this->x <<= static_cast<T>(v.x);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator>>=(U const & s)
 {
  this->x >>= static_cast<T>(s);
  return *this;
 }

 template <typename T, precision P>
 template <typename U>
 inline tvec1<T, P> & tvec1<T, P>::operator>>=(tvec1<U, P> const & v)
 {
  this->x >>= static_cast<T>(v.x);
  return *this;
 }




 template <typename T, precision P>
 inline tvec1<T, P> operator+(tvec1<T, P> const & v, T const & s)
 {
  return tvec1<T, P>(
   v.x + s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator+(T const & s, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   s + v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator+(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x + v2.x);
 }


 template <typename T, precision P>
 inline tvec1<T, P> operator-(tvec1<T, P> const & v, T const & s)
 {
  return tvec1<T, P>(
   v.x - s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator-(T const & s, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   s - v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator-(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x - v2.x);
 }


 template <typename T, precision P>
 inline tvec1<T, P> operator*(tvec1<T, P> const & v, T const & s)
 {
  return tvec1<T, P>(
   v.x * s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator*(T const & s, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   s * v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator*(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x * v2.x);
 }


 template <typename T, precision P>
 inline tvec1<T, P> operator/(tvec1<T, P> const & v, T const & s)
 {
  return tvec1<T, P>(
   v.x / s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator/(T const & s, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   s / v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator/(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x / v2.x);
 }


 template <typename T, precision P>
 inline tvec1<T, P> operator-(tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   -v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator++(tvec1<T, P> const & v, int)
 {
  return tvec1<T, P>(
   v.x + T(1));
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator--(tvec1<T, P> const & v, int)
 {
  return tvec1<T, P>(
   v.x - T(1));
 }




 template <typename T, precision P>
 inline tvec1<T, P> operator%(tvec1<T, P> const & v, T const & s)
 {
  return tvec1<T, P>(
   v.x % s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator%(T const & s, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   s % v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator%(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x % v2.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator&(tvec1<T, P> const & v, T const & s)
 {
  return tvec1<T, P>(
   v.x & s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator&(T const & s, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   s & v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator&(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x & v2.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator|(tvec1<T, P> const & v, T const & s)
 {
  return tvec1<T, P>(
   v.x | s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator|(T const & s, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   s | v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator|(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x | v2.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator^(tvec1<T, P> const & v, T const & s)
 {
  return tvec1<T, P>(
   v.x ^ s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator^(T const & s, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   s ^ v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator^(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x ^ v2.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator<<(tvec1<T, P> const & v, T const & s)
 {
  return tvec1<T, P>(
   v.x << s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator<<(T const & s, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   s << v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator<<(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x << v2.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator>>(tvec1<T, P> const & v, T const & s)
 {
  return tvec1<T, P>(
   v.x >> s);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator>>(T const & s, tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   s >> v.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator>>(tvec1<T, P> const & v1, tvec1<T, P> const & v2)
 {
  return tvec1<T, P>(
   v1.x >> v2.x);
 }

 template <typename T, precision P>
 inline tvec1<T, P> operator~(tvec1<T, P> const & v)
 {
  return tvec1<T, P>(
   ~v.x);
 }
}
# 319 "../glm/gtx/../detail/type_vec1.hpp" 2
# 36 "../glm/gtx/../detail/_vectorize.hpp" 2




namespace glm{
namespace detail
{
 template <typename R, typename T, precision P, template <typename, precision> class vecType>
 struct functor1{};

 template <typename R, typename T, precision P>
 struct functor1<R, T, P, tvec1>
 {
  inline static tvec1<R, P> call(R (*Func) (T x), tvec1<T, P> const & v)
  {
   return tvec1<R, P>(Func(v.x));
  }
 };

 template <typename R, typename T, precision P>
 struct functor1<R, T, P, tvec2>
 {
  inline static tvec2<R, P> call(R (*Func) (T x), tvec2<T, P> const & v)
  {
   return tvec2<R, P>(Func(v.x), Func(v.y));
  }
 };

 template <typename R, typename T, precision P>
 struct functor1<R, T, P, tvec3>
 {
  inline static tvec3<R, P> call(R (*Func) (T x), tvec3<T, P> const & v)
  {
   return tvec3<R, P>(Func(v.x), Func(v.y), Func(v.z));
  }
 };

 template <typename R, typename T, precision P>
 struct functor1<R, T, P, tvec4>
 {
  inline static tvec4<R, P> call(R (*Func) (T x), tvec4<T, P> const & v)
  {
   return tvec4<R, P>(Func(v.x), Func(v.y), Func(v.z), Func(v.w));
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType>
 struct functor2{};

 template <typename T, precision P>
 struct functor2<T, P, tvec1>
 {
  inline static tvec1<T, P> call(T (*Func) (T x, T y), tvec1<T, P> const & a, tvec1<T, P> const & b)
  {
   return tvec1<T, P>(Func(a.x, b.x));
  }
 };

 template <typename T, precision P>
 struct functor2<T, P, tvec2>
 {
  inline static tvec2<T, P> call(T (*Func) (T x, T y), tvec2<T, P> const & a, tvec2<T, P> const & b)
  {
   return tvec2<T, P>(Func(a.x, b.x), Func(a.y, b.y));
  }
 };

 template <typename T, precision P>
 struct functor2<T, P, tvec3>
 {
  inline static tvec3<T, P> call(T (*Func) (T x, T y), tvec3<T, P> const & a, tvec3<T, P> const & b)
  {
   return tvec3<T, P>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z));
  }
 };

 template <typename T, precision P>
 struct functor2<T, P, tvec4>
 {
  inline static tvec4<T, P> call(T (*Func) (T x, T y), tvec4<T, P> const & a, tvec4<T, P> const & b)
  {
   return tvec4<T, P>(Func(a.x, b.x), Func(a.y, b.y), Func(a.z, b.z), Func(a.w, b.w));
  }
 };

 template <typename T, precision P, template <typename, precision> class vecType>
 struct functor2_vec_sca{};

 template <typename T, precision P>
 struct functor2_vec_sca<T, P, tvec1>
 {
  inline static tvec1<T, P> call(T (*Func) (T x, T y), tvec1<T, P> const & a, T b)
  {
   return tvec1<T, P>(Func(a.x, b));
  }
 };

 template <typename T, precision P>
 struct functor2_vec_sca<T, P, tvec2>
 {
  inline static tvec2<T, P> call(T (*Func) (T x, T y), tvec2<T, P> const & a, T b)
  {
   return tvec2<T, P>(Func(a.x, b), Func(a.y, b));
  }
 };

 template <typename T, precision P>
 struct functor2_vec_sca<T, P, tvec3>
 {
  inline static tvec3<T, P> call(T (*Func) (T x, T y), tvec3<T, P> const & a, T b)
  {
   return tvec3<T, P>(Func(a.x, b), Func(a.y, b), Func(a.z, b));
  }
 };

 template <typename T, precision P>
 struct functor2_vec_sca<T, P, tvec4>
 {
  inline static tvec4<T, P> call(T (*Func) (T x, T y), tvec4<T, P> const & a, T b)
  {
   return tvec4<T, P>(Func(a.x, b), Func(a.y, b), Func(a.z, b), Func(a.w, b));
  }
 };
}
}
# 34 "../glm/gtx/../detail/func_trigonometric.inl" 2
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 1
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath"
       
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 3
# 35 "../glm/gtx/../detail/func_trigonometric.inl" 2


namespace glm
{

 template <typename genType>
 inline genType radians(genType degrees)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'radians' only accept floating-point input");

  return degrees * static_cast<genType>(0.01745329251994329576923690768489);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> radians(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(radians, v);
 }


 template <typename genType>
 inline genType degrees(genType radians)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'degrees' only accept floating-point input");

  return radians * static_cast<genType>(57.295779513082320876798154814105);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> degrees(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(degrees, v);
 }


 using ::std::sin;

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> sin(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(sin, v);
 }


 using std::cos;

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> cos(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(cos, v);
 }


 using std::tan;

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> tan(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(tan, v);
 }


 using std::asin;

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> asin(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(asin, v);
 }


 using std::acos;

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> acos(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(acos, v);
 }


 template <typename genType>
 inline genType atan(genType const & y, genType const & x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'atan' only accept floating-point input");

  return ::std::atan2(y, x);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> atan(vecType<T, P> const & a, vecType<T, P> const & b)
 {
  return detail::functor2<T, P, vecType>::call(atan2, a, b);
 }

 using std::atan;

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> atan(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(atan, v);
 }


 using std::sinh;

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> sinh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(sinh, v);
 }


 using std::cosh;

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> cosh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(cosh, v);
 }


 using std::tanh;

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> tanh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(tanh, v);
 }





  template <typename genType>
  inline genType asinh(genType const & x)
  {
   static_assert(std::numeric_limits<genType>::is_iec559, "'asinh' only accept floating-point input");

   return (x < static_cast<genType>(0) ? static_cast<genType>(-1) : (x > static_cast<genType>(0) ? static_cast<genType>(1) : static_cast<genType>(0))) * log(abs(x) + sqrt(static_cast<genType>(1) + x * x));
  }


 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> asinh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(asinh, v);
 }





  template <typename genType>
  inline genType acosh(genType const & x)
  {
   static_assert(std::numeric_limits<genType>::is_iec559, "'acosh' only accept floating-point input");

   if(x < static_cast<genType>(1))
    return static_cast<genType>(0);
   return log(x + sqrt(x * x - static_cast<genType>(1)));
  }


 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> acosh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(acosh, v);
 }





  template <typename genType>
  inline genType atanh(genType const & x)
  {
   static_assert(std::numeric_limits<genType>::is_iec559, "'atanh' only accept floating-point input");

   if(abs(x) >= static_cast<genType>(1))
    return 0;
   return static_cast<genType>(0.5) * log((static_cast<genType>(1) + x) / (static_cast<genType>(1) - x));
  }


 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> atanh(vecType<T, P> const & v)
 {
  return detail::functor1<T, T, P, vecType>::call(atanh, v);
 }
}
# 206 "../glm/gtx/../detail/func_trigonometric.hpp" 2
# 36 "../glm/gtx/../trigonometric.hpp" 2
# 111 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../exponential.hpp" 1
# 33 "../glm/gtx/../exponential.hpp"
       

# 1 "../glm/gtx/../detail/func_exponential.hpp" 1
# 40 "../glm/gtx/../detail/func_exponential.hpp"
       





# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 1
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath"
       
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 3
# 47 "../glm/gtx/../detail/func_exponential.hpp" 2

namespace glm
{
# 61 "../glm/gtx/../detail/func_exponential.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> pow(vecType<T, P> const & base, vecType<T, P> const & exponent);
# 71 "../glm/gtx/../detail/func_exponential.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> exp(vecType<T, P> const & v);
# 83 "../glm/gtx/../detail/func_exponential.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> log(vecType<T, P> const & v);
# 93 "../glm/gtx/../detail/func_exponential.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> exp2(vecType<T, P> const & v);
# 104 "../glm/gtx/../detail/func_exponential.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> log2(vecType<T, P> const & v);
# 116 "../glm/gtx/../detail/func_exponential.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> sqrt(vecType<T, P> const & v);
# 126 "../glm/gtx/../detail/func_exponential.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> inversesqrt(vecType<T, P> const & v);


}

# 1 "../glm/gtx/../detail/func_exponential.inl" 1
# 33 "../glm/gtx/../detail/func_exponential.inl"
# 1 "../glm/gtx/../detail/func_vector_relational.hpp" 1
# 45 "../glm/gtx/../detail/func_vector_relational.hpp"
       




namespace glm
{
# 61 "../glm/gtx/../detail/func_vector_relational.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<bool, P> lessThan(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<bool, P> lessThanEqual(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<bool, P> greaterThan(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<bool, P> greaterThanEqual(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<bool, P> equal(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<bool, P> notEqual(vecType<T, P> const & x, vecType<T, P> const & y);







 template <precision P, template <typename, precision> class vecType>
 bool any(vecType<bool, P> const & v);







 template <precision P, template <typename, precision> class vecType>
 bool all(vecType<bool, P> const & v);
# 134 "../glm/gtx/../detail/func_vector_relational.hpp"
 template <precision P, template <typename, precision> class vecType>
 vecType<bool, P> not_(vecType<bool, P> const & v);


}

# 1 "../glm/gtx/../detail/func_vector_relational.inl" 1
# 35 "../glm/gtx/../detail/func_vector_relational.inl"
namespace glm
{
 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<bool, P> lessThan(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  ((detail::component_count(x) == detail::component_count(y)) ? (void)0 : __assert2("../glm/gtx/../detail/func_vector_relational.inl", 40, __PRETTY_FUNCTION__, "detail::component_count(x) == detail::component_count(y)"));

  vecType<bool, P> Result(uninitialize);
  for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
   Result[i] = x[i] < y[i];

  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<bool, P> lessThanEqual(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  ((detail::component_count(x) == detail::component_count(y)) ? (void)0 : __assert2("../glm/gtx/../detail/func_vector_relational.inl", 52, __PRETTY_FUNCTION__, "detail::component_count(x) == detail::component_count(y)"));

  vecType<bool, P> Result(uninitialize);
  for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
   Result[i] = x[i] <= y[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<bool, P> greaterThan(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  ((detail::component_count(x) == detail::component_count(y)) ? (void)0 : __assert2("../glm/gtx/../detail/func_vector_relational.inl", 63, __PRETTY_FUNCTION__, "detail::component_count(x) == detail::component_count(y)"));

  vecType<bool, P> Result(uninitialize);
  for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
   Result[i] = x[i] > y[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<bool, P> greaterThanEqual(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  ((detail::component_count(x) == detail::component_count(y)) ? (void)0 : __assert2("../glm/gtx/../detail/func_vector_relational.inl", 74, __PRETTY_FUNCTION__, "detail::component_count(x) == detail::component_count(y)"));

  vecType<bool, P> Result(uninitialize);
  for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
   Result[i] = x[i] >= y[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<bool, P> equal(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  ((detail::component_count(x) == detail::component_count(y)) ? (void)0 : __assert2("../glm/gtx/../detail/func_vector_relational.inl", 85, __PRETTY_FUNCTION__, "detail::component_count(x) == detail::component_count(y)"));

  vecType<bool, P> Result(uninitialize);
  for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
   Result[i] = x[i] == y[i];
  return Result;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<bool, P> notEqual(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  ((detail::component_count(x) == detail::component_count(y)) ? (void)0 : __assert2("../glm/gtx/../detail/func_vector_relational.inl", 96, __PRETTY_FUNCTION__, "detail::component_count(x) == detail::component_count(y)"));

  vecType<bool, P> Result(uninitialize);
  for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
   Result[i] = x[i] != y[i];
  return Result;
 }

 template <precision P, template <typename, precision> class vecType>
 inline bool any(vecType<bool, P> const & v)
 {
  bool Result = false;
  for(detail::component_count_t i = 0; i < detail::component_count(v); ++i)
   Result = Result || v[i];
  return Result;
 }

 template <precision P, template <typename, precision> class vecType>
 inline bool all(vecType<bool, P> const & v)
 {
  bool Result = true;
  for(detail::component_count_t i = 0; i < detail::component_count(v); ++i)
   Result = Result && v[i];
  return Result;
 }

 template <precision P, template <typename, precision> class vecType>
 inline vecType<bool, P> not_(vecType<bool, P> const & v)
 {
  vecType<bool, P> Result(uninitialize);
  for(detail::component_count_t i = 0; i < detail::component_count(v); ++i)
   Result[i] = !v[i];
  return Result;
 }
}
# 141 "../glm/gtx/../detail/func_vector_relational.hpp" 2
# 34 "../glm/gtx/../detail/func_exponential.inl" 2


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 1
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath"
       
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 3
# 37 "../glm/gtx/../detail/func_exponential.inl" 2
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cassert" 1
# 41 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cassert"
       
# 42 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cassert" 3

# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/assert.h" 1 3
# 62 "C:\\ndk/platforms/android-9/arch-arm/usr/include/assert.h" 3
extern "C" {
 void __assert(const char *, int, const char *);
 void __assert2(const char *, int, const char *, const char *);
}
# 43 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cassert" 2 3
# 38 "../glm/gtx/../detail/func_exponential.inl" 2

namespace glm{
namespace detail
{



  template <typename genType>
  genType log2(genType Value)
  {
   return std::log(Value) * static_cast<genType>(1.4426950408889634073599246810019);
  }


 template <typename T, precision P, template <class, precision> class vecType, bool isFloat = true>
 struct compute_log2
 {
  inline static vecType<T, P> call(vecType<T, P> const & vec)
  {
   return detail::functor1<T, T, P, vecType>::call(log2, vec);
  }
 };

 template <template <class, precision> class vecType, typename T, precision P>
 struct compute_inversesqrt
 {
  inline static vecType<T, P> call(vecType<T, P> const & x)
  {
   return static_cast<T>(1) / sqrt(x);
  }
 };

 template <template <class, precision> class vecType>
 struct compute_inversesqrt<vecType, float, lowp>
 {
  inline static vecType<float, lowp> call(vecType<float, lowp> const & x)
  {
   vecType<float, lowp> tmp(x);
   vecType<float, lowp> xhalf(tmp * 0.5f);
   vecType<uint, lowp>* p = reinterpret_cast<vecType<uint, lowp>*>(const_cast<vecType<float, lowp>*>(&x));
   vecType<uint, lowp> i = vecType<uint, lowp>(0x5f375a86) - (*p >> vecType<uint, lowp>(1));
   vecType<float, lowp>* ptmp = reinterpret_cast<vecType<float, lowp>*>(&i);
   tmp = *ptmp;
   tmp = tmp * (1.5f - xhalf * tmp * tmp);
   return tmp;
  }
 };
}


 using std::pow;
 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> pow(vecType<T, P> const & base, vecType<T, P> const & exponent)
 {
  return detail::functor2<T, P, vecType>::call(pow, base, exponent);
 }


 using std::exp;
 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> exp(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(exp, x);
 }


 using std::log;
 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> log(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(log, x);
 }


 template <typename genType>
 inline genType exp2(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'exp2' only accept floating-point inputs");

  return std::exp(static_cast<genType>(0.69314718055994530941723212145818) * x);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> exp2(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(exp2, x);
 }


 template <typename genType>
 inline genType log2(genType x)
 {
  return log2(tvec1<genType>(x)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> log2(vecType<T, P> const & x)
 {
  return detail::compute_log2<T, P, vecType, std::numeric_limits<T>::is_iec559>::call(x);
 }


 using std::sqrt;
 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> sqrt(vecType<T, P> const & x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'sqrt' only accept floating-point inputs");
  return detail::functor1<T, T, P, vecType>::call(sqrt, x);
 }


 template <typename genType>
 inline genType inversesqrt(genType x)
 {
  return static_cast<genType>(1) / sqrt(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> inversesqrt(vecType<T, P> const & x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'inversesqrt' only accept floating-point inputs");
  return detail::compute_inversesqrt<vecType, T, P>::call(x);
 }
}
# 133 "../glm/gtx/../detail/func_exponential.hpp" 2
# 36 "../glm/gtx/../exponential.hpp" 2
# 112 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../common.hpp" 1
# 33 "../glm/gtx/../common.hpp"
       

# 1 "../glm/gtx/../detail/func_common.hpp" 1
# 40 "../glm/gtx/../detail/func_common.hpp"
       




# 1 "../glm/gtx/../detail/_fixes.hpp" 1
# 33 "../glm/gtx/../detail/_fixes.hpp"
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 1
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath"
       
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cmath" 3
# 34 "../glm/gtx/../detail/_fixes.hpp" 2
# 46 "../glm/gtx/../detail/func_common.hpp" 2

namespace glm
{
# 58 "../glm/gtx/../detail/func_common.hpp"
 template <typename genType>
 genType abs(genType x);

 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> abs(vecType<T, P> const & x);







 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> sign(vecType<T, P> const & x);







 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> floor(vecType<T, P> const & x);
# 89 "../glm/gtx/../detail/func_common.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> trunc(vecType<T, P> const & x);
# 102 "../glm/gtx/../detail/func_common.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> round(vecType<T, P> const & x);
# 114 "../glm/gtx/../detail/func_common.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> roundEven(vecType<T, P> const & x);
# 124 "../glm/gtx/../detail/func_common.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> ceil(vecType<T, P> const & x);







 template <typename genType>
 genType fract(genType x);

 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> fract(vecType<T, P> const & x);
# 146 "../glm/gtx/../detail/func_common.hpp"
 template <typename genType>
 genType mod(genType x, genType y);

 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> mod(vecType<T, P> const & x, T y);

 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> mod(vecType<T, P> const & x, vecType<T, P> const & y);
# 164 "../glm/gtx/../detail/func_common.hpp"
 template <typename genType>
 genType modf(genType x, genType & i);







 template <typename genType>
 genType min(genType x, genType y);

 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> min(vecType<T, P> const & x, T y);

 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> min(vecType<T, P> const & x, vecType<T, P> const & y);







 template <typename genType>
 genType max(genType x, genType y);

 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> max(vecType<T, P> const & x, T y);

 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> max(vecType<T, P> const & x, vecType<T, P> const & y);
# 204 "../glm/gtx/../detail/func_common.hpp"
 template <typename genType>
 genType clamp(genType x, genType minVal, genType maxVal);

 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> clamp(vecType<T, P> const & x, T minVal, T maxVal);

 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> clamp(vecType<T, P> const & x, vecType<T, P> const & minVal, vecType<T, P> const & maxVal);
# 255 "../glm/gtx/../detail/func_common.hpp"
 template <typename T, typename U, precision P, template <typename, precision> class vecType>
 vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a);

 template <typename T, typename U, precision P, template <typename, precision> class vecType>
 vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, U a);

 template <typename genTypeT, typename genTypeU>
 genTypeT mix(genTypeT x, genTypeT y, genTypeU a);





 template <typename genType>
 genType step(genType edge, genType x);





 template <template <typename, precision> class vecType, typename T, precision P>
 vecType<T, P> step(T edge, vecType<T, P> const & x);





 template <template <typename, precision> class vecType, typename T, precision P>
 vecType<T, P> step(vecType<T, P> const & edge, vecType<T, P> const & x);
# 299 "../glm/gtx/../detail/func_common.hpp"
 template <typename genType>
 genType smoothstep(genType edge0, genType edge1, genType x);

 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> smoothstep(T edge0, T edge1, vecType<T, P> const & x);

 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> smoothstep(vecType<T, P> const & edge0, vecType<T, P> const & edge1, vecType<T, P> const & x);
# 320 "../glm/gtx/../detail/func_common.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<bool, P> isnan(vecType<T, P> const & x);
# 333 "../glm/gtx/../detail/func_common.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<bool, P> isinf(vecType<T, P> const & x);







 int floatBitsToInt(float const & v);







 template <template <typename, precision> class vecType, precision P>
 vecType<int, P> floatBitsToInt(vecType<float, P> const & v);







 uint floatBitsToUint(float const & v);







 template <template <typename, precision> class vecType, precision P>
 vecType<uint, P> floatBitsToUint(vecType<float, P> const & v);
# 378 "../glm/gtx/../detail/func_common.hpp"
 float intBitsToFloat(int const & v);
# 388 "../glm/gtx/../detail/func_common.hpp"
 template <template <typename, precision> class vecType, precision P>
 vecType<float, P> intBitsToFloat(vecType<int, P> const & v);
# 399 "../glm/gtx/../detail/func_common.hpp"
 float uintBitsToFloat(uint const & v);
# 409 "../glm/gtx/../detail/func_common.hpp"
 template <template <typename, precision> class vecType, precision P>
 vecType<float, P> uintBitsToFloat(vecType<uint, P> const & v);







 template <typename genType>
 genType fma(genType const & a, genType const & b, genType const & c);
# 435 "../glm/gtx/../detail/func_common.hpp"
 template <typename genType, typename genIType>
 genType frexp(genType const & x, genIType & exp);
# 449 "../glm/gtx/../detail/func_common.hpp"
 template <typename genType, typename genIType>
 genType ldexp(genType const & x, genIType const & exp);


}

# 1 "../glm/gtx/../detail/func_common.inl" 1
# 40 "../glm/gtx/../detail/func_common.inl"
namespace glm{
namespace detail
{
 template <typename genFIType, bool >
 struct compute_abs
 {};

 template <typename genFIType>
 struct compute_abs<genFIType, true>
 {
  inline static genFIType call(genFIType x)
  {
   static_assert(std::numeric_limits<genFIType>::is_iec559 || std::numeric_limits<genFIType>::is_signed, "'abs' only accept floating-point and integer scalar or vector inputs")

                                                                           ;

   return x >= genFIType(0) ? x : -x;

  }
 };

 template <typename genFIType>
 struct compute_abs<genFIType, false>
 {
  inline static genFIType call(genFIType x)
  {
   static_assert(!std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer, "'abs' only accept floating-point and integer scalar or vector inputs")

                                                                           ;
   return x;
  }
 };

 template <typename T, typename U, precision P, template <class, precision> class vecType>
 struct compute_mix_vector
 {
  inline static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a)
  {
   static_assert(std::numeric_limits<U>::is_iec559, "'mix' only accept floating-point inputs for the interpolator a");

   return vecType<T, P>(vecType<U, P>(x) + a * vecType<U, P>(y - x));
  }
 };

 template <typename T, precision P, template <class, precision> class vecType>
 struct compute_mix_vector<T, bool, P, vecType>
 {
  inline static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, vecType<bool, P> const & a)
  {
   vecType<T, P> Result(uninitialize);
   for(detail::component_count_t i = 0; i < detail::component_count(x); ++i)
    Result[i] = a[i] ? y[i] : x[i];
   return Result;
  }
 };

 template <typename T, typename U, precision P, template <class, precision> class vecType>
 struct compute_mix_scalar
 {
  inline static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, U const & a)
  {
   static_assert(std::numeric_limits<U>::is_iec559, "'mix' only accept floating-point inputs for the interpolator a");

   return vecType<T, P>(vecType<U, P>(x) + a * vecType<U, P>(y - x));
  }
 };

 template <typename T, precision P, template <class, precision> class vecType>
 struct compute_mix_scalar<T, bool, P, vecType>
 {
  inline static vecType<T, P> call(vecType<T, P> const & x, vecType<T, P> const & y, bool const & a)
  {
   return a ? y : x;
  }
 };

 template <typename T, typename U>
 struct compute_mix
 {
  inline static T call(T const & x, T const & y, U const & a)
  {
   static_assert(std::numeric_limits<U>::is_iec559, "'mix' only accept floating-point inputs for the interpolator a");

   return static_cast<T>(static_cast<U>(x) + a * static_cast<U>(y - x));
  }
 };

 template <typename T>
 struct compute_mix<T, bool>
 {
  inline static T call(T const & x, T const & y, bool const & a)
  {
   return a ? y : x;
  }
 };

 template <typename T, precision P, template <class, precision> class vecType, bool isFloat = true, bool isSigned = true>
 struct compute_sign
 {
  inline static vecType<T, P> call(vecType<T, P> const & x)
  {
   return vecType<T, P>(glm::lessThan(vecType<T, P>(0), x)) - vecType<T, P>(glm::lessThan(x, vecType<T, P>(0)));
  }
 };

 template <typename T, precision P, template <class, precision> class vecType>
 struct compute_sign<T, P, vecType, false, false>
 {
  inline static vecType<T, P> call(vecType<T, P> const & x)
  {
   return vecType<T, P>(glm::greaterThan(x , vecType<T, P>(0)));
  }
 };

 template <typename T, precision P, template <class, precision> class vecType>
 struct compute_sign<T, P, vecType, false, true>
 {
  inline static vecType<T, P> call(vecType<T, P> const & x)
  {
   T const Shift(static_cast<T>(sizeof(T) * 8 - 1));
   vecType<T, P> const y(vecType<typename make_unsigned<T>::type, P>(-x) >> typename make_unsigned<T>::type(Shift));

   return (x >> Shift) | y;
  }
 };

 template <typename T, precision P, template <class, precision> class vecType, typename genType, bool isFloat = true>
 struct compute_mod
 {
  inline static vecType<T, P> call(vecType<T, P> const & a, genType const & b)
  {
   static_assert(std::numeric_limits<T>::is_iec559, "'mod' only accept floating-point inputs. Include <glm/gtc/integer.hpp> for integer inputs.");
   return a - b * floor(a / b);
  }
 };
}


 template <>
 inline int32 abs(int32 x)
 {
  int32 const y = x >> 31;
  return (x ^ y) - y;
 }

 template <typename genFIType>
 inline genFIType abs(genFIType x)
 {
  return detail::compute_abs<genFIType, std::numeric_limits<genFIType>::is_signed>::call(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> abs(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(abs, x);
 }



 template <typename genFIType>
 inline genFIType sign(genFIType x)
 {
  static_assert(std::numeric_limits<genFIType>::is_iec559 || (std::numeric_limits<genFIType>::is_signed && std::numeric_limits<genFIType>::is_integer), "'sign' only accept signed inputs")

                                      ;

  return detail::compute_sign<genFIType, defaultp, tvec1, std::numeric_limits<genFIType>::is_iec559>::call(tvec1<genFIType>(x)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> sign(vecType<T, P> const & x)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || (std::numeric_limits<T>::is_signed && std::numeric_limits<T>::is_integer), "'sign' only accept signed inputs")

                                      ;

  return detail::compute_sign<T, P, vecType, std::numeric_limits<T>::is_iec559>::call(x);
 }


 using ::std::floor;
 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> floor(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(floor, x);
 }





  template <typename genType>
  inline genType trunc(genType x)
  {
   static_assert(std::numeric_limits<genType>::is_iec559, "'trunc' only accept floating-point inputs");

   return x < static_cast<genType>(0) ? -floor(-x) : floor(x);
  }


 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> trunc(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(trunc, x);
 }





  template <typename genType>
  inline genType round(genType x)
  {
   static_assert(std::numeric_limits<genType>::is_iec559, "'round' only accept floating-point inputs");

   return x < static_cast<genType>(0) ? static_cast<genType>(int(x - static_cast<genType>(0.5))) : static_cast<genType>(int(x + static_cast<genType>(0.5)));
  }


 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> round(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(round, x);
 }
# 277 "../glm/gtx/../detail/func_common.inl"
 template <typename genType>
 inline genType roundEven(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'roundEven' only accept floating-point inputs");

  int Integer = static_cast<int>(x);
  genType IntegerPart = static_cast<genType>(Integer);
  genType FractionalPart = fract(x);

  if(FractionalPart > static_cast<genType>(0.5) || FractionalPart < static_cast<genType>(0.5))
  {
   return round(x);
  }
  else if((Integer % 2) == 0)
  {
   return IntegerPart;
  }
  else if(x <= static_cast<genType>(0))
  {
   return IntegerPart - static_cast<genType>(1);
  }
  else
  {
   return IntegerPart + static_cast<genType>(1);
  }




 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> roundEven(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(roundEven, x);
 }


 using ::std::ceil;
 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> ceil(vecType<T, P> const & x)
 {
  return detail::functor1<T, T, P, vecType>::call(ceil, x);
 }


 template <typename genType>
 inline genType fract(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'fract' only accept floating-point inputs");

  return fract(tvec1<genType>(x)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> fract(vecType<T, P> const & x)
 {
  return x - floor(x);
 }


 template <typename genType>
 inline genType mod(genType x, genType y)
 {
  return mod(tvec1<genType>(x), y).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> mod(vecType<T, P> const & x, T y)
 {
  return detail::compute_mod<T, P, vecType, T, std::numeric_limits<T>::is_iec559>::call(x, y);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> mod(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  return detail::compute_mod<T, P, vecType, vecType<T, P>, std::numeric_limits<T>::is_iec559>::call(x, y);
 }


 template <typename genType>
 inline genType modf(genType x, genType & i)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'modf' only accept floating-point inputs");

  return std::modf(x, &i);
 }

 template <typename T, precision P>
 inline tvec1<T, P> modf(tvec1<T, P> const & x, tvec1<T, P> & i)
 {
  return tvec1<T, P>(
   modf(x.x, i.x));
 }

 template <typename T, precision P>
 inline tvec2<T, P> modf(tvec2<T, P> const & x, tvec2<T, P> & i)
 {
  return tvec2<T, P>(
   modf(x.x, i.x),
   modf(x.y, i.y));
 }

 template <typename T, precision P>
 inline tvec3<T, P> modf(tvec3<T, P> const & x, tvec3<T, P> & i)
 {
  return tvec3<T, P>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z));
 }

 template <typename T, precision P>
 inline tvec4<T, P> modf(tvec4<T, P> const & x, tvec4<T, P> & i)
 {
  return tvec4<T, P>(
   modf(x.x, i.x),
   modf(x.y, i.y),
   modf(x.z, i.z),
   modf(x.w, i.w));
 }
# 408 "../glm/gtx/../detail/func_common.inl"
 template <typename genType>
 inline genType min(genType x, genType y)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, "'min' only accept floating-point or integer inputs");

  return x < y ? x : y;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> min(vecType<T, P> const & a, T b)
 {
  return detail::functor2_vec_sca<T, P, vecType>::call(min, a, b);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> min(vecType<T, P> const & a, vecType<T, P> const & b)
 {
  return detail::functor2<T, P, vecType>::call(min, a, b);
 }


 template <typename genType>
 inline genType max(genType x, genType y)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, "'max' only accept floating-point or integer inputs");

  return x > y ? x : y;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> max(vecType<T, P> const & a, T b)
 {
  return detail::functor2_vec_sca<T, P, vecType>::call(max, a, b);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> max(vecType<T, P> const & a, vecType<T, P> const & b)
 {
  return detail::functor2<T, P, vecType>::call(max, a, b);
 }


 template <typename genType>
 inline genType clamp(genType x, genType minVal, genType maxVal)
 {
  static_assert(std::numeric_limits<genType>::is_iec559 || std::numeric_limits<genType>::is_integer, "'clamp' only accept floating-point or integer inputs");

  return min(max(x, minVal), maxVal);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> clamp(vecType<T, P> const & x, T minVal, T maxVal)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs");

  return min(max(x, minVal), maxVal);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> clamp(vecType<T, P> const & x, vecType<T, P> const & minVal, vecType<T, P> const & maxVal)
 {
  static_assert(std::numeric_limits<T>::is_iec559 || std::numeric_limits<T>::is_integer, "'clamp' only accept floating-point or integer inputs");

  return min(max(x, minVal), maxVal);
 }

 template <typename genTypeT, typename genTypeU>
 inline genTypeT mix(genTypeT x, genTypeT y, genTypeU a)
 {
  return detail::compute_mix<genTypeT, genTypeU>::call(x, y, a);
 }

 template <typename T, typename U, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, U a)
 {
  return detail::compute_mix_scalar<T, U, P, vecType>::call(x, y, a);
 }

 template <typename T, typename U, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> mix(vecType<T, P> const & x, vecType<T, P> const & y, vecType<U, P> const & a)
 {
  return detail::compute_mix_vector<T, U, P, vecType>::call(x, y, a);
 }


 template <typename genType>
 inline genType step(genType edge, genType x)
 {
  return mix(static_cast<genType>(1), static_cast<genType>(0), glm::lessThan(x, edge));
 }

 template <template <typename, precision> class vecType, typename T, precision P>
 inline vecType<T, P> step(T edge, vecType<T, P> const & x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'step' only accept floating-point inputs");

  return mix(vecType<T, P>(1), vecType<T, P>(0), glm::lessThan(x, vecType<T, P>(edge)));
 }

 template <template <typename, precision> class vecType, typename T, precision P>
 inline vecType<T, P> step(vecType<T, P> const & edge, vecType<T, P> const & x)
 {
  return mix(vecType<T, P>(1), vecType<T, P>(0), glm::lessThan(x, edge));
 }


 template <typename genType>
 inline genType smoothstep(genType edge0, genType edge1, genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'smoothstep' only accept floating-point inputs");

  genType const tmp(clamp((x - edge0) / (edge1 - edge0), genType(0), genType(1)));
  return tmp * tmp * (genType(3) - genType(2) * tmp);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> smoothstep(T edge0, T edge1, vecType<T, P> const & x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'smoothstep' only accept floating-point inputs");

  vecType<T, P> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
  return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> smoothstep(vecType<T, P> const & edge0, vecType<T, P> const & edge1, vecType<T, P> const & x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'smoothstep' only accept floating-point inputs");

  vecType<T, P> const tmp(clamp((x - edge0) / (edge1 - edge0), static_cast<T>(0), static_cast<T>(1)));
  return tmp * tmp * (static_cast<T>(3) - static_cast<T>(2) * tmp);
 }




  template <typename genType>
  inline bool isnan(genType x)
  {
   static_assert(std::numeric_limits<genType>::is_iec559, "'isnan' only accept floating-point inputs");
# 557 "../glm/gtx/../detail/func_common.inl"
     return std::isnan(x);






  }


 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<bool, P> isnan(vecType<T, P> const & x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'isnan' only accept floating-point inputs");

  return detail::functor1<bool, T, P, vecType>::call(isnan, x);
 }




  template <typename genType>
  inline bool isinf(genType x)
  {
   static_assert(std::numeric_limits<genType>::is_iec559, "'isinf' only accept floating-point inputs");
# 591 "../glm/gtx/../detail/func_common.inl"
     return std::isinf(x);







 }


 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<bool, P> isinf(vecType<T, P> const & x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'isnan' only accept floating-point inputs");

  return detail::functor1<bool, T, P, vecType>::call(isinf, x);
 }

 inline int floatBitsToInt(float const & v)
 {
  return reinterpret_cast<int&>(const_cast<float&>(v));
 }

 template <template <typename, precision> class vecType, precision P>
 inline vecType<int, P> floatBitsToInt(vecType<float, P> const & v)
 {
  return reinterpret_cast<vecType<int, P>&>(const_cast<vecType<float, P>&>(v));
 }

 inline uint floatBitsToUint(float const & v)
 {
  return reinterpret_cast<uint&>(const_cast<float&>(v));
 }

 template <template <typename, precision> class vecType, precision P>
 inline vecType<uint, P> floatBitsToUint(vecType<float, P> const & v)
 {
  return reinterpret_cast<vecType<uint, P>&>(const_cast<vecType<float, P>&>(v));
 }

 inline float intBitsToFloat(int const & v)
 {
  return reinterpret_cast<float&>(const_cast<int&>(v));
 }

 template <template <typename, precision> class vecType, precision P>
 inline vecType<float, P> intBitsToFloat(vecType<int, P> const & v)
 {
  return reinterpret_cast<vecType<float, P>&>(const_cast<vecType<int, P>&>(v));
 }

 inline float uintBitsToFloat(uint const & v)
 {
  return reinterpret_cast<float&>(const_cast<uint&>(v));
 }

 template <template <typename, precision> class vecType, precision P>
 inline vecType<float, P> uintBitsToFloat(vecType<uint, P> const & v)
 {
  return reinterpret_cast<vecType<float, P>&>(const_cast<vecType<uint, P>&>(v));
 }

 template <typename genType>
 inline genType fma(genType const & a, genType const & b, genType const & c)
 {
  return a * b + c;
 }

 template <typename genType>
 inline genType frexp(genType x, int & exp)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'frexp' only accept floating-point inputs");

  return std::frexp(x, exp);
 }

 template <typename T, precision P>
 inline tvec1<T, P> frexp(tvec1<T, P> const & x, tvec1<int, P> & exp)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'frexp' only accept floating-point inputs");

  return tvec1<T, P>(std::frexp(x.x, exp.x));
 }

 template <typename T, precision P>
 inline tvec2<T, P> frexp(tvec2<T, P> const & x, tvec2<int, P> & exp)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'frexp' only accept floating-point inputs");

  return tvec2<T, P>(
   frexp(x.x, exp.x),
   frexp(x.y, exp.y));
 }

 template <typename T, precision P>
 inline tvec3<T, P> frexp(tvec3<T, P> const & x, tvec3<int, P> & exp)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'frexp' only accept floating-point inputs");

  return tvec3<T, P>(
   frexp(x.x, exp.x),
   frexp(x.y, exp.y),
   frexp(x.z, exp.z));
 }

 template <typename T, precision P>
 inline tvec4<T, P> frexp(tvec4<T, P> const & x, tvec4<int, P> & exp)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'frexp' only accept floating-point inputs");

  return tvec4<T, P>(
   frexp(x.x, exp.x),
   frexp(x.y, exp.y),
   frexp(x.z, exp.z),
   frexp(x.w, exp.w));
 }

 template <typename genType, precision P>
 inline genType ldexp(genType const & x, int const & exp)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'ldexp' only accept floating-point inputs");

  return std::ldexp(x, exp);
 }

 template <typename T, precision P>
 inline tvec1<T, P> ldexp(tvec1<T, P> const & x, tvec1<int, P> const & exp)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'ldexp' only accept floating-point inputs");

  return tvec1<T, P>(
   ldexp(x.x, exp.x));
 }

 template <typename T, precision P>
 inline tvec2<T, P> ldexp(tvec2<T, P> const & x, tvec2<int, P> const & exp)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'ldexp' only accept floating-point inputs");

  return tvec2<T, P>(
   ldexp(x.x, exp.x),
   ldexp(x.y, exp.y));
 }

 template <typename T, precision P>
 inline tvec3<T, P> ldexp(tvec3<T, P> const & x, tvec3<int, P> const & exp)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'ldexp' only accept floating-point inputs");

  return tvec3<T, P>(
   ldexp(x.x, exp.x),
   ldexp(x.y, exp.y),
   ldexp(x.z, exp.z));
 }

 template <typename T, precision P>
 inline tvec4<T, P> ldexp(tvec4<T, P> const & x, tvec4<int, P> const & exp)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'ldexp' only accept floating-point inputs");

  return tvec4<T, P>(
   ldexp(x.x, exp.x),
   ldexp(x.y, exp.y),
   ldexp(x.z, exp.z),
   ldexp(x.w, exp.w));
 }
}
# 456 "../glm/gtx/../detail/func_common.hpp" 2
# 36 "../glm/gtx/../common.hpp" 2
# 113 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../packing.hpp" 1
# 33 "../glm/gtx/../packing.hpp"
       

# 1 "../glm/gtx/../detail/func_packing.hpp" 1
# 41 "../glm/gtx/../detail/func_packing.hpp"
       




namespace glm
{
# 62 "../glm/gtx/../detail/func_packing.hpp"
 uint packUnorm2x16(vec2 const & v);
# 75 "../glm/gtx/../detail/func_packing.hpp"
 uint packSnorm2x16(vec2 const & v);
# 88 "../glm/gtx/../detail/func_packing.hpp"
 uint packUnorm4x8(vec4 const & v);
# 101 "../glm/gtx/../detail/func_packing.hpp"
 uint packSnorm4x8(vec4 const & v);
# 114 "../glm/gtx/../detail/func_packing.hpp"
 vec2 unpackUnorm2x16(uint const & p);
# 127 "../glm/gtx/../detail/func_packing.hpp"
 vec2 unpackSnorm2x16(uint const & p);
# 140 "../glm/gtx/../detail/func_packing.hpp"
 vec4 unpackUnorm4x8(uint const & p);
# 153 "../glm/gtx/../detail/func_packing.hpp"
 vec4 unpackSnorm4x8(uint const & p);
# 163 "../glm/gtx/../detail/func_packing.hpp"
 double packDouble2x32(uvec2 const & v);
# 172 "../glm/gtx/../detail/func_packing.hpp"
 uvec2 unpackDouble2x32(double const & v);
# 182 "../glm/gtx/../detail/func_packing.hpp"
 uint packHalf2x16(vec2 const & v);
# 192 "../glm/gtx/../detail/func_packing.hpp"
 vec2 unpackHalf2x16(uint const & v);


}

# 1 "../glm/gtx/../detail/func_packing.inl" 1
# 34 "../glm/gtx/../detail/func_packing.inl"
# 1 "../glm/gtx/../detail/type_half.hpp" 1
# 33 "../glm/gtx/../detail/type_half.hpp"
       



namespace glm{
namespace detail
{
 typedef short hdata;

 float toFloat32(hdata value);
 hdata toFloat16(float const & value);

}
}

# 1 "../glm/gtx/../detail/type_half.inl" 1
# 37 "../glm/gtx/../detail/type_half.inl"
namespace glm{
namespace detail
{
 inline float overflow()
 {
  volatile float f = 1e10;

  for(int i = 0; i < 10; ++i)
   f *= f;
  return f;
 }

 union uif32
 {
  inline uif32() :
   i(0)
  {}

  inline uif32(float f) :
   f(f)
  {}

  inline uif32(uint32 i) :
   i(i)
  {}

  float f;
  uint32 i;
 };

 inline float toFloat32(hdata value)
 {
  int s = (value >> 15) & 0x00000001;
  int e = (value >> 10) & 0x0000001f;
  int m = value & 0x000003ff;

  if(e == 0)
  {
   if(m == 0)
   {




    detail::uif32 result;
    result.i = (unsigned int)(s << 31);
    return result.f;
   }
   else
   {




    while(!(m & 0x00000400))
    {
     m <<= 1;
     e -= 1;
    }

    e += 1;
    m &= ~0x00000400;
   }
  }
  else if(e == 31)
  {
   if(m == 0)
   {




    uif32 result;
    result.i = (unsigned int)((s << 31) | 0x7f800000);
    return result.f;
   }
   else
   {




    uif32 result;
    result.i = (unsigned int)((s << 31) | 0x7f800000 | (m << 13));
    return result.f;
   }
  }





  e = e + (127 - 15);
  m = m << 13;





  uif32 Result;
  Result.i = (unsigned int)((s << 31) | (e << 23) | m);
  return Result.f;
 }

 inline hdata toFloat16(float const & f)
 {
  uif32 Entry;
  Entry.f = f;
  int i = (int)Entry.i;
# 157 "../glm/gtx/../detail/type_half.inl"
  int s = (i >> 16) & 0x00008000;
  int e = ((i >> 23) & 0x000000ff) - (127 - 15);
  int m = i & 0x007fffff;





  if(e <= 0)
  {
   if(e < -10)
   {
# 177 "../glm/gtx/../detail/type_half.inl"
    return hdata(s);
   }
# 187 "../glm/gtx/../detail/type_half.inl"
   m = (m | 0x00800000) >> (1 - e);
# 198 "../glm/gtx/../detail/type_half.inl"
   if(m & 0x00001000)
    m += 0x00002000;





   return hdata(s | (m >> 13));
  }
  else if(e == 0xff - (127 - 15))
  {
   if(m == 0)
   {





    return hdata(s | 0x7c00);
   }
   else
   {
# 229 "../glm/gtx/../detail/type_half.inl"
    m >>= 13;

    return hdata(s | 0x7c00 | m | (m == 0));
   }
  }
  else
  {
# 245 "../glm/gtx/../detail/type_half.inl"
   if(m & 0x00001000)
   {
    m += 0x00002000;

    if(m & 0x00800000)
    {
     m = 0;
     e += 1;
    }
   }





   if (e > 30)
   {
    overflow();

    return hdata(s | 0x7c00);

   }





   return hdata(s | (e << 10) | (m >> 13));
  }
 }

}
}
# 49 "../glm/gtx/../detail/type_half.hpp" 2
# 35 "../glm/gtx/../detail/func_packing.inl" 2


namespace glm
{
 inline uint packUnorm2x16(vec2 const & v)
 {
  u16vec2 Topack(round(clamp(v, 0.0f, 1.0f) * 65535.0f));

    uint* ptr(reinterpret_cast<uint*>(&Topack));
    return *ptr;
 }

 inline vec2 unpackUnorm2x16(uint const & p)
 {
  vec2 Unpack(reinterpret_cast<u16vec2 const &>(p));
  return Unpack * float(1.5259021896696421759365224689097e-5);
 }

 inline uint packSnorm2x16(vec2 const & v)
 {
  i16vec2 Topack(round(clamp(v ,-1.0f, 1.0f) * 32767.0f));

    uint* ptr(reinterpret_cast<uint*>(&Topack));
    return *ptr;
 }

 inline vec2 unpackSnorm2x16(uint const & p)
 {
  vec2 Unpack(reinterpret_cast<i16vec2 const &>(p));
  return clamp(
   Unpack * 3.0518509475997192297128208258309e-5f,
   -1.0f, 1.0f);
 }

 inline uint packUnorm4x8(vec4 const & v)
 {
  u8vec4 Topack(round(clamp(v, 0.0f, 1.0f) * 255.0f));
  return reinterpret_cast<uint&>(Topack);
 }

 inline vec4 unpackUnorm4x8(uint const & p)
 {
  vec4 Unpack(reinterpret_cast<u8vec4 const&>(p));
  return Unpack * float(0.0039215686274509803921568627451);
 }

 inline uint packSnorm4x8(vec4 const & v)
 {
  i8vec4 Topack(round(clamp(v ,-1.0f, 1.0f) * 127.0f));
  return reinterpret_cast<uint&>(Topack);
 }

 inline glm::vec4 unpackSnorm4x8(uint const & p)
 {
  vec4 Unpack(reinterpret_cast<i8vec4 const &>(p));
  return clamp(
   Unpack * 0.0078740157480315f,
   -1.0f, 1.0f);
 }

 inline double packDouble2x32(uvec2 const & v)
 {
  return reinterpret_cast<double const &>(v);
 }

 inline uvec2 unpackDouble2x32(double const & v)
 {
  return reinterpret_cast<uvec2 const &>(v);
 }

 inline uint packHalf2x16(vec2 const & v)
 {
  i16vec2 Unpack(
   detail::toFloat16(v.x),
   detail::toFloat16(v.y));

  uint * Result = reinterpret_cast<uint*>(&Unpack);
  return *Result;
 }

 inline vec2 unpackHalf2x16(uint const & v)
 {
  i16vec2 Unpack(reinterpret_cast<i16vec2 const &>(v));

  return vec2(
   detail::toFloat32(Unpack.x),
   detail::toFloat32(Unpack.y));
 }
}
# 198 "../glm/gtx/../detail/func_packing.hpp" 2
# 36 "../glm/gtx/../packing.hpp" 2
# 114 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../geometric.hpp" 1
# 33 "../glm/gtx/../geometric.hpp"
       

# 1 "../glm/gtx/../detail/func_geometric.hpp" 1
# 40 "../glm/gtx/../detail/func_geometric.hpp"
       



namespace glm
{
# 55 "../glm/gtx/../detail/func_geometric.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 T length(
  vecType<T, P> const & x);







 template <typename T, precision P, template <typename, precision> class vecType>
 T distance(
  vecType<T, P> const & p0,
  vecType<T, P> const & p1);







 template <typename T, precision P, template <typename, precision> class vecType>
 T dot(
  vecType<T, P> const & x,
  vecType<T, P> const & y);







 template <typename T, precision P>
 tvec3<T, P> cross(
  tvec3<T, P> const & x,
  tvec3<T, P> const & y);






 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> normalize(
  vecType<T, P> const & x);







 template <typename genType>
 genType faceforward(
  genType const & N,
  genType const & I,
  genType const & Nref);
# 120 "../glm/gtx/../detail/func_geometric.hpp"
 template <typename genType>
 genType reflect(
  genType const & I,
  genType const & N);
# 133 "../glm/gtx/../detail/func_geometric.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> refract(
  vecType<T, P> const & I,
  vecType<T, P> const & N,
  T eta);


}

# 1 "../glm/gtx/../detail/func_geometric.inl" 1
# 39 "../glm/gtx/../detail/func_geometric.inl"
namespace glm{
namespace detail
{
 template <template <class, precision> class vecType, typename T, precision P>
 struct compute_dot{};

 template <typename T, precision P>
 struct compute_dot<tvec1, T, P>
 {
  inline static T call(tvec1<T, P> const & a, tvec1<T, P> const & b)
  {
   return a.x * b.x;
  }
 };

 template <typename T, precision P>
 struct compute_dot<tvec2, T, P>
 {
  inline static T call(tvec2<T, P> const & x, tvec2<T, P> const & y)
  {
   tvec2<T, P> tmp(x * y);
   return tmp.x + tmp.y;
  }
 };

 template <typename T, precision P>
 struct compute_dot<tvec3, T, P>
 {
  inline static T call(tvec3<T, P> const & x, tvec3<T, P> const & y)
  {
   tvec3<T, P> tmp(x * y);
   return tmp.x + tmp.y + tmp.z;
  }
 };

 template <typename T, precision P>
 struct compute_dot<tvec4, T, P>
 {
  inline static T call(tvec4<T, P> const & x, tvec4<T, P> const & y)
  {
   tvec4<T, P> tmp(x * y);
   return (tmp.x + tmp.y) + (tmp.z + tmp.w);
  }
 };
}


 template <typename genType>
 inline genType length(genType x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'length' only accept floating-point inputs");

  return abs(x);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline T length(vecType<T, P> const & v)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'length' only accept floating-point inputs");

  return sqrt(dot(v, v));
 }


 template <typename genType>
 inline genType distance(genType const & p0, genType const & p1)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'distance' only accept floating-point inputs");

  return length(p1 - p0);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline T distance(vecType<T, P> const & p0, vecType<T, P> const & p1)
 {
  return length(p1 - p0);
 }


 template <typename T>
 inline T dot(T x, T y)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'dot' only accept floating-point inputs");
  return x * y;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline T dot(vecType<T, P> const & x, vecType<T, P> const & y)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'dot' only accept floating-point inputs");
  return detail::compute_dot<vecType, T, P>::call(x, y);
 }


 template <typename T, precision P>
 inline tvec3<T, P> cross(tvec3<T, P> const & x, tvec3<T, P> const & y)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'cross' only accept floating-point inputs");

  return tvec3<T, P>(
   x.y * y.z - y.y * x.z,
   x.z * y.x - y.z * x.x,
   x.x * y.y - y.x * x.y);
 }


 template <typename genType>
 inline genType normalize(genType const & x)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'normalize' only accept floating-point inputs");

  return x < genType(0) ? genType(-1) : genType(1);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> normalize(vecType<T, P> const & x)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'normalize' only accept floating-point inputs");

  return x * inversesqrt(dot(x, x));
 }


 template <typename genType>
 inline genType faceforward(genType const & N, genType const & I, genType const & Nref)
 {
  return dot(Nref, I) < static_cast<genType>(0) ? N : -N;
 }


 template <typename genType>
 inline genType reflect(genType const & I, genType const & N)
 {
  return I - N * dot(N, I) * static_cast<genType>(2);
 }


 template <typename genType>
 inline genType refract(genType const & I, genType const & N, genType const & eta)
 {
  static_assert(std::numeric_limits<genType>::is_iec559, "'refract' only accept floating-point inputs");

  genType const dotValue(dot(N, I));
  genType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));
  return (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> refract(vecType<T, P> const & I, vecType<T, P> const & N, T eta)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'refract' only accept floating-point inputs");

  T const dotValue(dot(N, I));
  T const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));
  return (eta * I - (eta * dotValue + std::sqrt(k)) * N) * static_cast<T>(k >= static_cast<T>(0));
 }
}
# 143 "../glm/gtx/../detail/func_geometric.hpp" 2
# 36 "../glm/gtx/../geometric.hpp" 2
# 115 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../matrix.hpp" 1
# 33 "../glm/gtx/../matrix.hpp"
       

# 1 "../glm/gtx/../detail/func_matrix.hpp" 1
# 44 "../glm/gtx/../detail/func_matrix.hpp"
       
# 63 "../glm/gtx/../detail/func_matrix.hpp"
namespace glm{
namespace detail
{
 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec2, tvec2>
 {
  typedef tmat2x2<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec2, tvec3>
 {
  typedef tmat2x3<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec2, tvec4>
 {
  typedef tmat2x4<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec3, tvec2>
 {
  typedef tmat3x2<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec3, tvec3>
 {
  typedef tmat3x3<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec3, tvec4>
 {
  typedef tmat3x4<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec4, tvec2>
 {
  typedef tmat4x2<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec4, tvec3>
 {
  typedef tmat4x3<T, P> type;
 };

 template <typename T, precision P>
 struct outerProduct_trait<T, P, tvec4, tvec4>
 {
  typedef tmat4x4<T, P> type;
 };

}
# 132 "../glm/gtx/../detail/func_matrix.hpp"
 template <typename T, precision P, template <typename, precision> class matType>
 matType<T, P> matrixCompMult(matType<T, P> const & x, matType<T, P> const & y);
# 143 "../glm/gtx/../detail/func_matrix.hpp"
 template <typename T, precision P, template <typename, precision> class vecTypeA, template <typename, precision> class vecTypeB>
 typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type outerProduct(vecTypeA<T, P> const & c, vecTypeB<T, P> const & r);
# 163 "../glm/gtx/../detail/func_matrix.hpp"
 template <typename T, precision P, template <typename, precision> class matType>
 T determinant(matType<T, P> const & m);







 template <typename T, precision P, template <typename, precision> class matType>
 matType<T, P> inverse(matType<T, P> const & m);


}

# 1 "../glm/gtx/../detail/func_matrix.inl" 1
# 36 "../glm/gtx/../detail/func_matrix.inl"
namespace glm{
namespace detail
{
 template <template <class, precision> class matType, typename T, precision P>
 struct compute_transpose{};

 template <typename T, precision P>
 struct compute_transpose<tmat2x2, T, P>
 {
  inline static tmat2x2<T, P> call(tmat2x2<T, P> const & m)
  {
   tmat2x2<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   return result;
  }
 };

 template <typename T, precision P>
 struct compute_transpose<tmat2x3, T, P>
 {
  inline static tmat3x2<T, P> call(tmat2x3<T, P> const & m)
  {
   tmat3x2<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   return result;
  }
 };

 template <typename T, precision P>
 struct compute_transpose<tmat2x4, T, P>
 {
  inline static tmat4x2<T, P> call(tmat2x4<T, P> const & m)
  {
   tmat4x2<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[3][0] = m[0][3];
   result[3][1] = m[1][3];
   return result;
  }
 };

 template <typename T, precision P>
 struct compute_transpose<tmat3x2, T, P>
 {
  inline static tmat2x3<T, P> call(tmat3x2<T, P> const & m)
  {
   tmat2x3<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   return result;
  }
 };

 template <typename T, precision P>
 struct compute_transpose<tmat3x3, T, P>
 {
  inline static tmat3x3<T, P> call(tmat3x3<T, P> const & m)
  {
   tmat3x3<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];

   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];

   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[2][2] = m[2][2];
   return result;
  }
 };

 template <typename T, precision P>
 struct compute_transpose<tmat3x4, T, P>
 {
  inline static tmat4x3<T, P> call(tmat3x4<T, P> const & m)
  {
   tmat4x3<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[2][2] = m[2][2];
   result[3][0] = m[0][3];
   result[3][1] = m[1][3];
   result[3][2] = m[2][3];
   return result;
  }
 };

 template <typename T, precision P>
 struct compute_transpose<tmat4x2, T, P>
 {
  inline static tmat2x4<T, P> call(tmat4x2<T, P> const & m)
  {
   tmat2x4<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[0][3] = m[3][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   result[1][3] = m[3][1];
   return result;
  }
 };

 template <typename T, precision P>
 struct compute_transpose<tmat4x3, T, P>
 {
  inline static tmat3x4<T, P> call(tmat4x3<T, P> const & m)
  {
   tmat3x4<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[0][3] = m[3][0];
   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   result[1][3] = m[3][1];
   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[2][2] = m[2][2];
   result[2][3] = m[3][2];
   return result;
  }
 };

 template <typename T, precision P>
 struct compute_transpose<tmat4x4, T, P>
 {
  inline static tmat4x4<T, P> call(tmat4x4<T, P> const & m)
  {
   tmat4x4<T, P> result(uninitialize);
   result[0][0] = m[0][0];
   result[0][1] = m[1][0];
   result[0][2] = m[2][0];
   result[0][3] = m[3][0];

   result[1][0] = m[0][1];
   result[1][1] = m[1][1];
   result[1][2] = m[2][1];
   result[1][3] = m[3][1];

   result[2][0] = m[0][2];
   result[2][1] = m[1][2];
   result[2][2] = m[2][2];
   result[2][3] = m[3][2];

   result[3][0] = m[0][3];
   result[3][1] = m[1][3];
   result[3][2] = m[2][3];
   result[3][3] = m[3][3];
   return result;
  }
 };

 template <template <class, precision> class matType, typename T, precision P>
 struct compute_determinant{};

 template <typename T, precision P>
 struct compute_determinant<tmat2x2, T, P>
 {
  inline static T call(tmat2x2<T, P> const & m)
  {
   return m[0][0] * m[1][1] - m[1][0] * m[0][1];
  }
 };

 template <typename T, precision P>
 struct compute_determinant<tmat3x3, T, P>
 {
  inline static T call(tmat3x3<T, P> const & m)
  {
   return
    + m[0][0] * (m[1][1] * m[2][2] - m[2][1] * m[1][2])
    - m[1][0] * (m[0][1] * m[2][2] - m[2][1] * m[0][2])
    + m[2][0] * (m[0][1] * m[1][2] - m[1][1] * m[0][2]);
  }
 };

 template <typename T, precision P>
 struct compute_determinant<tmat4x4, T, P>
 {
  inline static T call(tmat4x4<T, P> const & m)
  {
   T SubFactor00 = m[2][2] * m[3][3] - m[3][2] * m[2][3];
   T SubFactor01 = m[2][1] * m[3][3] - m[3][1] * m[2][3];
   T SubFactor02 = m[2][1] * m[3][2] - m[3][1] * m[2][2];
   T SubFactor03 = m[2][0] * m[3][3] - m[3][0] * m[2][3];
   T SubFactor04 = m[2][0] * m[3][2] - m[3][0] * m[2][2];
   T SubFactor05 = m[2][0] * m[3][1] - m[3][0] * m[2][1];

   tvec4<T, P> DetCof(
    + (m[1][1] * SubFactor00 - m[1][2] * SubFactor01 + m[1][3] * SubFactor02),
    - (m[1][0] * SubFactor00 - m[1][2] * SubFactor03 + m[1][3] * SubFactor04),
    + (m[1][0] * SubFactor01 - m[1][1] * SubFactor03 + m[1][3] * SubFactor05),
    - (m[1][0] * SubFactor02 - m[1][1] * SubFactor04 + m[1][2] * SubFactor05));

   return
    m[0][0] * DetCof[0] + m[0][1] * DetCof[1] +
    m[0][2] * DetCof[2] + m[0][3] * DetCof[3];
  }
 };
}

 template <typename T, precision P, template <typename, precision> class matType>
 inline matType<T, P> matrixCompMult(matType<T, P> const & x, matType<T, P> const & y)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'matrixCompMult' only accept floating-point inputs");

  matType<T, P> result(uninitialize);
  for(detail::component_count_t i = 0; i < detail::component_count(result); ++i)
   result[i] = x[i] * y[i];
  return result;
 }

 template<typename T, precision P, template <typename, precision> class vecTypeA, template <typename, precision> class vecTypeB>
 inline typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type outerProduct(vecTypeA<T, P> const & c, vecTypeB<T, P> const & r)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'outerProduct' only accept floating-point inputs");

  typename detail::outerProduct_trait<T, P, vecTypeA, vecTypeB>::type m(uninitialize);
  for(detail::component_count_t i = 0; i < detail::component_count(m); ++i)
   m[i] = c * r[i];
  return m;
 }

 template <typename T, precision P, template <typename, precision> class matType>
 inline typename matType<T, P>::transpose_type transpose(matType<T, P> const & m)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'transpose' only accept floating-point inputs");
  return detail::compute_transpose<matType, T, P>::call(m);
 }

 template <typename T, precision P, template <typename, precision> class matType>
 inline T determinant(matType<T, P> const & m)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'determinant' only accept floating-point inputs");
  return detail::compute_determinant<matType, T, P>::call(m);
 }

 template <typename T, precision P, template <typename, precision> class matType>
 inline matType<T, P> inverse(matType<T, P> const & m)
 {
  static_assert(std::numeric_limits<T>::is_iec559, "'inverse' only accept floating-point inputs");
  return detail::compute_inverse(m);
 }

}
# 179 "../glm/gtx/../detail/func_matrix.hpp" 2
# 36 "../glm/gtx/../matrix.hpp" 2
# 116 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../vector_relational.hpp" 1
# 33 "../glm/gtx/../vector_relational.hpp"
       
# 117 "../glm/gtx/../glm.hpp" 2
# 1 "../glm/gtx/../integer.hpp" 1
# 33 "../glm/gtx/../integer.hpp"
       

# 1 "../glm/gtx/../detail/func_integer.hpp" 1
# 42 "../glm/gtx/../detail/func_integer.hpp"
       






namespace glm
{
# 62 "../glm/gtx/../detail/func_integer.hpp"
 template <precision P, template <typename, precision> class vecType>
 vecType<uint, P> uaddCarry(
  vecType<uint, P> const & x,
  vecType<uint, P> const & y,
  vecType<uint, P> & carry);
# 76 "../glm/gtx/../detail/func_integer.hpp"
 template <precision P, template <typename, precision> class vecType>
 vecType<uint, P> usubBorrow(
  vecType<uint, P> const & x,
  vecType<uint, P> const & y,
  vecType<uint, P> & borrow);
# 90 "../glm/gtx/../detail/func_integer.hpp"
 template <precision P, template <typename, precision> class vecType>
 void umulExtended(
  vecType<uint, P> const & x,
  vecType<uint, P> const & y,
  vecType<uint, P> & msb,
  vecType<uint, P> & lsb);
# 105 "../glm/gtx/../detail/func_integer.hpp"
 template <precision P, template <typename, precision> class vecType>
 void imulExtended(
  vecType<int, P> const & x,
  vecType<int, P> const & y,
  vecType<int, P> & msb,
  vecType<int, P> & lsb);
# 127 "../glm/gtx/../detail/func_integer.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> bitfieldExtract(
  vecType<T, P> const & Value,
  int Offset,
  int Bits);
# 147 "../glm/gtx/../detail/func_integer.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> bitfieldInsert(
  vecType<T, P> const & Base,
  vecType<T, P> const & Insert,
  int Offset,
  int Bits);
# 162 "../glm/gtx/../detail/func_integer.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<T, P> bitfieldReverse(vecType<T, P> const & v);







 template <typename genType>
 int bitCount(genType v);







 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<int, P> bitCount(vecType<T, P> const & v);
# 191 "../glm/gtx/../detail/func_integer.hpp"
 template <typename genIUType>
 int findLSB(genIUType x);
# 202 "../glm/gtx/../detail/func_integer.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<int, P> findLSB(vecType<T, P> const & v);
# 214 "../glm/gtx/../detail/func_integer.hpp"
 template <typename genIUType>
 int findMSB(genIUType x);
# 226 "../glm/gtx/../detail/func_integer.hpp"
 template <typename T, precision P, template <typename, precision> class vecType>
 vecType<int, P> findMSB(vecType<T, P> const & v);


}

# 1 "../glm/gtx/../detail/func_integer.inl" 1
# 46 "../glm/gtx/../detail/func_integer.inl"
namespace glm{
namespace detail
{
 template <typename T>
 inline T mask(T Bits)
 {
  return Bits >= sizeof(T) * 8 ? ~static_cast<T>(0) : (static_cast<T>(1) << Bits) - static_cast<T>(1);
 }

 template <bool EXEC = false>
 struct compute_bitfieldReverseStep
 {
  template <typename T, glm::precision P, template <class, glm::precision> class vecType>
  inline static vecType<T, P> call(vecType<T, P> const & v, T, T)
  {
   return v;
  }
 };

 template <>
 struct compute_bitfieldReverseStep<true>
 {
  template <typename T, glm::precision P, template <class, glm::precision> class vecType>
  inline static vecType<T, P> call(vecType<T, P> const & v, T Mask, T Shift)
  {
   return (v & Mask) << Shift | (v & (~Mask)) >> Shift;
  }
 };

 template <bool EXEC = false>
 struct compute_bitfieldBitCountStep
 {
  template <typename T, glm::precision P, template <class, glm::precision> class vecType>
  inline static vecType<T, P> call(vecType<T, P> const & v, T, T)
  {
   return v;
  }
 };

 template <>
 struct compute_bitfieldBitCountStep<true>
 {
  template <typename T, glm::precision P, template <class, glm::precision> class vecType>
  inline static vecType<T, P> call(vecType<T, P> const & v, T Mask, T Shift)
  {
   return (v & Mask) + ((v >> Shift) & Mask);
  }
 };

 template <typename genIUType, size_t Bits>
 struct compute_findLSB
 {
  inline static int call(genIUType Value)
  {
   if(Value == 0)
    return -1;

   return glm::bitCount(~Value & (Value - static_cast<genIUType>(1)));
  }
 };
# 133 "../glm/gtx/../detail/func_integer.inl"
 template <typename T, glm::precision P, template <class, glm::precision> class vecType, bool EXEC = true>
 struct compute_findMSB_step_vec
 {
  inline static vecType<T, P> call(vecType<T, P> const & x, T Shift)
  {
   return x | (x >> Shift);
  }
 };

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType>
 struct compute_findMSB_step_vec<T, P, vecType, false>
 {
  inline static vecType<T, P> call(vecType<T, P> const & x, T)
  {
   return x;
  }
 };

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType, int>
 struct compute_findMSB_vec
 {
  inline static vecType<int, P> call(vecType<T, P> const & vec)
  {
   vecType<T, P> x(vec);
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 1));
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 2));
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 8>::call(x, static_cast<T>( 4));
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 16>::call(x, static_cast<T>( 8));
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 32>::call(x, static_cast<T>(16));
   x = compute_findMSB_step_vec<T, P, vecType, sizeof(T) * 8 >= 64>::call(x, static_cast<T>(32));
   return vecType<int, P>(sizeof(T) * 8 - 1) - glm::bitCount(~x);
  }
 };
# 204 "../glm/gtx/../detail/func_integer.inl"
}


 inline uint uaddCarry(uint const & x, uint const & y, uint & Carry)
 {
  uint64 const Value64(static_cast<uint64>(x) + static_cast<uint64>(y));
  uint64 const Max32((static_cast<uint64>(1) << static_cast<uint64>(32)) - static_cast<uint64>(1));
  Carry = Value64 > Max32 ? 1 : 0;
  return static_cast<uint32>(Value64 % (Max32 + static_cast<uint64>(1)));
 }

 template <precision P, template <typename, precision> class vecType>
 inline vecType<uint, P> uaddCarry(vecType<uint, P> const & x, vecType<uint, P> const & y, vecType<uint, P> & Carry)
 {
  vecType<uint64, P> Value64(vecType<uint64, P>(x) + vecType<uint64, P>(y));
  vecType<uint64, P> Max32((static_cast<uint64>(1) << static_cast<uint64>(32)) - static_cast<uint64>(1));
  Carry = mix(vecType<uint32, P>(0), vecType<uint32, P>(1), greaterThan(Value64, Max32));
  return vecType<uint32,P>(Value64 % (Max32 + static_cast<uint64>(1)));
 }


 inline uint usubBorrow(uint const & x, uint const & y, uint & Borrow)
 {
  static_assert(sizeof(uint) == sizeof(uint32), "uint and uint32 size mismatch");

  Borrow = x >= y ? static_cast<uint32>(0) : static_cast<uint32>(1);
  if(y >= x)
   return y - x;
  else
   return static_cast<uint32>((static_cast<int64>(1) << static_cast<int64>(32)) + (static_cast<int64>(y) - static_cast<int64>(x)));
 }

 template <precision P, template <typename, precision> class vecType>
 inline vecType<uint, P> usubBorrow(vecType<uint, P> const & x, vecType<uint, P> const & y, vecType<uint, P> & Borrow)
 {
  Borrow = mix(vecType<uint, P>(1), vecType<uint, P>(0), greaterThanEqual(x, y));
  vecType<uint, P> const YgeX(y - x);
  vecType<uint, P> const XgeY(vecType<uint32, P>((static_cast<int64>(1) << static_cast<int64>(32)) + (vecType<int64, P>(y) - vecType<int64, P>(x))));
  return mix(XgeY, YgeX, greaterThanEqual(y, x));
 }


 inline void umulExtended(uint const & x, uint const & y, uint & msb, uint & lsb)
 {
  static_assert(sizeof(uint) == sizeof(uint32), "uint and uint32 size mismatch");

  uint64 Value64 = static_cast<uint64>(x) * static_cast<uint64>(y);
  uint32* PointerMSB = (reinterpret_cast<uint32*>(&Value64) + 1);
  msb = *PointerMSB;
  uint32* PointerLSB = (reinterpret_cast<uint32*>(&Value64) + 0);
  lsb = *PointerLSB;
 }

 template <precision P, template <typename, precision> class vecType>
 inline void umulExtended(vecType<uint, P> const & x, vecType<uint, P> const & y, vecType<uint, P> & msb, vecType<uint, P> & lsb)
 {
  static_assert(sizeof(uint) == sizeof(uint32), "uint and uint32 size mismatch");

  vecType<uint64, P> Value64(vecType<uint64, P>(x) * vecType<uint64, P>(y));
  msb = vecType<uint32, P>(Value64 >> static_cast<uint64>(32));
  lsb = vecType<uint32, P>(Value64);
 }


 inline void imulExtended(int x, int y, int & msb, int & lsb)
 {
  static_assert(sizeof(int) == sizeof(int32), "int and int32 size mismatch");

  int64 Value64 = static_cast<int64>(x) * static_cast<int64>(y);
  int32* PointerMSB = (reinterpret_cast<int32*>(&Value64) + 1);
  msb = *PointerMSB;
  int32* PointerLSB = (reinterpret_cast<int32*>(&Value64));
  lsb = *PointerLSB;
 }

 template <precision P, template <typename, precision> class vecType>
 inline void imulExtended(vecType<int, P> const & x, vecType<int, P> const & y, vecType<int, P> & msb, vecType<int, P> & lsb)
 {
  static_assert(sizeof(int) == sizeof(int32), "int and int32 size mismatch");

  vecType<int64, P> Value64(vecType<int64, P>(x) * vecType<int64, P>(y));
  lsb = vecType<int32, P>(Value64 & static_cast<int64>(0xFFFFFFFF));
  msb = vecType<int32, P>((Value64 >> static_cast<int64>(32)) & static_cast<int64>(0xFFFFFFFF));
 }


 template <typename genIUType>
 inline genIUType bitfieldExtract(genIUType Value, int Offset, int Bits)
 {
  return bitfieldExtract(tvec1<genIUType>(Value), Offset, Bits).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> bitfieldExtract(vecType<T, P> const & Value, int Offset, int Bits)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitfieldExtract' only accept integer inputs");

  return (Value >> static_cast<T>(Offset)) & static_cast<T>(detail::mask(Bits));
 }


 template <typename genIUType>
 inline genIUType bitfieldInsert(genIUType const & Base, genIUType const & Insert, int Offset, int Bits)
 {
  return bitfieldInsert(tvec1<genIUType>(Base), tvec1<genIUType>(Insert), Offset, Bits).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<T, P> bitfieldInsert(vecType<T, P> const & Base, vecType<T, P> const & Insert, int Offset, int Bits)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'bitfieldInsert' only accept integer values");

  T const Mask = static_cast<T>(detail::mask(Bits) << Offset);
  return (Base & ~Mask) | (Insert & Mask);
 }


 template <typename genType>
 inline genType bitfieldReverse(genType x)
 {
  return bitfieldReverse(glm::tvec1<genType, glm::defaultp>(x)).x;
 }

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType>
 inline vecType<T, P> bitfieldReverse(vecType<T, P> const & v)
 {
  vecType<T, P> x(v);
  x = detail::compute_bitfieldReverseStep<sizeof(T) * 8 >= 2>::call(x, T(0x5555555555555555ull), static_cast<T>( 1));
  x = detail::compute_bitfieldReverseStep<sizeof(T) * 8 >= 4>::call(x, T(0x3333333333333333ull), static_cast<T>( 2));
  x = detail::compute_bitfieldReverseStep<sizeof(T) * 8 >= 8>::call(x, T(0x0F0F0F0F0F0F0F0Full), static_cast<T>( 4));
  x = detail::compute_bitfieldReverseStep<sizeof(T) * 8 >= 16>::call(x, T(0x00FF00FF00FF00FFull), static_cast<T>( 8));
  x = detail::compute_bitfieldReverseStep<sizeof(T) * 8 >= 32>::call(x, T(0x0000FFFF0000FFFFull), static_cast<T>(16));
  x = detail::compute_bitfieldReverseStep<sizeof(T) * 8 >= 64>::call(x, T(0x00000000FFFFFFFFull), static_cast<T>(32));
  return x;
 }


 template <typename genType>
 inline int bitCount(genType x)
 {
  return bitCount(glm::tvec1<genType, glm::defaultp>(x)).x;
 }

 template <typename T, glm::precision P, template <typename, glm::precision> class vecType>
 inline vecType<int, P> bitCount(vecType<T, P> const & v)
 {
  vecType<typename detail::make_unsigned<T>::type, P> x(*reinterpret_cast<vecType<typename detail::make_unsigned<T>::type, P> const *>(&v));
  x = detail::compute_bitfieldBitCountStep<sizeof(T) * 8 >= 2>::call(x, typename detail::make_unsigned<T>::type(0x5555555555555555ull), typename detail::make_unsigned<T>::type( 1));
  x = detail::compute_bitfieldBitCountStep<sizeof(T) * 8 >= 4>::call(x, typename detail::make_unsigned<T>::type(0x3333333333333333ull), typename detail::make_unsigned<T>::type( 2));
  x = detail::compute_bitfieldBitCountStep<sizeof(T) * 8 >= 8>::call(x, typename detail::make_unsigned<T>::type(0x0F0F0F0F0F0F0F0Full), typename detail::make_unsigned<T>::type( 4));
  x = detail::compute_bitfieldBitCountStep<sizeof(T) * 8 >= 16>::call(x, typename detail::make_unsigned<T>::type(0x00FF00FF00FF00FFull), typename detail::make_unsigned<T>::type( 8));
  x = detail::compute_bitfieldBitCountStep<sizeof(T) * 8 >= 32>::call(x, typename detail::make_unsigned<T>::type(0x0000FFFF0000FFFFull), typename detail::make_unsigned<T>::type(16));
  x = detail::compute_bitfieldBitCountStep<sizeof(T) * 8 >= 64>::call(x, typename detail::make_unsigned<T>::type(0x00000000FFFFFFFFull), typename detail::make_unsigned<T>::type(32));
  return vecType<int, P>(x);
 }


 template <typename genIUType>
 inline int findLSB(genIUType Value)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'findLSB' only accept integer values");

  return detail::compute_findLSB<genIUType, sizeof(genIUType) * 8>::call(Value);
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<int, P> findLSB(vecType<T, P> const & x)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'findLSB' only accept integer values");

  return detail::functor1<int, T, P, vecType>::call(findLSB, x);
 }


 template <typename genIUType>
 inline int findMSB(genIUType x)
 {
  static_assert(std::numeric_limits<genIUType>::is_integer, "'findMSB' only accept integer values");

  return findMSB(tvec1<genIUType>(x)).x;
 }

 template <typename T, precision P, template <typename, precision> class vecType>
 inline vecType<int, P> findMSB(vecType<T, P> const & x)
 {
  static_assert(std::numeric_limits<T>::is_integer, "'findMSB' only accept integer values");

  return detail::compute_findMSB_vec<T, P, vecType, sizeof(T) * 8>::call(x);
 }
}
# 233 "../glm/gtx/../detail/func_integer.hpp" 2
# 36 "../glm/gtx/../integer.hpp" 2
# 118 "../glm/gtx/../glm.hpp" 2
# 49 "../glm/gtx/transform.hpp" 2
# 1 "../glm/gtx/../gtc/matrix_transform.hpp" 1
# 50 "../glm/gtx/../gtc/matrix_transform.hpp"
       






# 1 "../glm/gtx/../gtc/../gtc/constants.hpp" 1
# 43 "../glm/gtx/../gtc/../gtc/constants.hpp"
       
# 52 "../glm/gtx/../gtc/../gtc/constants.hpp"
namespace glm
{





 template <typename genType>
 genType epsilon();



 template <typename genType>
 genType zero();



 template <typename genType>
 genType one();



 template <typename genType>
 genType pi();



 template <typename genType>
 genType two_pi();



 template <typename genType>
 genType root_pi();



 template <typename genType>
 genType half_pi();



 template <typename genType>
 genType three_over_two_pi();



 template <typename genType>
 genType quarter_pi();



 template <typename genType>
 genType one_over_pi();



 template <typename genType>
 genType one_over_two_pi();



 template <typename genType>
 genType two_over_pi();



 template <typename genType>
 genType four_over_pi();



 template <typename genType>
 genType two_over_root_pi();



 template <typename genType>
 genType one_over_root_two();



 template <typename genType>
 genType root_half_pi();



 template <typename genType>
 genType root_two_pi();



 template <typename genType>
 genType root_ln_four();



 template <typename genType>
 genType e();



 template <typename genType>
 genType euler();



 template <typename genType>
 genType root_two();



 template <typename genType>
 genType root_three();



 template <typename genType>
 genType root_five();



 template <typename genType>
 genType ln_two();



 template <typename genType>
 genType ln_ten();



 template <typename genType>
 genType ln_ln_two();



 template <typename genType>
 genType third();



 template <typename genType>
 genType two_thirds();



 template <typename genType>
 genType golden_ratio();


}

# 1 "../glm/gtx/../gtc/../gtc/constants.inl" 1
# 35 "../glm/gtx/../gtc/../gtc/constants.inl"
namespace glm
{
 template <typename genType>
 inline genType epsilon()
 {
  return std::numeric_limits<genType>::epsilon();
 }

 template <typename genType>
 inline genType zero()
 {
  return genType(0);
 }

 template <typename genType>
 inline genType one()
 {
  return genType(1);
 }

 template <typename genType>
 inline genType pi()
 {
  return genType(3.14159265358979323846264338327950288);
 }

 template <typename genType>
 inline genType two_pi()
 {
  return genType(6.28318530717958647692528676655900576);
 }

 template <typename genType>
 inline genType root_pi()
 {
  return genType(1.772453850905516027);
 }

 template <typename genType>
 inline genType half_pi()
 {
  return genType(1.57079632679489661923132169163975144);
 }

 template <typename genType>
 inline genType three_over_two_pi()
 {
  return genType(4.71238898038468985769396507491925432);
 }

 template <typename genType>
 inline genType quarter_pi()
 {
  return genType(0.785398163397448309615660845819875721);
 }

 template <typename genType>
 inline genType one_over_pi()
 {
  return genType(0.318309886183790671537767526745028724);
 }

 template <typename genType>
 inline genType one_over_two_pi()
 {
  return genType(0.159154943091895335768883763372514362);
 }

 template <typename genType>
 inline genType two_over_pi()
 {
  return genType(0.636619772367581343075535053490057448);
 }

 template <typename genType>
 inline genType four_over_pi()
 {
  return genType(1.273239544735162686151070106980114898);
 }

 template <typename genType>
 inline genType two_over_root_pi()
 {
  return genType(1.12837916709551257389615890312154517);
 }

 template <typename genType>
 inline genType one_over_root_two()
 {
  return genType(0.707106781186547524400844362104849039);
 }

 template <typename genType>
 inline genType root_half_pi()
 {
  return genType(1.253314137315500251);
 }

 template <typename genType>
 inline genType root_two_pi()
 {
  return genType(2.506628274631000502);
 }

 template <typename genType>
 inline genType root_ln_four()
 {
  return genType(1.17741002251547469);
 }

 template <typename genType>
 inline genType e()
 {
  return genType(2.71828182845904523536);
 }

 template <typename genType>
 inline genType euler()
 {
  return genType(0.577215664901532860606);
 }

 template <typename genType>
 inline genType root_two()
 {
  return genType(1.41421356237309504880168872420969808);
 }

 template <typename genType>
 inline genType root_three()
 {
  return genType(1.73205080756887729352744634150587236);
 }

 template <typename genType>
 inline genType root_five()
 {
  return genType(2.23606797749978969640917366873127623);
 }

 template <typename genType>
 inline genType ln_two()
 {
  return genType(0.693147180559945309417232121458176568);
 }

 template <typename genType>
 inline genType ln_ten()
 {
  return genType(2.30258509299404568401799145468436421);
 }

 template <typename genType>
 inline genType ln_ln_two()
 {
  return genType(-0.3665129205816643);
 }

 template <typename genType>
 inline genType third()
 {
  return genType(0.3333333333333333333333333333333333333333);
 }

 template <typename genType>
 inline genType two_thirds()
 {
  return genType(0.666666666666666666666666666666666666667);
 }

 template <typename genType>
 inline genType golden_ratio()
 {
  return genType(1.61803398874989484820458683436563811);
 }
}
# 206 "../glm/gtx/../gtc/../gtc/constants.hpp" 2
# 58 "../glm/gtx/../gtc/matrix_transform.hpp" 2





namespace glm
{
# 86 "../glm/gtx/../gtc/matrix_transform.hpp"
 template <typename T, precision P>
 tmat4x4<T, P> translate(
  tmat4x4<T, P> const & m,
  tvec3<T, P> const & v);
# 100 "../glm/gtx/../gtc/matrix_transform.hpp"
 template <typename T, precision P>
 tmat4x4<T, P> rotate(
  tmat4x4<T, P> const & m,
  T angle,
  tvec3<T, P> const & axis);
# 114 "../glm/gtx/../gtc/matrix_transform.hpp"
 template <typename T, precision P>
 tmat4x4<T, P> scale(
  tmat4x4<T, P> const & m,
  tvec3<T, P> const & v);
# 130 "../glm/gtx/../gtc/matrix_transform.hpp"
 template <typename T>
 tmat4x4<T, defaultp> ortho(
  T left,
  T right,
  T bottom,
  T top,
  T zNear,
  T zFar);
# 148 "../glm/gtx/../gtc/matrix_transform.hpp"
 template <typename T>
 tmat4x4<T, defaultp> ortho(
  T left,
  T right,
  T bottom,
  T top);
# 165 "../glm/gtx/../gtc/matrix_transform.hpp"
 template <typename T>
 tmat4x4<T, defaultp> frustum(
  T left,
  T right,
  T bottom,
  T top,
  T near,
  T far);
# 182 "../glm/gtx/../gtc/matrix_transform.hpp"
 template <typename T>
 tmat4x4<T, defaultp> perspective(
  T fovy,
  T aspect,
  T near,
  T far);
# 198 "../glm/gtx/../gtc/matrix_transform.hpp"
 template <typename T>
 tmat4x4<T, defaultp> perspectiveFov(
  T fov,
  T width,
  T height,
  T near,
  T far);
# 213 "../glm/gtx/../gtc/matrix_transform.hpp"
 template <typename T>
 tmat4x4<T, defaultp> infinitePerspective(
  T fovy, T aspect, T near);
# 224 "../glm/gtx/../gtc/matrix_transform.hpp"
 template <typename T>
 tmat4x4<T, defaultp> tweakedInfinitePerspective(
  T fovy, T aspect, T near);
# 236 "../glm/gtx/../gtc/matrix_transform.hpp"
 template <typename T>
 tmat4x4<T, defaultp> tweakedInfinitePerspective(
  T fovy, T aspect, T near, T ep);
# 250 "../glm/gtx/../gtc/matrix_transform.hpp"
 template <typename T, typename U, precision P>
 tvec3<T, P> project(
  tvec3<T, P> const & obj,
  tmat4x4<T, P> const & model,
  tmat4x4<T, P> const & proj,
  tvec4<U, P> const & viewport);
# 267 "../glm/gtx/../gtc/matrix_transform.hpp"
 template <typename T, typename U, precision P>
 tvec3<T, P> unProject(
  tvec3<T, P> const & win,
  tmat4x4<T, P> const & model,
  tmat4x4<T, P> const & proj,
  tvec4<U, P> const & viewport);
# 282 "../glm/gtx/../gtc/matrix_transform.hpp"
 template <typename T, precision P, typename U>
 tmat4x4<T, P> pickMatrix(
  tvec2<T, P> const & center,
  tvec2<T, P> const & delta,
  tvec4<U, P> const & viewport);
# 295 "../glm/gtx/../gtc/matrix_transform.hpp"
 template <typename T, precision P>
 tmat4x4<T, P> lookAt(
  tvec3<T, P> const & eye,
  tvec3<T, P> const & center,
  tvec3<T, P> const & up);


}

# 1 "../glm/gtx/../gtc/matrix_transform.inl" 1
# 37 "../glm/gtx/../gtc/matrix_transform.inl"
namespace glm
{
 template <typename T, precision P>
 inline tmat4x4<T, P> translate
 (
  tmat4x4<T, P> const & m,
  tvec3<T, P> const & v
 )
 {
  tmat4x4<T, P> Result(m);
  Result[3] = m[0] * v[0] + m[1] * v[1] + m[2] * v[2] + m[3];
  return Result;
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> rotate
 (
  tmat4x4<T, P> const & m,
  T angle,
  tvec3<T, P> const & v
 )
 {
  T const a = angle;
  T const c = cos(a);
  T const s = sin(a);

  tvec3<T, P> axis(normalize(v));
  tvec3<T, P> temp((T(1) - c) * axis);

  tmat4x4<T, P> Rotate(uninitialize);
  Rotate[0][0] = c + temp[0] * axis[0];
  Rotate[0][1] = 0 + temp[0] * axis[1] + s * axis[2];
  Rotate[0][2] = 0 + temp[0] * axis[2] - s * axis[1];

  Rotate[1][0] = 0 + temp[1] * axis[0] - s * axis[2];
  Rotate[1][1] = c + temp[1] * axis[1];
  Rotate[1][2] = 0 + temp[1] * axis[2] + s * axis[0];

  Rotate[2][0] = 0 + temp[2] * axis[0] + s * axis[1];
  Rotate[2][1] = 0 + temp[2] * axis[1] - s * axis[0];
  Rotate[2][2] = c + temp[2] * axis[2];

  tmat4x4<T, P> Result(uninitialize);
  Result[0] = m[0] * Rotate[0][0] + m[1] * Rotate[0][1] + m[2] * Rotate[0][2];
  Result[1] = m[0] * Rotate[1][0] + m[1] * Rotate[1][1] + m[2] * Rotate[1][2];
  Result[2] = m[0] * Rotate[2][0] + m[1] * Rotate[2][1] + m[2] * Rotate[2][2];
  Result[3] = m[3];
  return Result;
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> rotate_slow
 (
  tmat4x4<T, P> const & m,
  T angle,
  tvec3<T, P> const & v
 )
 {
  T const a = angle;
  T const c = cos(a);
  T const s = sin(a);
  tmat4x4<T, P> Result;

  tvec3<T, P> axis = normalize(v);

  Result[0][0] = c + (1 - c) * axis.x * axis.x;
  Result[0][1] = (1 - c) * axis.x * axis.y + s * axis.z;
  Result[0][2] = (1 - c) * axis.x * axis.z - s * axis.y;
  Result[0][3] = 0;

  Result[1][0] = (1 - c) * axis.y * axis.x - s * axis.z;
  Result[1][1] = c + (1 - c) * axis.y * axis.y;
  Result[1][2] = (1 - c) * axis.y * axis.z + s * axis.x;
  Result[1][3] = 0;

  Result[2][0] = (1 - c) * axis.z * axis.x + s * axis.y;
  Result[2][1] = (1 - c) * axis.z * axis.y - s * axis.x;
  Result[2][2] = c + (1 - c) * axis.z * axis.z;
  Result[2][3] = 0;

  Result[3] = tvec4<T, P>(0, 0, 0, 1);
  return m * Result;
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> scale
 (
  tmat4x4<T, P> const & m,
  tvec3<T, P> const & v
 )
 {
  tmat4x4<T, P> Result(uninitialize);
  Result[0] = m[0] * v[0];
  Result[1] = m[1] * v[1];
  Result[2] = m[2] * v[2];
  Result[3] = m[3];
  return Result;
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> scale_slow
 (
  tmat4x4<T, P> const & m,
  tvec3<T, P> const & v
 )
 {
  tmat4x4<T, P> Result(T(1));
  Result[0][0] = v.x;
  Result[1][1] = v.y;
  Result[2][2] = v.z;
  return m * Result;
 }

 template <typename T>
 inline tmat4x4<T, defaultp> ortho
 (
  T left,
  T right,
  T bottom,
  T top,
  T zNear,
  T zFar
 )
 {
  tmat4x4<T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - static_cast<T>(2) / (zFar - zNear);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  Result[3][2] = - (zFar + zNear) / (zFar - zNear);
  return Result;
 }

 template <typename T>
 inline tmat4x4<T, defaultp> ortho
 (
  T left,
  T right,
  T bottom,
  T top
 )
 {
  tmat4x4<T, defaultp> Result(1);
  Result[0][0] = static_cast<T>(2) / (right - left);
  Result[1][1] = static_cast<T>(2) / (top - bottom);
  Result[2][2] = - static_cast<T>(1);
  Result[3][0] = - (right + left) / (right - left);
  Result[3][1] = - (top + bottom) / (top - bottom);
  return Result;
 }

 template <typename T>
 inline tmat4x4<T, defaultp> frustum
 (
  T left,
  T right,
  T bottom,
  T top,
  T nearVal,
  T farVal
 )
 {
  tmat4x4<T, defaultp> Result(0);
  Result[0][0] = (static_cast<T>(2) * nearVal) / (right - left);
  Result[1][1] = (static_cast<T>(2) * nearVal) / (top - bottom);
  Result[2][0] = (right + left) / (right - left);
  Result[2][1] = (top + bottom) / (top - bottom);
  Result[2][2] = -(farVal + nearVal) / (farVal - nearVal);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = -(static_cast<T>(2) * farVal * nearVal) / (farVal - nearVal);
  return Result;
 }

 template <typename T>
 inline tmat4x4<T, defaultp> perspective
 (
  T fovy,
  T aspect,
  T zNear,
  T zFar
 )
 {
  ((abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)) ? (void)0 : __assert2("../glm/gtx/../gtc/matrix_transform.inl", 220, __PRETTY_FUNCTION__, "abs(aspect - std::numeric_limits<T>::epsilon()) > static_cast<T>(0)"));
  ((zFar > zNear) ? (void)0 : __assert2("../glm/gtx/../gtc/matrix_transform.inl", 221, __PRETTY_FUNCTION__, "zFar > zNear"));

  T const tanHalfFovy = tan(fovy / static_cast<T>(2));

  tmat4x4<T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = static_cast<T>(1) / (aspect * tanHalfFovy);
  Result[1][1] = static_cast<T>(1) / (tanHalfFovy);
  Result[2][2] = - (zFar + zNear) / (zFar - zNear);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template <typename T>
 inline tmat4x4<T, defaultp> perspectiveFov
 (
  T fov,
  T width,
  T height,
  T zNear,
  T zFar
 )
 {
  ((width > static_cast<T>(0)) ? (void)0 : __assert2("../glm/gtx/../gtc/matrix_transform.inl", 244, __PRETTY_FUNCTION__, "width > static_cast<T>(0)"));
  ((height > static_cast<T>(0)) ? (void)0 : __assert2("../glm/gtx/../gtc/matrix_transform.inl", 245, __PRETTY_FUNCTION__, "height > static_cast<T>(0)"));
  ((fov > static_cast<T>(0)) ? (void)0 : __assert2("../glm/gtx/../gtc/matrix_transform.inl", 246, __PRETTY_FUNCTION__, "fov > static_cast<T>(0)"));

  T const rad = fov;
  T const h = glm::cos(static_cast<T>(0.5) * rad) / glm::sin(static_cast<T>(0.5) * rad);
  T const w = h * height / width;

  tmat4x4<T, defaultp> Result(static_cast<T>(0));
  Result[0][0] = w;
  Result[1][1] = h;
  Result[2][2] = - (zFar + zNear) / (zFar - zNear);
  Result[2][3] = - static_cast<T>(1);
  Result[3][2] = - (static_cast<T>(2) * zFar * zNear) / (zFar - zNear);
  return Result;
 }

 template <typename T>
 inline tmat4x4<T, defaultp> infinitePerspective
 (
  T fovy,
  T aspect,
  T zNear
 )
 {
  T const range = tan(fovy / T(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  tmat4x4<T, defaultp> Result(T(0));
  Result[0][0] = (T(2) * zNear) / (right - left);
  Result[1][1] = (T(2) * zNear) / (top - bottom);
  Result[2][2] = - T(1);
  Result[2][3] = - T(1);
  Result[3][2] = - T(2) * zNear;
  return Result;
 }


 template <typename T>
 inline tmat4x4<T, defaultp> tweakedInfinitePerspective
 (
  T fovy,
  T aspect,
  T zNear,
  T ep
 )
 {
  T const range = tan(fovy / T(2)) * zNear;
  T const left = -range * aspect;
  T const right = range * aspect;
  T const bottom = -range;
  T const top = range;

  tmat4x4<T, defaultp> Result(T(0));
  Result[0][0] = (static_cast<T>(2) * zNear) / (right - left);
  Result[1][1] = (static_cast<T>(2) * zNear) / (top - bottom);
  Result[2][2] = ep - static_cast<T>(1);
  Result[2][3] = static_cast<T>(-1);
  Result[3][2] = (ep - static_cast<T>(2)) * zNear;
  return Result;
 }

 template <typename T>
 inline tmat4x4<T, defaultp> tweakedInfinitePerspective
 (
  T fovy,
  T aspect,
  T zNear
 )
 {
  return tweakedInfinitePerspective(fovy, aspect, zNear, epsilon<T>());
 }

 template <typename T, typename U, precision P>
 inline tvec3<T, P> project
 (
  tvec3<T, P> const & obj,
  tmat4x4<T, P> const & model,
  tmat4x4<T, P> const & proj,
  tvec4<U, P> const & viewport
 )
 {
  tvec4<T, P> tmp = tvec4<T, P>(obj, T(1));
  tmp = model * tmp;
  tmp = proj * tmp;

  tmp /= tmp.w;
  tmp = tmp * T(0.5) + T(0.5);
  tmp[0] = tmp[0] * T(viewport[2]) + T(viewport[0]);
  tmp[1] = tmp[1] * T(viewport[3]) + T(viewport[1]);

  return tvec3<T, P>(tmp);
 }

 template <typename T, typename U, precision P>
 inline tvec3<T, P> unProject
 (
  tvec3<T, P> const & win,
  tmat4x4<T, P> const & model,
  tmat4x4<T, P> const & proj,
  tvec4<U, P> const & viewport
 )
 {
  tmat4x4<T, P> Inverse = inverse(proj * model);

  tvec4<T, P> tmp = tvec4<T, P>(win, T(1));
  tmp.x = (tmp.x - T(viewport[0])) / T(viewport[2]);
  tmp.y = (tmp.y - T(viewport[1])) / T(viewport[3]);
  tmp = tmp * T(2) - T(1);

  tvec4<T, P> obj = Inverse * tmp;
  obj /= obj.w;

  return tvec3<T, P>(obj);
 }

 template <typename T, precision P, typename U>
 inline tmat4x4<T, P> pickMatrix
 (
  tvec2<T, P> const & center,
  tvec2<T, P> const & delta,
  tvec4<U, P> const & viewport
 )
 {
  ((delta.x > T(0) && delta.y > T(0)) ? (void)0 : __assert2("../glm/gtx/../gtc/matrix_transform.inl", 371, __PRETTY_FUNCTION__, "delta.x > T(0) && delta.y > T(0)"));
  tmat4x4<T, P> Result(1.0f);

  if(!(delta.x > T(0) && delta.y > T(0)))
   return Result;

  tvec3<T, P> Temp(
   (T(viewport[2]) - T(2) * (center.x - T(viewport[0]))) / delta.x,
   (T(viewport[3]) - T(2) * (center.y - T(viewport[1]))) / delta.y,
   T(0));


  Result = translate(Result, Temp);
  return scale(Result, tvec3<T, P>(T(viewport[2]) / delta.x, T(viewport[3]) / delta.y, T(1)));
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> lookAt
 (
  tvec3<T, P> const & eye,
  tvec3<T, P> const & center,
  tvec3<T, P> const & up
 )
 {
  tvec3<T, P> const f(normalize(center - eye));
  tvec3<T, P> const s(normalize(cross(f, up)));
  tvec3<T, P> const u(cross(s, f));

  tmat4x4<T, P> Result(1);
  Result[0][0] = s.x;
  Result[1][0] = s.y;
  Result[2][0] = s.z;
  Result[0][1] = u.x;
  Result[1][1] = u.y;
  Result[2][1] = u.z;
  Result[0][2] =-f.x;
  Result[1][2] =-f.y;
  Result[2][2] =-f.z;
  Result[3][0] =-dot(s, eye);
  Result[3][1] =-dot(u, eye);
  Result[3][2] = dot(f, eye);
  return Result;
 }
}
# 305 "../glm/gtx/../gtc/matrix_transform.hpp" 2
# 50 "../glm/gtx/transform.hpp" 2





namespace glm
{






 template <typename T, precision P>
 tmat4x4<T, P> translate(
  tvec3<T, P> const & v);




 template <typename T, precision P>
 tmat4x4<T, P> rotate(
  T angle,
  tvec3<T, P> const & v);




 template <typename T, precision P>
 tmat4x4<T, P> scale(
  tvec3<T, P> const & v);


}

# 1 "../glm/gtx/transform.inl" 1
# 33 "../glm/gtx/transform.inl"
namespace glm
{
 template <typename T, precision P>
 inline tmat4x4<T, P> translate(
  tvec3<T, P> const & v)
 {
  return translate(
   tmat4x4<T, P>(1.0f), v);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> rotate(
  T angle,
  tvec3<T, P> const & v)
 {
  return rotate(
   tmat4x4<T, P>(1), angle, v);
 }

 template <typename T, precision P>
 inline tmat4x4<T, P> scale(
  tvec3<T, P> const & v)
 {
  return scale(
   tmat4x4<T, P>(1.0f), v);
 }

}
# 86 "../glm/gtx/transform.hpp" 2
# 16 "../Quadris/Font.cpp" 2

# 1 "../Quadris/Engine.h" 1
       




# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 1 3 4
# 7 "../Quadris/Engine.h" 2

# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/list" 1
# 58 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/list"
       
# 59 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/list" 3

# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 1 3
# 60 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/functexcept.h" 1 3
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/functexcept.h" 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/exception_defines.h" 1 3
# 41 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/functexcept.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{



  void
  __throw_bad_exception(void) __attribute__((__noreturn__));


  void
  __throw_bad_alloc(void) __attribute__((__noreturn__));


  void
  __throw_bad_cast(void) __attribute__((__noreturn__));

  void
  __throw_bad_typeid(void) __attribute__((__noreturn__));


  void
  __throw_logic_error(const char*) __attribute__((__noreturn__));

  void
  __throw_domain_error(const char*) __attribute__((__noreturn__));

  void
  __throw_invalid_argument(const char*) __attribute__((__noreturn__));

  void
  __throw_length_error(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range(const char*) __attribute__((__noreturn__));

  void
  __throw_out_of_range_fmt(const char*, ...) __attribute__((__noreturn__))
    __attribute__((__format__(__printf__, 1, 2)));

  void
  __throw_runtime_error(const char*) __attribute__((__noreturn__));

  void
  __throw_range_error(const char*) __attribute__((__noreturn__));

  void
  __throw_overflow_error(const char*) __attribute__((__noreturn__));

  void
  __throw_underflow_error(const char*) __attribute__((__noreturn__));


  void
  __throw_ios_failure(const char*) __attribute__((__noreturn__));

  void
  __throw_system_error(int) __attribute__((__noreturn__));

  void
  __throw_future_error(int) __attribute__((__noreturn__));


  void
  __throw_bad_function_call() __attribute__((__noreturn__));


}
# 61 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 2 3


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/numeric_traits.h" 1 3
# 32 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/numeric_traits.h" 3
       
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/numeric_traits.h" 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 54 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_integer
    {

      static const _Value __min = (((_Value)(-1) < 0) ? (_Value)1 << (sizeof(_Value) * 8 - ((_Value)(-1) < 0)) : (_Value)0);
      static const _Value __max = (((_Value)(-1) < 0) ? (((((_Value)1 << ((sizeof(_Value) * 8 - ((_Value)(-1) < 0)) - 1)) - 1) << 1) + 1) : ~(_Value)0);



      static const bool __is_signed = ((_Value)(-1) < 0);
      static const int __digits = (sizeof(_Value) * 8 - ((_Value)(-1) < 0));
    };

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__min;

  template<typename _Value>
    const _Value __numeric_traits_integer<_Value>::__max;

  template<typename _Value>
    const bool __numeric_traits_integer<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_integer<_Value>::__digits;
# 99 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/numeric_traits.h" 3
  template<typename _Value>
    struct __numeric_traits_floating
    {

      static const int __max_digits10 = (2 + (std::__are_same<_Value, float>::__value ? 24 : std::__are_same<_Value, double>::__value ? 53 : 53) * 643L / 2136);


      static const bool __is_signed = true;
      static const int __digits10 = (std::__are_same<_Value, float>::__value ? 6 : std::__are_same<_Value, double>::__value ? 15 : 15);
      static const int __max_exponent10 = (std::__are_same<_Value, float>::__value ? 38 : std::__are_same<_Value, double>::__value ? 308 : 308);
    };

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_digits10;

  template<typename _Value>
    const bool __numeric_traits_floating<_Value>::__is_signed;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__digits10;

  template<typename _Value>
    const int __numeric_traits_floating<_Value>::__max_exponent10;

  template<typename _Value>
    struct __numeric_traits
    : public __conditional_type<std::__is_integer<_Value>::__value,
    __numeric_traits_integer<_Value>,
    __numeric_traits_floating<_Value> >::__type
    { };


}
# 64 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_pair.h" 1 3
# 59 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_pair.h" 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/move.h" 1 3
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/move.h" 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/concept_check.h" 1 3
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/concept_check.h" 3
       
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/concept_check.h" 3
# 35 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/move.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _Tp>
    inline _Tp*
    __addressof(_Tp& __r) noexcept
    {
      return reinterpret_cast<_Tp*>
 (&const_cast<char&>(reinterpret_cast<const volatile char&>(__r)));
    }


}




namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/move.h" 3
  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type& __t) noexcept
    { return static_cast<_Tp&&>(__t); }







  template<typename _Tp>
    constexpr _Tp&&
    forward(typename std::remove_reference<_Tp>::type&& __t) noexcept
    {
      static_assert(!std::is_lvalue_reference<_Tp>::value, "template argument"
      " substituting _Tp is an lvalue reference type");
      return static_cast<_Tp&&>(__t);
    }






  template<typename _Tp>
    constexpr typename std::remove_reference<_Tp>::type&&
    move(_Tp&& __t) noexcept
    { return static_cast<typename std::remove_reference<_Tp>::type&&>(__t); }


  template<typename _Tp>
    struct __move_if_noexcept_cond
    : public __and_<__not_<is_nothrow_move_constructible<_Tp>>,
                    is_copy_constructible<_Tp>>::type { };
# 118 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/move.h" 3
  template<typename _Tp>
    constexpr typename
    conditional<__move_if_noexcept_cond<_Tp>::value, const _Tp&, _Tp&&>::type
    move_if_noexcept(_Tp& __x) noexcept
    { return std::move(__x); }
# 133 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/move.h" 3
  template<typename _Tp>
    inline _Tp*
    addressof(_Tp& __r) noexcept
    { return std::__addressof(__r); }



}
# 149 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/move.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 164 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/move.h" 3
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)

    noexcept(__and_<is_nothrow_move_constructible<_Tp>,
             is_nothrow_move_assignable<_Tp>>::value)

    {

     

      _Tp __tmp = std::move(__a);
      __a = std::move(__b);
      __b = std::move(__tmp);
    }




  template<typename _Tp, size_t _Nm>
    inline void
    swap(_Tp (&__a)[_Nm], _Tp (&__b)[_Nm])

    noexcept(noexcept(swap(*__a, *__b)))

    {
      for (size_t __n = 0; __n < _Nm; ++__n)
 swap(__a[__n], __b[__n]);
    }



}
# 60 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_pair.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 76 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_pair.h" 3
  struct piecewise_construct_t { };


  constexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();


  template<typename...>
    class tuple;

  template<std::size_t...>
    struct _Index_tuple;
# 95 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    struct pair
    {
      typedef _T1 first_type;
      typedef _T2 second_type;

      _T1 first;
      _T2 second;





      constexpr pair()
      : first(), second() { }


      constexpr pair(const _T1& __a, const _T2& __b)
      : first(__a), second(__b) { }







      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<const _U1&, _T1>,
    is_convertible<const _U2&, _T2>>::value>::type>
 constexpr pair(const pair<_U1, _U2>& __p)
 : first(__p.first), second(__p.second) { }

      constexpr pair(const pair&) = default;
      constexpr pair(pair&&) = default;


      template<class _U1, class = typename
        enable_if<is_convertible<_U1, _T1>::value>::type>
 constexpr pair(_U1&& __x, const _T2& __y)
 : first(std::forward<_U1>(__x)), second(__y) { }

      template<class _U2, class = typename
        enable_if<is_convertible<_U2, _T2>::value>::type>
 constexpr pair(const _T1& __x, _U2&& __y)
 : first(__x), second(std::forward<_U2>(__y)) { }

      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
 constexpr pair(_U1&& __x, _U2&& __y)
 : first(std::forward<_U1>(__x)), second(std::forward<_U2>(__y)) { }

      template<class _U1, class _U2, class = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
 constexpr pair(pair<_U1, _U2>&& __p)
 : first(std::forward<_U1>(__p.first)),
   second(std::forward<_U2>(__p.second)) { }

      template<typename... _Args1, typename... _Args2>
        pair(piecewise_construct_t, tuple<_Args1...>, tuple<_Args2...>);

      pair&
      operator=(const pair& __p)
      {
 first = __p.first;
 second = __p.second;
 return *this;
      }

      pair&
      operator=(pair&& __p)
      noexcept(__and_<is_nothrow_move_assignable<_T1>,
               is_nothrow_move_assignable<_T2>>::value)
      {
 first = std::forward<first_type>(__p.first);
 second = std::forward<second_type>(__p.second);
 return *this;
      }

      template<class _U1, class _U2>
 pair&
 operator=(const pair<_U1, _U2>& __p)
 {
   first = __p.first;
   second = __p.second;
   return *this;
 }

      template<class _U1, class _U2>
 pair&
 operator=(pair<_U1, _U2>&& __p)
 {
   first = std::forward<_U1>(__p.first);
   second = std::forward<_U2>(__p.second);
   return *this;
 }

      void
      swap(pair& __p)
      noexcept(noexcept(swap(first, __p.first))
        && noexcept(swap(second, __p.second)))
      {
 using std::swap;
 swap(first, __p.first);
 swap(second, __p.second);
      }

    private:
      template<typename... _Args1, std::size_t... _Indexes1,
               typename... _Args2, std::size_t... _Indexes2>
        pair(tuple<_Args1...>&, tuple<_Args2...>&,
             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);

    };


  template<class _T1, class _T2>
    inline constexpr bool
    operator==(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first == __y.first && __x.second == __y.second; }


  template<class _T1, class _T2>
    inline constexpr bool
    operator<(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __x.first < __y.first
      || (!(__y.first < __x.first) && __x.second < __y.second); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator!=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x == __y); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator>(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return __y < __x; }


  template<class _T1, class _T2>
    inline constexpr bool
    operator<=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__y < __x); }


  template<class _T1, class _T2>
    inline constexpr bool
    operator>=(const pair<_T1, _T2>& __x, const pair<_T1, _T2>& __y)
    { return !(__x < __y); }





  template<class _T1, class _T2>
    inline void
    swap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }
# 273 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_pair.h" 3
  template<class _T1, class _T2>
    constexpr pair<typename __decay_and_strip<_T1>::__type,
                   typename __decay_and_strip<_T2>::__type>
    make_pair(_T1&& __x, _T2&& __y)
    {
      typedef typename __decay_and_strip<_T1>::__type __ds_type1;
      typedef typename __decay_and_strip<_T2>::__type __ds_type2;
      typedef pair<__ds_type1, __ds_type2> __pair_type;
      return __pair_type(std::forward<_T1>(__x), std::forward<_T2>(__y));
    }
# 292 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_pair.h" 3

}
# 65 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator_base_types.h" 1 3
# 62 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator_base_types.h" 3
       
# 63 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator_base_types.h" 3







namespace std __attribute__ ((__visibility__ ("default")))
{

# 89 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator_base_types.h" 3
  struct input_iterator_tag { };


  struct output_iterator_tag { };


  struct forward_iterator_tag : public input_iterator_tag { };



  struct bidirectional_iterator_tag : public forward_iterator_tag { };



  struct random_access_iterator_tag : public bidirectional_iterator_tag { };
# 116 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator_base_types.h" 3
  template<typename _Category, typename _Tp, typename _Distance = ptrdiff_t,
           typename _Pointer = _Tp*, typename _Reference = _Tp&>
    struct iterator
    {

      typedef _Category iterator_category;

      typedef _Tp value_type;

      typedef _Distance difference_type;

      typedef _Pointer pointer;

      typedef _Reference reference;
    };
# 142 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator_base_types.h" 3
template<typename _Tp> class __has_iterator_category_helper { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static true_type __test(_Wrap_type<typename _Up::iterator_category>*); template<typename _Up> static false_type __test(...); public: typedef decltype(__test<_Tp>(0)) type; }; template<typename _Tp> struct __has_iterator_category : public __has_iterator_category_helper <typename remove_cv<_Tp>::type>::type { };

  template<typename _Iterator,
    bool = __has_iterator_category<_Iterator>::value>
    struct __iterator_traits { };

  template<typename _Iterator>
    struct __iterator_traits<_Iterator, true>
    {
      typedef typename _Iterator::iterator_category iterator_category;
      typedef typename _Iterator::value_type value_type;
      typedef typename _Iterator::difference_type difference_type;
      typedef typename _Iterator::pointer pointer;
      typedef typename _Iterator::reference reference;
    };

  template<typename _Iterator>
    struct iterator_traits
    : public __iterator_traits<_Iterator> { };
# 174 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator_base_types.h" 3
  template<typename _Tp>
    struct iterator_traits<_Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;
    };


  template<typename _Tp>
    struct iterator_traits<const _Tp*>
    {
      typedef random_access_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef ptrdiff_t difference_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;
    };





  template<typename _Iter>
    inline typename iterator_traits<_Iter>::iterator_category
    __iterator_category(const _Iter&)
    { return typename iterator_traits<_Iter>::iterator_category(); }





  template<typename _Iterator, bool _HasBase>
    struct _Iter_base
    {
      typedef _Iterator iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it; }
    };

  template<typename _Iterator>
    struct _Iter_base<_Iterator, true>
    {
      typedef typename _Iterator::iterator_type iterator_type;
      static iterator_type _S_base(_Iterator __it)
      { return __it.base(); }
    };


  template<typename _InIter>
    using _RequireInputIter = typename
      enable_if<is_convertible<typename
  iterator_traits<_InIter>::iterator_category,
          input_iterator_tag>::value>::type;



}
# 66 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator_base_funcs.h" 1 3
# 62 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator_base_funcs.h" 3
       
# 63 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator_base_funcs.h" 3


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/debug/debug.h" 1 3
# 46 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/debug/debug.h" 3
namespace std
{
  namespace __debug { }
}




namespace __gnu_debug
{
  using namespace std::__debug;
}
# 66 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator_base_funcs.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    __distance(_InputIterator __first, _InputIterator __last,
               input_iterator_tag)
    {

     

      typename iterator_traits<_InputIterator>::difference_type __n = 0;
      while (__first != __last)
 {
   ++__first;
   ++__n;
 }
      return __n;
    }

  template<typename _RandomAccessIterator>
    inline typename iterator_traits<_RandomAccessIterator>::difference_type
    __distance(_RandomAccessIterator __first, _RandomAccessIterator __last,
               random_access_iterator_tag)
    {

     

      return __last - __first;
    }
# 112 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator>
    inline typename iterator_traits<_InputIterator>::difference_type
    distance(_InputIterator __first, _InputIterator __last)
    {

      return std::__distance(__first, __last,
        std::__iterator_category(__first));
    }

  template<typename _InputIterator, typename _Distance>
    inline void
    __advance(_InputIterator& __i, _Distance __n, input_iterator_tag)
    {

     
      ;
      while (__n--)
 ++__i;
    }

  template<typename _BidirectionalIterator, typename _Distance>
    inline void
    __advance(_BidirectionalIterator& __i, _Distance __n,
       bidirectional_iterator_tag)
    {

     

      if (__n > 0)
        while (__n--)
   ++__i;
      else
        while (__n++)
   --__i;
    }

  template<typename _RandomAccessIterator, typename _Distance>
    inline void
    __advance(_RandomAccessIterator& __i, _Distance __n,
              random_access_iterator_tag)
    {

     

      __i += __n;
    }
# 171 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator_base_funcs.h" 3
  template<typename _InputIterator, typename _Distance>
    inline void
    advance(_InputIterator& __i, _Distance __n)
    {

      typename iterator_traits<_InputIterator>::difference_type __d = __n;
      std::__advance(__i, __d, std::__iterator_category(__i));
    }



  template<typename _ForwardIterator>
    inline _ForwardIterator
    next(_ForwardIterator __x, typename
  iterator_traits<_ForwardIterator>::difference_type __n = 1)
    {
      std::advance(__x, __n);
      return __x;
    }

  template<typename _BidirectionalIterator>
    inline _BidirectionalIterator
    prev(_BidirectionalIterator __x, typename
  iterator_traits<_BidirectionalIterator>::difference_type __n = 1)
    {
      std::advance(__x, -__n);
      return __x;
    }




}
# 67 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 1 3
# 66 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/ptr_traits.h" 1 3
# 37 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/ptr_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


template<typename _Tp> class __has_element_type_helper { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static true_type __test(_Wrap_type<typename _Up::element_type>*); template<typename _Up> static false_type __test(...); public: typedef decltype(__test<_Tp>(0)) type; }; template<typename _Tp> struct __has_element_type : public __has_element_type_helper <typename remove_cv<_Tp>::type>::type { };
template<typename _Tp> class __has_difference_type_helper { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static true_type __test(_Wrap_type<typename _Up::difference_type>*); template<typename _Up> static false_type __test(...); public: typedef decltype(__test<_Tp>(0)) type; }; template<typename _Tp> struct __has_difference_type : public __has_difference_type_helper <typename remove_cv<_Tp>::type>::type { };

  template<typename _Tp, bool = __has_element_type<_Tp>::value>
    struct __ptrtr_elt_type;

  template<typename _Tp>
    struct __ptrtr_elt_type<_Tp, true>
    {
      typedef typename _Tp::element_type __type;
    };

  template<template<typename, typename...> class _SomePtr, typename _Tp,
            typename... _Args>
    struct __ptrtr_elt_type<_SomePtr<_Tp, _Args...>, false>
    {
      typedef _Tp __type;
    };

  template<typename _Tp, bool = __has_difference_type<_Tp>::value>
    struct __ptrtr_diff_type
    {
      typedef typename _Tp::difference_type __type;
    };

  template<typename _Tp>
    struct __ptrtr_diff_type<_Tp, false>
    {
      typedef ptrdiff_t __type;
    };

  template<typename _Ptr, typename _Up>
    class __ptrtr_rebind_helper
    {
      template<typename _Ptr2, typename _Up2>
 static constexpr true_type
 _S_chk(typename _Ptr2::template rebind<_Up2>*);

      template<typename, typename>
 static constexpr false_type
 _S_chk(...);

    public:
      using __type = decltype(_S_chk<_Ptr, _Up>(nullptr));
    };

  template<typename _Tp, typename _Up,
           bool = __ptrtr_rebind_helper<_Tp, _Up>::__type::value>
    struct __ptrtr_rebind;

  template<typename _Tp, typename _Up>
    struct __ptrtr_rebind<_Tp, _Up, true>
    {
      typedef typename _Tp::template rebind<_Up> __type;
    };

  template<template<typename, typename...> class _SomePtr, typename _Up,
            typename _Tp, typename... _Args>
    struct __ptrtr_rebind<_SomePtr<_Tp, _Args...>, _Up, false>
    {
      typedef _SomePtr<_Up, _Args...> __type;
    };

  template<typename _Tp, typename = typename remove_cv<_Tp>::type>
    struct __ptrtr_not_void
    {
      typedef _Tp __type;
    };

  template<typename _Tp>
    struct __ptrtr_not_void<_Tp, void>
    {
      struct __type { };
    };

  template<typename _Ptr>
    class __ptrtr_pointer_to
    {
      typedef typename __ptrtr_elt_type<_Ptr>::__type __orig_type;
      typedef typename __ptrtr_not_void<__orig_type>::__type __element_type;

    public:
      static _Ptr pointer_to(__element_type& __e)
      { return _Ptr::pointer_to(__e); }
    };





  template<typename _Ptr>
    struct pointer_traits : __ptrtr_pointer_to<_Ptr>
    {

      typedef _Ptr pointer;

      typedef typename __ptrtr_elt_type<_Ptr>::__type element_type;

      typedef typename __ptrtr_diff_type<_Ptr>::__type difference_type;

      template<typename _Up>
        using rebind = typename __ptrtr_rebind<_Ptr, _Up>::__type;
    };





  template<typename _Tp>
    struct pointer_traits<_Tp*>
    {

      typedef _Tp* pointer;

      typedef _Tp element_type;

      typedef ptrdiff_t difference_type;

      template<typename _Up>
        using rebind = _Up*;






      static pointer
      pointer_to(typename __ptrtr_not_void<element_type>::__type& __r) noexcept
      { return std::addressof(__r); }
    };


}
# 67 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 96 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class reverse_iterator
    : public iterator<typename iterator_traits<_Iterator>::iterator_category,
        typename iterator_traits<_Iterator>::value_type,
        typename iterator_traits<_Iterator>::difference_type,
        typename iterator_traits<_Iterator>::pointer,
                      typename iterator_traits<_Iterator>::reference>
    {
    protected:
      _Iterator current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::pointer pointer;
      typedef typename __traits_type::reference reference;







      reverse_iterator() : current() { }




      explicit
      reverse_iterator(iterator_type __x) : current(__x) { }




      reverse_iterator(const reverse_iterator& __x)
      : current(__x.current) { }





      template<typename _Iter>
        reverse_iterator(const reverse_iterator<_Iter>& __x)
 : current(__x.base()) { }




      iterator_type
      base() const
      { return current; }
# 160 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 3
      reference
      operator*() const
      {
 _Iterator __tmp = current;
 return *--__tmp;
      }






      pointer
      operator->() const
      { return &(operator*()); }






      reverse_iterator&
      operator++()
      {
 --current;
 return *this;
      }






      reverse_iterator
      operator++(int)
      {
 reverse_iterator __tmp = *this;
 --current;
 return __tmp;
      }






      reverse_iterator&
      operator--()
      {
 ++current;
 return *this;
      }






      reverse_iterator
      operator--(int)
      {
 reverse_iterator __tmp = *this;
 ++current;
 return __tmp;
      }






      reverse_iterator
      operator+(difference_type __n) const
      { return reverse_iterator(current - __n); }







      reverse_iterator&
      operator+=(difference_type __n)
      {
 current -= __n;
 return *this;
      }






      reverse_iterator
      operator-(difference_type __n) const
      { return reverse_iterator(current + __n); }







      reverse_iterator&
      operator-=(difference_type __n)
      {
 current += __n;
 return *this;
      }






      reference
      operator[](difference_type __n) const
      { return *(*this + __n); }
    };
# 290 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 3
  template<typename _Iterator>
    inline bool
    operator==(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() < __x.base(); }

  template<typename _Iterator>
    inline bool
    operator!=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator>(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator<=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator>=(const reverse_iterator<_Iterator>& __x,
        const reverse_iterator<_Iterator>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline typename reverse_iterator<_Iterator>::difference_type
    operator-(const reverse_iterator<_Iterator>& __x,
       const reverse_iterator<_Iterator>& __y)
    { return __y.base() - __x.base(); }

  template<typename _Iterator>
    inline reverse_iterator<_Iterator>
    operator+(typename reverse_iterator<_Iterator>::difference_type __n,
       const reverse_iterator<_Iterator>& __x)
    { return reverse_iterator<_Iterator>(__x.base() - __n); }



  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y.base() < __x.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const reverse_iterator<_IteratorL>& __x,
        const reverse_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _IteratorL, typename _IteratorR>


    inline auto
    operator-(const reverse_iterator<_IteratorL>& __x,
       const reverse_iterator<_IteratorR>& __y)
    -> decltype(__y.base() - __x.base())





    { return __y.base() - __x.base(); }
# 402 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 3
  template<typename _Container>
    class back_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit
      back_insert_iterator(_Container& __x) : container(&__x) { }
# 436 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 3
      back_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_back(__value);
 return *this;
      }

      back_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_back(std::move(__value));
 return *this;
      }



      back_insert_iterator&
      operator*()
      { return *this; }


      back_insert_iterator&
      operator++()
      { return *this; }


      back_insert_iterator
      operator++(int)
      { return *this; }
    };
# 478 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 3
  template<typename _Container>
    inline back_insert_iterator<_Container>
    back_inserter(_Container& __x)
    { return back_insert_iterator<_Container>(__x); }
# 493 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 3
  template<typename _Container>
    class front_insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;

    public:

      typedef _Container container_type;


      explicit front_insert_iterator(_Container& __x) : container(&__x) { }
# 526 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 3
      front_insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 container->push_front(__value);
 return *this;
      }

      front_insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 container->push_front(std::move(__value));
 return *this;
      }



      front_insert_iterator&
      operator*()
      { return *this; }


      front_insert_iterator&
      operator++()
      { return *this; }


      front_insert_iterator
      operator++(int)
      { return *this; }
    };
# 568 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 3
  template<typename _Container>
    inline front_insert_iterator<_Container>
    front_inserter(_Container& __x)
    { return front_insert_iterator<_Container>(__x); }
# 587 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 3
  template<typename _Container>
    class insert_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _Container* container;
      typename _Container::iterator iter;

    public:

      typedef _Container container_type;





      insert_iterator(_Container& __x, typename _Container::iterator __i)
      : container(&__x), iter(__i) {}
# 638 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 3
      insert_iterator&
      operator=(const typename _Container::value_type& __value)
      {
 iter = container->insert(iter, __value);
 ++iter;
 return *this;
      }

      insert_iterator&
      operator=(typename _Container::value_type&& __value)
      {
 iter = container->insert(iter, std::move(__value));
 ++iter;
 return *this;
      }



      insert_iterator&
      operator*()
      { return *this; }


      insert_iterator&
      operator++()
      { return *this; }


      insert_iterator&
      operator++(int)
      { return *this; }
    };
# 682 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 3
  template<typename _Container, typename _Iterator>
    inline insert_iterator<_Container>
    inserter(_Container& __x, _Iterator __i)
    {
      return insert_iterator<_Container>(__x,
      typename _Container::iterator(__i));
    }




}

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 706 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 3
  using std::iterator_traits;
  using std::iterator;
  template<typename _Iterator, typename _Container>
    class __normal_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;
      typedef typename __traits_type::reference reference;
      typedef typename __traits_type::pointer pointer;

      constexpr __normal_iterator() noexcept
      : _M_current(_Iterator()) { }

      explicit
      __normal_iterator(const _Iterator& __i) noexcept
      : _M_current(__i) { }


      template<typename _Iter>
        __normal_iterator(const __normal_iterator<_Iter,
     typename __enable_if<
              (std::__are_same<_Iter, typename _Container::pointer>::__value),
        _Container>::__type>& __i) noexcept
        : _M_current(__i.base()) { }


      reference
      operator*() const noexcept
      { return *_M_current; }

      pointer
      operator->() const noexcept
      { return _M_current; }

      __normal_iterator&
      operator++() noexcept
      {
 ++_M_current;
 return *this;
      }

      __normal_iterator
      operator++(int) noexcept
      { return __normal_iterator(_M_current++); }


      __normal_iterator&
      operator--() noexcept
      {
 --_M_current;
 return *this;
      }

      __normal_iterator
      operator--(int) noexcept
      { return __normal_iterator(_M_current--); }


      reference
      operator[](difference_type __n) const noexcept
      { return _M_current[__n]; }

      __normal_iterator&
      operator+=(difference_type __n) noexcept
      { _M_current += __n; return *this; }

      __normal_iterator
      operator+(difference_type __n) const noexcept
      { return __normal_iterator(_M_current + __n); }

      __normal_iterator&
      operator-=(difference_type __n) noexcept
      { _M_current -= __n; return *this; }

      __normal_iterator
      operator-(difference_type __n) const noexcept
      { return __normal_iterator(_M_current - __n); }

      const _Iterator&
      base() const noexcept
      { return _M_current; }
    };
# 806 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 3
  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator==(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator==(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() == __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator!=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() != __rhs.base(); }


  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() < __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() > __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator<=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() <= __rhs.base(); }

  template<typename _IteratorL, typename _IteratorR, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_IteratorL, _Container>& __lhs,
        const __normal_iterator<_IteratorR, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline bool
    operator>=(const __normal_iterator<_Iterator, _Container>& __lhs,
        const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() >= __rhs.base(); }





  template<typename _IteratorL, typename _IteratorR, typename _Container>


    inline auto
    operator-(const __normal_iterator<_IteratorL, _Container>& __lhs,
       const __normal_iterator<_IteratorR, _Container>& __rhs) noexcept
    -> decltype(__lhs.base() - __rhs.base())





    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline typename __normal_iterator<_Iterator, _Container>::difference_type
    operator-(const __normal_iterator<_Iterator, _Container>& __lhs,
       const __normal_iterator<_Iterator, _Container>& __rhs)
    noexcept
    { return __lhs.base() - __rhs.base(); }

  template<typename _Iterator, typename _Container>
    inline __normal_iterator<_Iterator, _Container>
    operator+(typename __normal_iterator<_Iterator, _Container>::difference_type
       __n, const __normal_iterator<_Iterator, _Container>& __i)
    noexcept
    { return __normal_iterator<_Iterator, _Container>(__i.base() + __n); }


}



namespace std __attribute__ ((__visibility__ ("default")))
{

# 946 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_iterator.h" 3
  template<typename _Iterator>
    class move_iterator
    {
    protected:
      _Iterator _M_current;

      typedef iterator_traits<_Iterator> __traits_type;

    public:
      typedef _Iterator iterator_type;
      typedef typename __traits_type::iterator_category iterator_category;
      typedef typename __traits_type::value_type value_type;
      typedef typename __traits_type::difference_type difference_type;

      typedef _Iterator pointer;
      typedef value_type&& reference;

      move_iterator()
      : _M_current() { }

      explicit
      move_iterator(iterator_type __i)
      : _M_current(__i) { }

      template<typename _Iter>
 move_iterator(const move_iterator<_Iter>& __i)
 : _M_current(__i.base()) { }

      iterator_type
      base() const
      { return _M_current; }

      reference
      operator*() const
      { return std::move(*_M_current); }

      pointer
      operator->() const
      { return _M_current; }

      move_iterator&
      operator++()
      {
 ++_M_current;
 return *this;
      }

      move_iterator
      operator++(int)
      {
 move_iterator __tmp = *this;
 ++_M_current;
 return __tmp;
      }

      move_iterator&
      operator--()
      {
 --_M_current;
 return *this;
      }

      move_iterator
      operator--(int)
      {
 move_iterator __tmp = *this;
 --_M_current;
 return __tmp;
      }

      move_iterator
      operator+(difference_type __n) const
      { return move_iterator(_M_current + __n); }

      move_iterator&
      operator+=(difference_type __n)
      {
 _M_current += __n;
 return *this;
      }

      move_iterator
      operator-(difference_type __n) const
      { return move_iterator(_M_current - __n); }

      move_iterator&
      operator-=(difference_type __n)
      {
 _M_current -= __n;
 return *this;
      }

      reference
      operator[](difference_type __n) const
      { return std::move(_M_current[__n]); }
    };




  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator==(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return __x.base() == __y.base(); }

  template<typename _Iterator>
    inline bool
    operator==(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return __x.base() == __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator!=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x == __y); }

  template<typename _Iterator>
    inline bool
    operator!=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x == __y); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __x.base() < __y.base(); }

  template<typename _Iterator>
    inline bool
    operator<(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __x.base() < __y.base(); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator<=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__y < __x); }

  template<typename _Iterator>
    inline bool
    operator<=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__y < __x); }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    { return __y < __x; }

  template<typename _Iterator>
    inline bool
    operator>(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    { return __y < __x; }

  template<typename _IteratorL, typename _IteratorR>
    inline bool
    operator>=(const move_iterator<_IteratorL>& __x,
        const move_iterator<_IteratorR>& __y)
    { return !(__x < __y); }

  template<typename _Iterator>
    inline bool
    operator>=(const move_iterator<_Iterator>& __x,
        const move_iterator<_Iterator>& __y)
    { return !(__x < __y); }


  template<typename _IteratorL, typename _IteratorR>
    inline auto
    operator-(const move_iterator<_IteratorL>& __x,
       const move_iterator<_IteratorR>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline auto
    operator-(const move_iterator<_Iterator>& __x,
       const move_iterator<_Iterator>& __y)
    -> decltype(__x.base() - __y.base())
    { return __x.base() - __y.base(); }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    operator+(typename move_iterator<_Iterator>::difference_type __n,
       const move_iterator<_Iterator>& __x)
    { return __x + __n; }

  template<typename _Iterator>
    inline move_iterator<_Iterator>
    make_move_iterator(_Iterator __i)
    { return move_iterator<_Iterator>(__i); }

  template<typename _Iterator, typename _ReturnType
    = typename conditional<__move_if_noexcept_cond
      <typename iterator_traits<_Iterator>::value_type>::value,
                _Iterator, move_iterator<_Iterator>>::type>
    inline _ReturnType
    __make_move_if_noexcept_iterator(_Iterator __i)
    { return _ReturnType(__i); }




}
# 68 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 2 3



# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/predefined_ops.h" 1 3
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/predefined_ops.h" 3
namespace __gnu_cxx
{
namespace __ops
{
  struct _Iter_less_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 < *__it2; }
  };

  inline _Iter_less_iter
  __iter_less_iter()
  { return _Iter_less_iter(); }

  struct _Iter_less_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it < __val; }
    };

  inline _Iter_less_val
  __iter_less_val()
  { return _Iter_less_val(); }

  inline _Iter_less_val
  __iter_comp_val(_Iter_less_iter)
  { return _Iter_less_val(); }

  struct _Val_less_iter
  {
    template<typename _Value, typename _Iterator>
      bool
      operator()(_Value& __val, _Iterator __it) const
      { return __val < *__it; }
    };

  inline _Val_less_iter
  __val_less_iter()
  { return _Val_less_iter(); }

  inline _Val_less_iter
  __val_comp_iter(_Iter_less_iter)
  { return _Val_less_iter(); }

  struct _Iter_equal_to_iter
  {
    template<typename _Iterator1, typename _Iterator2>
      bool
      operator()(_Iterator1 __it1, _Iterator2 __it2) const
      { return *__it1 == *__it2; }
    };

  inline _Iter_equal_to_iter
  __iter_equal_to_iter()
  { return _Iter_equal_to_iter(); }

  struct _Iter_equal_to_val
  {
    template<typename _Iterator, typename _Value>
      bool
      operator()(_Iterator __it, _Value& __val) const
      { return *__it == __val; }
    };

  inline _Iter_equal_to_val
  __iter_equal_to_val()
  { return _Iter_equal_to_val(); }

  inline _Iter_equal_to_val
  __iter_comp_val(_Iter_equal_to_iter)
  { return _Iter_equal_to_val(); }

  template<typename _Compare>
    struct _Iter_comp_iter
    {
      _Compare _M_comp;

      _Iter_comp_iter(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Iterator1, typename _Iterator2>
        bool
        operator()(_Iterator1 __it1, _Iterator2 __it2)
        { return bool(_M_comp(*__it1, *__it2)); }
    };

  template<typename _Compare>
    inline _Iter_comp_iter<_Compare>
    __iter_comp_iter(_Compare __comp)
    { return _Iter_comp_iter<_Compare>(__comp); }

  template<typename _Compare>
    struct _Iter_comp_val
    {
      _Compare _M_comp;

      _Iter_comp_val(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Iterator, typename _Value>
 bool
 operator()(_Iterator __it, _Value& __val)
 { return bool(_M_comp(*__it, __val)); }
    };

  template<typename _Compare>
   inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Compare __comp)
    { return _Iter_comp_val<_Compare>(__comp); }

  template<typename _Compare>
    inline _Iter_comp_val<_Compare>
    __iter_comp_val(_Iter_comp_iter<_Compare> __comp)
    { return _Iter_comp_val<_Compare>(__comp._M_comp); }

  template<typename _Compare>
    struct _Val_comp_iter
    {
      _Compare _M_comp;

      _Val_comp_iter(_Compare __comp)
 : _M_comp(__comp)
      { }

      template<typename _Value, typename _Iterator>
 bool
 operator()(_Value& __val, _Iterator __it)
 { return bool(_M_comp(__val, *__it)); }
    };

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Compare __comp)
    { return _Val_comp_iter<_Compare>(__comp); }

  template<typename _Compare>
    inline _Val_comp_iter<_Compare>
    __val_comp_iter(_Iter_comp_iter<_Compare> __comp)
    { return _Val_comp_iter<_Compare>(__comp._M_comp); }

  template<typename _Value>
    struct _Iter_equals_val
    {
      _Value& _M_value;

      _Iter_equals_val(_Value& __value)
 : _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return *__it == _M_value; }
    };

  template<typename _Value>
    inline _Iter_equals_val<_Value>
    __iter_equals_val(_Value& __val)
    { return _Iter_equals_val<_Value>(__val); }

  template<typename _Iterator1>
    struct _Iter_equals_iter
    {
      typename std::iterator_traits<_Iterator1>::reference _M_ref;

      _Iter_equals_iter(_Iterator1 __it1)
 : _M_ref(*__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return *__it2 == _M_ref; }
    };

  template<typename _Iterator>
    inline _Iter_equals_iter<_Iterator>
    __iter_comp_iter(_Iter_equal_to_iter, _Iterator __it)
    { return _Iter_equals_iter<_Iterator>(__it); }

  template<typename _Predicate>
    struct _Iter_pred
    {
      _Predicate _M_pred;

      _Iter_pred(_Predicate __pred)
 : _M_pred(__pred)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_pred<_Predicate>
    __pred_iter(_Predicate __pred)
    { return _Iter_pred<_Predicate>(__pred); }

  template<typename _Compare, typename _Value>
    struct _Iter_comp_to_val
    {
      _Compare _M_comp;
      _Value& _M_value;

      _Iter_comp_to_val(_Compare __comp, _Value& __value)
 : _M_comp(__comp), _M_value(__value)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return bool(_M_comp(*__it, _M_value)); }
    };

  template<typename _Compare, typename _Value>
    _Iter_comp_to_val<_Compare, _Value>
    __iter_comp_val(_Compare __comp, _Value &__val)
    { return _Iter_comp_to_val<_Compare, _Value>(__comp, __val); }

  template<typename _Compare, typename _Iterator1>
    struct _Iter_comp_to_iter
    {
      _Compare _M_comp;
      typename std::iterator_traits<_Iterator1>::reference _M_ref;

      _Iter_comp_to_iter(_Compare __comp, _Iterator1 __it1)
 : _M_comp(__comp), _M_ref(*__it1)
      { }

      template<typename _Iterator2>
 bool
 operator()(_Iterator2 __it2)
 { return bool(_M_comp(*__it2, _M_ref)); }
    };

  template<typename _Compare, typename _Iterator>
    inline _Iter_comp_to_iter<_Compare, _Iterator>
    __iter_comp_iter(_Iter_comp_iter<_Compare> __comp, _Iterator __it)
    { return _Iter_comp_to_iter<_Compare, _Iterator>(__comp._M_comp, __it); }

  template<typename _Predicate>
    struct _Iter_negate
    {
      _Predicate _M_pred;

      _Iter_negate(_Predicate __pred)
 : _M_pred(__pred)
      { }

      template<typename _Iterator>
 bool
 operator()(_Iterator __it)
 { return !bool(_M_pred(*__it)); }
    };

  template<typename _Predicate>
    inline _Iter_negate<_Predicate>
    __negate(_Iter_pred<_Predicate> __pred)
    { return _Iter_negate<_Predicate>(__pred._M_pred); }

}
}
# 72 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 118 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    inline void
    iter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)
    {

     

     
# 148 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
      swap(*__a, *__b);

    }
# 164 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _ForwardIterator1, typename _ForwardIterator2>
    _ForwardIterator2
    swap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1,
  _ForwardIterator2 __first2)
    {

     

     

      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 std::iter_swap(__first1, __first2);
      return __first2;
    }
# 192 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b)
    {

     

      if (__b < __a)
 return __b;
      return __a;
    }
# 215 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _Tp>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b)
    {

     

      if (__a < __b)
 return __b;
      return __a;
    }
# 238 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    min(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__b, __a))
 return __b;
      return __a;
    }
# 259 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _Tp, typename _Compare>
    inline const _Tp&
    max(const _Tp& __a, const _Tp& __b, _Compare __comp)
    {

      if (__comp(__a, __b))
 return __b;
      return __a;
    }



  template<typename _Iterator>
    struct _Niter_base
    : _Iter_base<_Iterator, __is_normal_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Niter_base<_Iterator>::iterator_type
    __niter_base(_Iterator __it)
    { return std::_Niter_base<_Iterator>::_S_base(__it); }


  template<typename _Iterator>
    struct _Miter_base
    : _Iter_base<_Iterator, __is_move_iterator<_Iterator>::__value>
    { };

  template<typename _Iterator>
    inline typename _Miter_base<_Iterator>::iterator_type
    __miter_base(_Iterator __it)
    { return std::_Miter_base<_Iterator>::_S_base(__it); }







  template<bool, bool, typename>
    struct __copy_move
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = *__first;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move<true, false, _Category>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   for (; __first != __last; ++__result, ++__first)
     *__result = std::move(*__first);
   return __result;
 }
    };


  template<>
    struct __copy_move<false, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = *__first;
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<>
    struct __copy_move<true, false, random_access_iterator_tag>
    {
      template<typename _II, typename _OI>
        static _OI
        __copy_m(_II __first, _II __last, _OI __result)
        {
   typedef typename iterator_traits<_II>::difference_type _Distance;
   for(_Distance __n = __last - __first; __n > 0; --__n)
     {
       *__result = std::move(*__first);
       ++__first;
       ++__result;
     }
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_m(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {


   static_assert( is_copy_assignable<_Tp>::value,
                  "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result, __first, sizeof(_Tp) * _Num);
   return __result + _Num;
 }
    };

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a(_II __first, _II __last, _OI __result)
    {
      typedef typename iterator_traits<_II>::value_type _ValueTypeI;
      typedef typename iterator_traits<_OI>::value_type _ValueTypeO;
      typedef typename iterator_traits<_II>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueTypeI)
                      && __is_pointer<_II>::__value
                      && __is_pointer<_OI>::__value
        && __are_same<_ValueTypeI, _ValueTypeO>::__value);

      return std::__copy_move<_IsMove, __simple,
                       _Category>::__copy_m(__first, __last, __result);
    }



  template<typename _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits>
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits>
    class ostreambuf_iterator;

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(_CharT*, _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
      ostreambuf_iterator<_CharT, char_traits<_CharT> > >::__type
    __copy_move_a2(const _CharT*, const _CharT*,
     ostreambuf_iterator<_CharT, char_traits<_CharT> >);

  template<bool _IsMove, typename _CharT>
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value,
        _CharT*>::__type
    __copy_move_a2(istreambuf_iterator<_CharT, char_traits<_CharT> >,
     istreambuf_iterator<_CharT, char_traits<_CharT> >, _CharT*);

  template<bool _IsMove, typename _II, typename _OI>
    inline _OI
    __copy_move_a2(_II __first, _II __last, _OI __result)
    {
      return _OI(std::__copy_move_a<_IsMove>(std::__niter_base(__first),
          std::__niter_base(__last),
          std::__niter_base(__result)));
    }
# 454 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    copy(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return (std::__copy_move_a2<__is_move_iterator<_II>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 487 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _II, typename _OI>
    inline _OI
    move(_II __first, _II __last, _OI __result)
    {

     
     

      ;

      return std::__copy_move_a2<true>(std::__miter_base(__first),
           std::__miter_base(__last), __result);
    }






  template<bool, bool, typename>
    struct __copy_move_backward
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = *--__last;
   return __result;
 }
    };


  template<typename _Category>
    struct __copy_move_backward<true, false, _Category>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   while (__first != __last)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<false, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = *--__last;
   return __result;
 }
    };


  template<>
    struct __copy_move_backward<true, false, random_access_iterator_tag>
    {
      template<typename _BI1, typename _BI2>
        static _BI2
        __copy_move_b(_BI1 __first, _BI1 __last, _BI2 __result)
        {
   typename iterator_traits<_BI1>::difference_type __n;
   for (__n = __last - __first; __n > 0; --__n)
     *--__result = std::move(*--__last);
   return __result;
 }
    };


  template<bool _IsMove>
    struct __copy_move_backward<_IsMove, true, random_access_iterator_tag>
    {
      template<typename _Tp>
        static _Tp*
        __copy_move_b(const _Tp* __first, const _Tp* __last, _Tp* __result)
        {


   static_assert( is_copy_assignable<_Tp>::value,
                  "type is not assignable" );

   const ptrdiff_t _Num = __last - __first;
   if (_Num)
     __builtin_memmove(__result - _Num, __first, sizeof(_Tp) * _Num);
   return __result - _Num;
 }
    };

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      typedef typename iterator_traits<_BI1>::value_type _ValueType1;
      typedef typename iterator_traits<_BI2>::value_type _ValueType2;
      typedef typename iterator_traits<_BI1>::iterator_category _Category;
      const bool __simple = (__is_trivial(_ValueType1)
                      && __is_pointer<_BI1>::__value
                      && __is_pointer<_BI2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__copy_move_backward<_IsMove, __simple,
                                _Category>::__copy_move_b(__first,
         __last,
         __result);
    }

  template<bool _IsMove, typename _BI1, typename _BI2>
    inline _BI2
    __copy_move_backward_a2(_BI1 __first, _BI1 __last, _BI2 __result)
    {
      return _BI2(std::__copy_move_backward_a<_IsMove>
    (std::__niter_base(__first), std::__niter_base(__last),
     std::__niter_base(__result)));
    }
# 628 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    copy_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return (std::__copy_move_backward_a2<__is_move_iterator<_BI1>::__value>
       (std::__miter_base(__first), std::__miter_base(__last),
        __result));
    }
# 664 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _BI1, typename _BI2>
    inline _BI2
    move_backward(_BI1 __first, _BI1 __last, _BI2 __result)
    {

     
     
     


      ;

      return std::__copy_move_backward_a2<true>(std::__miter_base(__first),
      std::__miter_base(__last),
      __result);
    }






  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
       const _Tp& __value)
    {
      for (; __first != __last; ++__first)
 *__first = __value;
    }

  template<typename _ForwardIterator, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, void>::__type
    __fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (; __first != __last; ++__first)
 *__first = __tmp;
    }


  template<typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, void>::__type
    __fill_a(_Tp* __first, _Tp* __last, const _Tp& __c)
    {
      const _Tp __tmp = __c;
      __builtin_memset(__first, static_cast<unsigned char>(__tmp),
         __last - __first);
    }
# 730 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)
    {

     

      ;

      std::__fill_a(std::__niter_base(__first), std::__niter_base(__last),
      __value);
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<!__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __value;
      return __first;
    }

  template<typename _OutputIterator, typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_scalar<_Tp>::__value, _OutputIterator>::__type
    __fill_n_a(_OutputIterator __first, _Size __n, const _Tp& __value)
    {
      const _Tp __tmp = __value;
      for (__decltype(__n + 0) __niter = __n;
    __niter > 0; --__niter, ++__first)
 *__first = __tmp;
      return __first;
    }

  template<typename _Size, typename _Tp>
    inline typename
    __gnu_cxx::__enable_if<__is_byte<_Tp>::__value, _Tp*>::__type
    __fill_n_a(_Tp* __first, _Size __n, const _Tp& __c)
    {
      std::__fill_a(__first, __first + __n, __c);
      return __first + __n;
    }
# 790 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _OI, typename _Size, typename _Tp>
    inline _OI
    fill_n(_OI __first, _Size __n, const _Tp& __value)
    {

     

      return _OI(std::__fill_n_a(std::__niter_base(__first), __n, __value));
    }

  template<bool _BoolType>
    struct __equal
    {
      template<typename _II1, typename _II2>
        static bool
        equal(_II1 __first1, _II1 __last1, _II2 __first2)
        {
   for (; __first1 != __last1; ++__first1, ++__first2)
     if (!(*__first1 == *__first2))
       return false;
   return true;
 }
    };

  template<>
    struct __equal<true>
    {
      template<typename _Tp>
        static bool
        equal(const _Tp* __first1, const _Tp* __last1, const _Tp* __first2)
        {
   return !__builtin_memcmp(__first1, __first2, sizeof(_Tp)
       * (__last1 - __first1));
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __equal_aux(_II1 __first1, _II1 __last1, _II2 __first2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple = ((__is_integer<_ValueType1>::__value
         || __is_pointer<_ValueType1>::__value)
                      && __is_pointer<_II1>::__value
                      && __is_pointer<_II2>::__value
        && __are_same<_ValueType1, _ValueType2>::__value);

      return std::__equal<__simple>::equal(__first1, __last1, __first2);
    }

  template<typename, typename>
    struct __lc_rai
    {
      template<typename _II1, typename _II2>
        static _II1
        __newlast1(_II1, _II1 __last1, _II2, _II2)
        { return __last1; }

      template<typename _II>
        static bool
        __cnd2(_II __first, _II __last)
        { return __first != __last; }
    };

  template<>
    struct __lc_rai<random_access_iterator_tag, random_access_iterator_tag>
    {
      template<typename _RAI1, typename _RAI2>
        static _RAI1
        __newlast1(_RAI1 __first1, _RAI1 __last1,
     _RAI2 __first2, _RAI2 __last2)
        {
   const typename iterator_traits<_RAI1>::difference_type
     __diff1 = __last1 - __first1;
   const typename iterator_traits<_RAI2>::difference_type
     __diff2 = __last2 - __first2;
   return __diff2 < __diff1 ? __first1 + __diff2 : __last1;
 }

      template<typename _RAI>
        static bool
        __cnd2(_RAI, _RAI)
        { return true; }
    };

  template<typename _II1, typename _II2, typename _Compare>
    bool
    __lexicographical_compare_impl(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2,
       _Compare __comp)
    {
      typedef typename iterator_traits<_II1>::iterator_category _Category1;
      typedef typename iterator_traits<_II2>::iterator_category _Category2;
      typedef std::__lc_rai<_Category1, _Category2> __rai_type;

      __last1 = __rai_type::__newlast1(__first1, __last1, __first2, __last2);
      for (; __first1 != __last1 && __rai_type::__cnd2(__first2, __last2);
    ++__first1, ++__first2)
 {
   if (__comp(__first1, __first2))
     return true;
   if (__comp(__first2, __first1))
     return false;
 }
      return __first1 == __last1 && __first2 != __last2;
    }

  template<bool _BoolType>
    struct __lexicographical_compare
    {
      template<typename _II1, typename _II2>
        static bool __lc(_II1, _II1, _II2, _II2);
    };

  template<bool _BoolType>
    template<typename _II1, typename _II2>
      bool
      __lexicographical_compare<_BoolType>::
      __lc(_II1 __first1, _II1 __last1, _II2 __first2, _II2 __last2)
      {
 return std::__lexicographical_compare_impl(__first1, __last1,
         __first2, __last2,
     __gnu_cxx::__ops::__iter_less_iter());
      }

  template<>
    struct __lexicographical_compare<true>
    {
      template<typename _Tp, typename _Up>
        static bool
        __lc(const _Tp* __first1, const _Tp* __last1,
      const _Up* __first2, const _Up* __last2)
 {
   const size_t __len1 = __last1 - __first1;
   const size_t __len2 = __last2 - __first2;
   const int __result = __builtin_memcmp(__first1, __first2,
      std::min(__len1, __len2));
   return __result != 0 ? __result < 0 : __len1 < __len2;
 }
    };

  template<typename _II1, typename _II2>
    inline bool
    __lexicographical_compare_aux(_II1 __first1, _II1 __last1,
      _II2 __first2, _II2 __last2)
    {
      typedef typename iterator_traits<_II1>::value_type _ValueType1;
      typedef typename iterator_traits<_II2>::value_type _ValueType2;
      const bool __simple =
 (__is_byte<_ValueType1>::__value && __is_byte<_ValueType2>::__value
  && !__gnu_cxx::__numeric_traits<_ValueType1>::__is_signed
  && !__gnu_cxx::__numeric_traits<_ValueType2>::__is_signed
  && __is_pointer<_II1>::__value
  && __is_pointer<_II2>::__value);

      return std::__lexicographical_compare<__simple>::__lc(__first1, __last1,
           __first2, __last2);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Compare>
    _ForwardIterator
    __lower_bound(_ForwardIterator __first, _ForwardIterator __last,
    const _Tp& __val, _Compare __comp)
    {
      typedef typename iterator_traits<_ForwardIterator>::difference_type
 _DistanceType;

      _DistanceType __len = std::distance(__first, __last);

      while (__len > 0)
 {
   _DistanceType __half = __len >> 1;
   _ForwardIterator __middle = __first;
   std::advance(__middle, __half);
   if (__comp(__middle, __val))
     {
       __first = __middle;
       ++__first;
       __len = __len - __half - 1;
     }
   else
     __len = __half;
 }
      return __first;
    }
# 988 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    lower_bound(_ForwardIterator __first, _ForwardIterator __last,
  const _Tp& __val)
    {

     
     

      ;

      return std::__lower_bound(__first, __last, __val,
    __gnu_cxx::__ops::__iter_less_val());
    }



  inline constexpr int
  __lg(int __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr unsigned
  __lg(unsigned __n)
  { return sizeof(int) * 8 - 1 - __builtin_clz(__n); }

  inline constexpr long
  __lg(long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr unsigned long
  __lg(unsigned long __n)
  { return sizeof(long) * 8 - 1 - __builtin_clzl(__n); }

  inline constexpr long long
  __lg(long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }

  inline constexpr unsigned long long
  __lg(unsigned long long __n)
  { return sizeof(long long) * 8 - 1 - __builtin_clzll(__n); }




# 1045 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    equal(_II1 __first1, _II1 __last1, _II2 __first2)
    {

     
     
     


      ;

      return std::__equal_aux(std::__niter_base(__first1),
         std::__niter_base(__last1),
         std::__niter_base(__first2));
    }
# 1077 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _IIter1, typename _IIter2, typename _BinaryPredicate>
    inline bool
    equal(_IIter1 __first1, _IIter1 __last1,
   _IIter2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!bool(__binary_pred(*__first1, *__first2)))
   return false;
      return true;
    }
# 1202 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2)
    {





     
     
     
     
      ;
      ;

      return std::__lexicographical_compare_aux(std::__niter_base(__first1),
      std::__niter_base(__last1),
      std::__niter_base(__first2),
      std::__niter_base(__last2));
    }
# 1238 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _II1, typename _II2, typename _Compare>
    inline bool
    lexicographical_compare(_II1 __first1, _II1 __last1,
       _II2 __first2, _II2 __last2, _Compare __comp)
    {

     
     
      ;
      ;

      return std::__lexicographical_compare_impl
 (__first1, __last1, __first2, __last2,
  __gnu_cxx::__ops::__iter_comp_iter(__comp));
    }

  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    pair<_InputIterator1, _InputIterator2>
    __mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
        _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {
      while (__first1 != __last1 && __binary_pred(__first1, __first2))
        {
   ++__first1;
   ++__first2;
        }
      return pair<_InputIterator1, _InputIterator2>(__first1, __first2);
    }
# 1281 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2)
    {

     
     
     


      ;

      return std::__mismatch(__first1, __last1, __first2,
        __gnu_cxx::__ops::__iter_equal_to_iter());
    }
# 1314 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _BinaryPredicate>
    inline pair<_InputIterator1, _InputIterator2>
    mismatch(_InputIterator1 __first1, _InputIterator1 __last1,
      _InputIterator2 __first2, _BinaryPredicate __binary_pred)
    {

     
     
      ;

      return std::__mismatch(__first1, __last1, __first2,
 __gnu_cxx::__ops::__iter_comp_iter(__binary_pred));
    }
# 1414 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_algobase.h" 3

}
# 61 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/list" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/allocator.h" 1 3
# 46 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/allocator.h" 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/c++allocator.h" 1 3
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/c++allocator.h" 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/new_allocator.h" 1 3
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/new_allocator.h" 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/new" 1 3
# 37 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/new" 3
       
# 38 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/new" 3


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/exception" 1 3
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/exception" 3
       
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/exception" 3

#pragma GCC visibility push(default)


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/atomic_lockfree_defines.h" 1 3
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/atomic_lockfree_defines.h" 3
       
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/atomic_lockfree_defines.h" 3
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/exception" 2 3

extern "C++" {

namespace std
{
# 60 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/exception" 3
  class exception
  {
  public:
    exception() noexcept { }
    virtual ~exception() noexcept;



    virtual const char* what() const noexcept;
  };



  class bad_exception : public exception
  {
  public:
    bad_exception() noexcept { }



    virtual ~bad_exception() noexcept;


    virtual const char* what() const noexcept;
  };


  typedef void (*terminate_handler) ();


  typedef void (*unexpected_handler) ();


  terminate_handler set_terminate(terminate_handler) noexcept;



  terminate_handler get_terminate() noexcept;




  void terminate() noexcept __attribute__ ((__noreturn__));


  unexpected_handler set_unexpected(unexpected_handler) noexcept;



  unexpected_handler get_unexpected() noexcept;




  void unexpected() __attribute__ ((__noreturn__));
# 127 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/exception" 3
  bool uncaught_exception() noexcept __attribute__ ((__pure__));


}

namespace __gnu_cxx
{

# 152 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/exception" 3
  void __verbose_terminate_handler();


}

}

#pragma GCC visibility pop


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/exception_ptr.h" 1 3
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/exception_ptr.h" 3
#pragma GCC visibility push(default)
# 43 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/exception_ptr.h" 3
extern "C++" {

namespace std
{
  class type_info;





  namespace __exception_ptr
  {
    class exception_ptr;
  }

  using __exception_ptr::exception_ptr;





  exception_ptr current_exception() noexcept;


  void rethrow_exception(exception_ptr) __attribute__ ((__noreturn__));

  namespace __exception_ptr
  {




    class exception_ptr
    {
      void* _M_exception_object;

      explicit exception_ptr(void* __e) noexcept;

      void _M_addref() noexcept;
      void _M_release() noexcept;

      void *_M_get() const noexcept __attribute__ ((__pure__));

      friend exception_ptr std::current_exception() noexcept;
      friend void std::rethrow_exception(exception_ptr);

    public:
      exception_ptr() noexcept;

      exception_ptr(const exception_ptr&) noexcept;


      exception_ptr(nullptr_t) noexcept
      : _M_exception_object(0)
      { }

      exception_ptr(exception_ptr&& __o) noexcept
      : _M_exception_object(__o._M_exception_object)
      { __o._M_exception_object = 0; }
# 111 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/exception_ptr.h" 3
      exception_ptr&
      operator=(const exception_ptr&) noexcept;


      exception_ptr&
      operator=(exception_ptr&& __o) noexcept
      {
        exception_ptr(static_cast<exception_ptr&&>(__o)).swap(*this);
        return *this;
      }


      ~exception_ptr() noexcept;

      void
      swap(exception_ptr&) noexcept;
# 138 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/exception_ptr.h" 3
      explicit operator bool() const
      { return _M_exception_object; }


      friend bool
      operator==(const exception_ptr&, const exception_ptr&)
 noexcept __attribute__ ((__pure__));

      const class std::type_info*
      __cxa_exception_type() const noexcept
 __attribute__ ((__pure__));
    };

    bool
    operator==(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    bool
    operator!=(const exception_ptr&, const exception_ptr&)
      noexcept __attribute__ ((__pure__));

    inline void
    swap(exception_ptr& __lhs, exception_ptr& __rhs)
    { __lhs.swap(__rhs); }

  }



  template<typename _Ex>
    exception_ptr
    make_exception_ptr(_Ex __ex) noexcept
    {
      try
 {

   throw __ex;

 }
      catch(...)
 {
   return current_exception();
 }
    }





  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept __attribute__ ((__deprecated__));

  template<typename _Ex>
    exception_ptr
    copy_exception(_Ex __ex) noexcept
    { return std::make_exception_ptr<_Ex>(__ex); }


}

}

#pragma GCC visibility pop
# 163 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/exception" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/nested_exception.h" 1 3
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/nested_exception.h" 3
#pragma GCC visibility push(default)
# 45 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/nested_exception.h" 3
extern "C++" {

namespace std
{






  class nested_exception
  {
    exception_ptr _M_ptr;

  public:
    nested_exception() noexcept : _M_ptr(current_exception()) { }

    nested_exception(const nested_exception&) = default;

    nested_exception& operator=(const nested_exception&) = default;

    virtual ~nested_exception() noexcept;

    void
    rethrow_nested() const __attribute__ ((__noreturn__))
    { rethrow_exception(_M_ptr); }

    exception_ptr
    nested_ptr() const
    { return _M_ptr; }
  };

  template<typename _Except>
    struct _Nested_exception : public _Except, public nested_exception
    {
      explicit _Nested_exception(_Except&& __ex)
      : _Except(static_cast<_Except&&>(__ex))
      { }
    };

  template<typename _Ex>
    struct __get_nested_helper
    {
      static const nested_exception*
      _S_get(const _Ex& __ex)
      { return dynamic_cast<const nested_exception*>(&__ex); }
    };

  template<typename _Ex>
    struct __get_nested_helper<_Ex*>
    {
      static const nested_exception*
      _S_get(const _Ex* __ex)
      { return dynamic_cast<const nested_exception*>(__ex); }
    };

  template<typename _Ex>
    inline const nested_exception*
    __get_nested_exception(const _Ex& __ex)
    { return __get_nested_helper<_Ex>::_S_get(__ex); }

  template<typename _Ex>
    void
    __throw_with_nested(_Ex&&, const nested_exception* = 0)
    __attribute__ ((__noreturn__));

  template<typename _Ex>
    void
    __throw_with_nested(_Ex&&, ...) __attribute__ ((__noreturn__));




  template<typename _Ex>
    inline void
    __throw_with_nested(_Ex&& __ex, const nested_exception*)
    { throw __ex; }

  template<typename _Ex>
    inline void
    __throw_with_nested(_Ex&& __ex, ...)
    { throw _Nested_exception<_Ex>(static_cast<_Ex&&>(__ex)); }

  template<typename _Ex>
    void
    throw_with_nested(_Ex __ex) __attribute__ ((__noreturn__));



  template<typename _Ex>
    inline void
    throw_with_nested(_Ex __ex)
    {
      if (__get_nested_exception(__ex))
        throw __ex;
      __throw_with_nested(static_cast<_Ex&&>(__ex), &__ex);
    }


  template<typename _Ex>
    inline void
    rethrow_if_nested(const _Ex& __ex)
    {
      if (const nested_exception* __nested = __get_nested_exception(__ex))
        __nested->rethrow_nested();
    }


  inline void
  rethrow_if_nested(const nested_exception& __ex)
  { __ex.rethrow_nested(); }


}

}



#pragma GCC visibility pop
# 164 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/exception" 2 3
# 41 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/new" 2 3

#pragma GCC visibility push(default)

extern "C++" {

namespace std
{






  class bad_alloc : public exception
  {
  public:
    bad_alloc() throw() { }



    virtual ~bad_alloc() throw();


    virtual const char* what() const throw();
  };


  class bad_array_new_length : public bad_alloc
  {
  public:
    bad_array_new_length() throw() { };



    virtual ~bad_array_new_length() throw();


    virtual const char* what() const throw();
  };
# 99 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/new" 3
  struct nothrow_t { };

  extern const nothrow_t nothrow;



  typedef void (*new_handler)();



  new_handler set_new_handler(new_handler) throw();



  new_handler get_new_handler() noexcept;

}
# 128 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/new" 3
void* operator new(std::size_t)
  __attribute__((__externally_visible__));
void* operator new[](std::size_t)
  __attribute__((__externally_visible__));
void operator delete(void*) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, std::size_t) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*) noexcept
  __attribute__((__externally_visible__));
void* operator new(std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void* operator new[](std::size_t, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete(void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));
void operator delete[](void*, const std::nothrow_t&) noexcept
  __attribute__((__externally_visible__));


inline void* operator new(std::size_t, void* __p) noexcept
{ return __p; }
inline void* operator new[](std::size_t, void* __p) noexcept
{ return __p; }


inline void operator delete (void*, void*) noexcept { }
inline void operator delete[](void*, void*) noexcept { }

}

#pragma GCC visibility pop
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/new_allocator.h" 2 3






namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{


  using std::size_t;
  using std::ptrdiff_t;
# 57 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/new_allocator.h" 3
  template<typename _Tp>
    class new_allocator
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef new_allocator<_Tp1> other; };




      typedef std::true_type propagate_on_container_move_assignment;


      new_allocator() noexcept { }

      new_allocator(const new_allocator&) noexcept { }

      template<typename _Tp1>
        new_allocator(const new_allocator<_Tp1>&) noexcept { }

      ~new_allocator() noexcept { }

      pointer
      address(reference __x) const noexcept
      { return std::__addressof(__x); }

      const_pointer
      address(const_reference __x) const noexcept
      { return std::__addressof(__x); }



      pointer
      allocate(size_type __n, const void* = 0)
      {
 if (__n > this->max_size())
   std::__throw_bad_alloc();

 return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
      }
# 114 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/new_allocator.h" 3
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }


      size_type
      max_size() const noexcept
      { return size_t(-1) / sizeof(_Tp); }


      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
 { ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }

      template<typename _Up>
        void
        destroy(_Up* __p) { __p->~_Up(); }
# 142 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/new_allocator.h" 3
    };

  template<typename _Tp>
    inline bool
    operator==(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator!=(const new_allocator<_Tp>&, const new_allocator<_Tp>&)
    { return false; }


}
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/c++allocator.h" 2 3


namespace std
{
# 47 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/c++allocator.h" 3
  template<typename _Tp>
    using __allocator_base = __gnu_cxx::new_allocator<_Tp>;
}
# 47 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/allocator.h" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/memoryfwd.h" 1 3
# 46 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/memoryfwd.h" 3
       
# 47 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/memoryfwd.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 63 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/memoryfwd.h" 3
  template<typename>
    class allocator;

  template<>
    class allocator<void>;


  template<typename, typename>
    struct uses_allocator;




}
# 48 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/allocator.h" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{








  template<>
    class allocator<void>
    {
    public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef void* pointer;
      typedef const void* const_pointer;
      typedef void value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;

    };
# 91 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/allocator.h" 3
  template<typename _Tp>
    class allocator: public __allocator_base<_Tp>
    {
   public:
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Tp* pointer;
      typedef const _Tp* const_pointer;
      typedef _Tp& reference;
      typedef const _Tp& const_reference;
      typedef _Tp value_type;

      template<typename _Tp1>
        struct rebind
        { typedef allocator<_Tp1> other; };




      typedef true_type propagate_on_container_move_assignment;


      allocator() throw() { }

      allocator(const allocator& __a) throw()
      : __allocator_base<_Tp>(__a) { }

      template<typename _Tp1>
        allocator(const allocator<_Tp1>&) throw() { }

      ~allocator() throw() { }


    };

  template<typename _T1, typename _T2>
    inline bool
    operator==(const allocator<_T1>&, const allocator<_T2>&)
    { return true; }

  template<typename _Tp>
    inline bool
    operator==(const allocator<_Tp>&, const allocator<_Tp>&)
    { return true; }

  template<typename _T1, typename _T2>
    inline bool
    operator!=(const allocator<_T1>&, const allocator<_T2>&)
    { return false; }

  template<typename _Tp>
    inline bool
    operator!=(const allocator<_Tp>&, const allocator<_Tp>&)
    { return false; }






  extern template class allocator<char>;
  extern template class allocator<wchar_t>;






  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_swap
    { static void _S_do_it(_Alloc&, _Alloc&) noexcept { } };

  template<typename _Alloc>
    struct __alloc_swap<_Alloc, false>
    {
      static void
      _S_do_it(_Alloc& __one, _Alloc& __two) noexcept
      {

 if (__one != __two)
   swap(__one, __two);
      }
    };


  template<typename _Alloc, bool = __is_empty(_Alloc)>
    struct __alloc_neq
    {
      static bool
      _S_do_it(const _Alloc&, const _Alloc&)
      { return false; }
    };

  template<typename _Alloc>
    struct __alloc_neq<_Alloc, false>
    {
      static bool
      _S_do_it(const _Alloc& __one, const _Alloc& __two)
      { return __one != __two; }
    };


  template<typename _Tp, bool
    = __or_<is_copy_constructible<typename _Tp::value_type>,
            is_nothrow_move_constructible<typename _Tp::value_type>>::value>
    struct __shrink_to_fit_aux
    { static bool _S_do_it(_Tp&) noexcept { return false; } };

  template<typename _Tp>
    struct __shrink_to_fit_aux<_Tp, true>
    {
      static bool
      _S_do_it(_Tp& __c) noexcept
      {
 try
   {
     _Tp(__make_move_if_noexcept_iterator(__c.begin()),
  __make_move_if_noexcept_iterator(__c.end()),
  __c.get_allocator()).swap(__c);
     return true;
   }
 catch(...)
   { return false; }
      }
    };



}
# 62 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/list" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/range_access.h" 1 3
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/range_access.h" 3
       
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/range_access.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{







  template<class _Container>
    inline auto
    begin(_Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<class _Container>
    inline auto
    begin(const _Container& __cont) -> decltype(__cont.begin())
    { return __cont.begin(); }






  template<class _Container>
    inline auto
    end(_Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }






  template<class _Container>
    inline auto
    end(const _Container& __cont) -> decltype(__cont.end())
    { return __cont.end(); }





  template<class _Tp, size_t _Nm>
    inline _Tp*
    begin(_Tp (&__arr)[_Nm])
    { return __arr; }






  template<class _Tp, size_t _Nm>
    inline _Tp*
    end(_Tp (&__arr)[_Nm])
    { return __arr + _Nm; }


}
# 63 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/list" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 1 3
# 61 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/initializer_list" 1 3
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/initializer_list" 3
       
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/initializer_list" 3





#pragma GCC visibility push(default)



namespace std
{

  template<class _E>
    class initializer_list
    {
    public:
      typedef _E value_type;
      typedef const _E& reference;
      typedef const _E& const_reference;
      typedef size_t size_type;
      typedef const _E* iterator;
      typedef const _E* const_iterator;

    private:
      iterator _M_array;
      size_type _M_len;


      constexpr initializer_list(const_iterator __a, size_type __l)
      : _M_array(__a), _M_len(__l) { }

    public:
      constexpr initializer_list() noexcept
      : _M_array(0), _M_len(0) { }


      constexpr size_type
      size() const noexcept { return _M_len; }


      constexpr const_iterator
      begin() const noexcept { return _M_array; }


      constexpr const_iterator
      end() const noexcept { return begin() + size(); }
    };






  template<class _Tp>
    constexpr const _Tp*
    begin(initializer_list<_Tp> __ils) noexcept
    { return __ils.begin(); }






  template<class _Tp>
    constexpr const _Tp*
    end(initializer_list<_Tp> __ils) noexcept
    { return __ils.end(); }
}

#pragma GCC visibility pop
# 62 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 2 3


namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace __detail
  {
 
# 77 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
    struct _List_node_base
    {
      _List_node_base* _M_next;
      _List_node_base* _M_prev;

      static void
      swap(_List_node_base& __x, _List_node_base& __y) noexcept;

      void
      _M_transfer(_List_node_base* const __first,
    _List_node_base* const __last) noexcept;

      void
      _M_reverse() noexcept;

      void
      _M_hook(_List_node_base* const __position) noexcept;

      void
      _M_unhook() noexcept;
    };

 
  }




  template<typename _Tp>
    struct _List_node : public __detail::_List_node_base
    {

      _Tp _M_data;


      template<typename... _Args>
        _List_node(_Args&&... __args)
 : __detail::_List_node_base(), _M_data(std::forward<_Args>(__args)...)
        { }

    };






  template<typename _Tp>
    struct _List_iterator
    {
      typedef _List_iterator<_Tp> _Self;
      typedef _List_node<_Tp> _Node;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef _Tp* pointer;
      typedef _Tp& reference;

      _List_iterator() noexcept
      : _M_node() { }

      explicit
      _List_iterator(__detail::_List_node_base* __x) noexcept
      : _M_node(__x) { }

      _Self
      _M_const_cast() const noexcept
      { return *this; }


      reference
      operator*() const noexcept
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const noexcept
      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }

      _Self&
      operator++() noexcept
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }


      __detail::_List_node_base* _M_node;
    };






  template<typename _Tp>
    struct _List_const_iterator
    {
      typedef _List_const_iterator<_Tp> _Self;
      typedef const _List_node<_Tp> _Node;
      typedef _List_iterator<_Tp> iterator;

      typedef ptrdiff_t difference_type;
      typedef std::bidirectional_iterator_tag iterator_category;
      typedef _Tp value_type;
      typedef const _Tp* pointer;
      typedef const _Tp& reference;

      _List_const_iterator() noexcept
      : _M_node() { }

      explicit
      _List_const_iterator(const __detail::_List_node_base* __x)
      noexcept
      : _M_node(__x) { }

      _List_const_iterator(const iterator& __x) noexcept
      : _M_node(__x._M_node) { }

      iterator
      _M_const_cast() const noexcept
      { return iterator(const_cast<__detail::_List_node_base*>(_M_node)); }



      reference
      operator*() const noexcept
      { return static_cast<_Node*>(_M_node)->_M_data; }

      pointer
      operator->() const noexcept
      { return std::__addressof(static_cast<_Node*>(_M_node)->_M_data); }

      _Self&
      operator++() noexcept
      {
 _M_node = _M_node->_M_next;
 return *this;
      }

      _Self
      operator++(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_next;
 return __tmp;
      }

      _Self&
      operator--() noexcept
      {
 _M_node = _M_node->_M_prev;
 return *this;
      }

      _Self
      operator--(int) noexcept
      {
 _Self __tmp = *this;
 _M_node = _M_node->_M_prev;
 return __tmp;
      }

      bool
      operator==(const _Self& __x) const noexcept
      { return _M_node == __x._M_node; }

      bool
      operator!=(const _Self& __x) const noexcept
      { return _M_node != __x._M_node; }


      const __detail::_List_node_base* _M_node;
    };

  template<typename _Val>
    inline bool
    operator==(const _List_iterator<_Val>& __x,
        const _List_const_iterator<_Val>& __y) noexcept
    { return __x._M_node == __y._M_node; }

  template<typename _Val>
    inline bool
    operator!=(const _List_iterator<_Val>& __x,
               const _List_const_iterator<_Val>& __y) noexcept
    { return __x._M_node != __y._M_node; }



  template<typename _Tp, typename _Alloc>
    class _List_base
    {
    protected:
# 314 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      typedef typename _Alloc::template rebind<_List_node<_Tp> >::other
        _Node_alloc_type;

      typedef typename _Alloc::template rebind<_Tp>::other _Tp_alloc_type;

      struct _List_impl
      : public _Node_alloc_type
      {
 __detail::_List_node_base _M_node;

 _List_impl()
 : _Node_alloc_type(), _M_node()
 { }

 _List_impl(const _Node_alloc_type& __a) noexcept
 : _Node_alloc_type(__a), _M_node()
 { }


 _List_impl(_Node_alloc_type&& __a) noexcept
 : _Node_alloc_type(std::move(__a)), _M_node()
 { }

      };

      _List_impl _M_impl;

      _List_node<_Tp>*
      _M_get_node()
      { return _M_impl._Node_alloc_type::allocate(1); }

      void
      _M_put_node(_List_node<_Tp>* __p) noexcept
      { _M_impl._Node_alloc_type::deallocate(__p, 1); }

  public:
      typedef _Alloc allocator_type;

      _Node_alloc_type&
      _M_get_Node_allocator() noexcept
      { return *static_cast<_Node_alloc_type*>(&_M_impl); }

      const _Node_alloc_type&
      _M_get_Node_allocator() const noexcept
      { return *static_cast<const _Node_alloc_type*>(&_M_impl); }

      _Tp_alloc_type
      _M_get_Tp_allocator() const noexcept
      { return _Tp_alloc_type(_M_get_Node_allocator()); }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(_M_get_Node_allocator()); }

      _List_base()
      : _M_impl()
      { _M_init(); }

      _List_base(const _Node_alloc_type& __a) noexcept
      : _M_impl(__a)
      { _M_init(); }


      _List_base(_List_base&& __x) noexcept
      : _M_impl(std::move(__x._M_get_Node_allocator()))
      {
 _M_init();
 __detail::_List_node_base::swap(_M_impl._M_node, __x._M_impl._M_node);
      }



      ~_List_base() noexcept
      { _M_clear(); }

      void
      _M_clear() noexcept;

      void
      _M_init() noexcept
      {
        this->_M_impl._M_node._M_next = &this->_M_impl._M_node;
        this->_M_impl._M_node._M_prev = &this->_M_impl._M_node;
      }
    };
# 446 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc = std::allocator<_Tp> >
    class list : protected _List_base<_Tp, _Alloc>
    {

      typedef typename _Alloc::value_type _Alloc_value_type;
     
     

      typedef _List_base<_Tp, _Alloc> _Base;
      typedef typename _Base::_Tp_alloc_type _Tp_alloc_type;
      typedef typename _Base::_Node_alloc_type _Node_alloc_type;

    public:
      typedef _Tp value_type;
      typedef typename _Tp_alloc_type::pointer pointer;
      typedef typename _Tp_alloc_type::const_pointer const_pointer;
      typedef typename _Tp_alloc_type::reference reference;
      typedef typename _Tp_alloc_type::const_reference const_reference;
      typedef _List_iterator<_Tp> iterator;
      typedef _List_const_iterator<_Tp> const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef size_t size_type;
      typedef ptrdiff_t difference_type;
      typedef _Alloc allocator_type;

    protected:


      typedef _List_node<_Tp> _Node;

      using _Base::_M_impl;
      using _Base::_M_put_node;
      using _Base::_M_get_node;
      using _Base::_M_get_Tp_allocator;
      using _Base::_M_get_Node_allocator;
# 507 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      template<typename... _Args>
        _Node*
        _M_create_node(_Args&&... __args)
 {
   _Node* __p = this->_M_get_node();
   try
     {
       _M_get_Node_allocator().construct(__p,
      std::forward<_Args>(__args)...);
     }
   catch(...)
     {
       _M_put_node(__p);
       throw;
     }
   return __p;
 }


    public:






      list()

      noexcept(is_nothrow_default_constructible<_Node_alloc_type>::value)

      : _Base() { }





      explicit
      list(const allocator_type& __a) noexcept
      : _Base(_Node_alloc_type(__a)) { }
# 555 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      explicit
      list(size_type __n)
      : _Base()
      { _M_default_initialize(__n); }
# 568 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      list(size_type __n, const value_type& __value,
    const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_fill_initialize(__n, __value); }
# 595 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      list(const list& __x)
      : _Base(__x._M_get_Node_allocator())
      { _M_initialize_dispatch(__x.begin(), __x.end(), __false_type()); }
# 607 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      list(list&& __x) noexcept
      : _Base(std::move(__x)) { }
# 618 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      list(initializer_list<value_type> __l,
           const allocator_type& __a = allocator_type())
      : _Base(_Node_alloc_type(__a))
      { _M_initialize_dispatch(__l.begin(), __l.end(), __false_type()); }
# 635 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        list(_InputIterator __first, _InputIterator __last,
      const allocator_type& __a = allocator_type())
 : _Base(_Node_alloc_type(__a))
        { _M_initialize_dispatch(__first, __last, __false_type()); }
# 668 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      list&
      operator=(const list& __x);
# 679 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      list&
      operator=(list&& __x)
      {


 this->clear();
 this->swap(__x);
 return *this;
      }
# 696 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      list&
      operator=(initializer_list<value_type> __l)
      {
 this->assign(__l.begin(), __l.end());
 return *this;
      }
# 714 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      assign(size_type __n, const value_type& __val)
      { _M_fill_assign(__n, __val); }
# 731 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
        void
        assign(_InputIterator __first, _InputIterator __last)
        { _M_assign_dispatch(__first, __last, __false_type()); }
# 755 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      assign(initializer_list<value_type> __l)
      { this->assign(__l.begin(), __l.end()); }



      allocator_type
      get_allocator() const noexcept
      { return _Base::get_allocator(); }






      iterator
      begin() noexcept
      { return iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      begin() const noexcept
      { return const_iterator(this->_M_impl._M_node._M_next); }






      iterator
      end() noexcept
      { return iterator(&this->_M_impl._M_node); }






      const_iterator
      end() const noexcept
      { return const_iterator(&this->_M_impl._M_node); }






      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }






      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }







      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_impl._M_node._M_next); }






      const_iterator
      cend() const noexcept
      { return const_iterator(&this->_M_impl._M_node); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }







      bool
      empty() const noexcept
      { return this->_M_impl._M_node._M_next == &this->_M_impl._M_node; }


      size_type
      size() const noexcept
      { return std::distance(begin(), end()); }


      size_type
      max_size() const noexcept
      { return _M_get_Node_allocator().max_size(); }
# 904 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      resize(size_type __new_size);
# 917 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      resize(size_type __new_size, const value_type& __x);
# 939 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      reference
      front() noexcept
      { return *begin(); }





      const_reference
      front() const noexcept
      { return *begin(); }





      reference
      back() noexcept
      {
 iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }





      const_reference
      back() const noexcept
      {
 const_iterator __tmp = end();
 --__tmp;
 return *__tmp;
      }
# 986 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      push_front(const value_type& __x)
      { this->_M_insert(begin(), __x); }


      void
      push_front(value_type&& __x)
      { this->_M_insert(begin(), std::move(__x)); }

      template<typename... _Args>
        void
        emplace_front(_Args&&... __args)
        { this->_M_insert(begin(), std::forward<_Args>(__args)...); }
# 1013 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      pop_front() noexcept
      { this->_M_erase(begin()); }
# 1027 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      push_back(const value_type& __x)
      { this->_M_insert(end(), __x); }


      void
      push_back(value_type&& __x)
      { this->_M_insert(end(), std::move(__x)); }

      template<typename... _Args>
        void
        emplace_back(_Args&&... __args)
        { this->_M_insert(end(), std::forward<_Args>(__args)...); }
# 1053 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      pop_back() noexcept
      { this->_M_erase(iterator(this->_M_impl._M_node._M_prev)); }
# 1070 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      template<typename... _Args>
        iterator
        emplace(const_iterator __position, _Args&&... __args);
# 1085 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      iterator
      insert(const_iterator __position, const value_type& __x);
# 1115 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      iterator
      insert(const_iterator __position, value_type&& __x)
      { return emplace(__position, std::move(__x)); }
# 1134 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      iterator
      insert(const_iterator __p, initializer_list<value_type> __l)
      { return this->insert(__p, __l.begin(), __l.end()); }
# 1154 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      iterator
      insert(const_iterator __position, size_type __n, const value_type& __x);
# 1193 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      template<typename _InputIterator,
        typename = std::_RequireInputIter<_InputIterator>>
 iterator
 insert(const_iterator __position, _InputIterator __first,
        _InputIterator __last);
# 1237 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      iterator

      erase(const_iterator __position) noexcept;
# 1262 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      iterator

      erase(const_iterator __first, const_iterator __last) noexcept



      {
 while (__first != __last)
   __first = erase(__first);
 return __last._M_const_cast();
      }
# 1283 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      swap(list& __x)
      {
 __detail::_List_node_base::swap(this->_M_impl._M_node,
     __x._M_impl._M_node);



 std::__alloc_swap<typename _Base::_Node_alloc_type>::
   _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator());
      }







      void
      clear() noexcept
      {
        _Base::_M_clear();
        _Base::_M_init();
      }
# 1320 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void

      splice(const_iterator __position, list&& __x) noexcept



      {
 if (!__x.empty())
   {
     _M_check_equal_allocators(__x);

     this->_M_transfer(__position._M_const_cast(),
         __x.begin(), __x.end());
   }
      }


      void
      splice(const_iterator __position, list& __x) noexcept
      { splice(__position, std::move(__x)); }
# 1353 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      splice(const_iterator __position, list&& __x, const_iterator __i) noexcept
# 1368 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      {
 iterator __j = __i._M_const_cast();
 ++__j;
 if (__position == __i || __position == __j)
   return;

 if (this != &__x)
   _M_check_equal_allocators(__x);

 this->_M_transfer(__position._M_const_cast(),
     __i._M_const_cast(), __j);
      }
# 1392 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      splice(const_iterator __position, list& __x, const_iterator __i) noexcept
      { splice(__position, std::move(__x), __i); }
# 1411 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      splice(const_iterator __position, list&& __x, const_iterator __first,
      const_iterator __last) noexcept
# 1431 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      {
 if (__first != __last)
   {
     if (this != &__x)
       _M_check_equal_allocators(__x);

     this->_M_transfer(__position._M_const_cast(),
         __first._M_const_cast(),
         __last._M_const_cast());
   }
      }
# 1457 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      splice(const_iterator __position, list& __x, const_iterator __first,
      const_iterator __last) noexcept
      { splice(__position, std::move(__x), __first, __last); }
# 1474 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      remove(const _Tp& __value);
# 1488 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      template<typename _Predicate>
        void
        remove_if(_Predicate);
# 1502 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      unique();
# 1517 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      template<typename _BinaryPredicate>
        void
        unique(_BinaryPredicate);
# 1531 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      merge(list&& __x);

      void
      merge(list& __x)
      { merge(std::move(__x)); }
# 1556 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      template<typename _StrictWeakOrdering>
        void
        merge(list&& __x, _StrictWeakOrdering __comp);

      template<typename _StrictWeakOrdering>
        void
        merge(list& __x, _StrictWeakOrdering __comp)
        { merge(std::move(__x), __comp); }
# 1575 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      void
      reverse() noexcept
      { this->_M_impl._M_node._M_reverse(); }







      void
      sort();







      template<typename _StrictWeakOrdering>
        void
        sort(_StrictWeakOrdering);

    protected:






      template<typename _Integer>
        void
        _M_initialize_dispatch(_Integer __n, _Integer __x, __true_type)
        { _M_fill_initialize(static_cast<size_type>(__n), __x); }


      template<typename _InputIterator>
        void
        _M_initialize_dispatch(_InputIterator __first, _InputIterator __last,
          __false_type)
        {
   for (; __first != __last; ++__first)

     emplace_back(*__first);



 }



      void
      _M_fill_initialize(size_type __n, const value_type& __x)
      {
 for (; __n; --__n)
   push_back(__x);
      }



      void
      _M_default_initialize(size_type __n)
      {
 for (; __n; --__n)
   emplace_back();
      }


      void
      _M_default_append(size_type __n);
# 1653 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
      template<typename _Integer>
        void
        _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)
        { _M_fill_assign(__n, __val); }


      template<typename _InputIterator>
        void
        _M_assign_dispatch(_InputIterator __first, _InputIterator __last,
      __false_type);



      void
      _M_fill_assign(size_type __n, const value_type& __val);



      void
      _M_transfer(iterator __position, iterator __first, iterator __last)
      { __position._M_node->_M_transfer(__first._M_node, __last._M_node); }
# 1684 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
     template<typename... _Args>
       void
       _M_insert(iterator __position, _Args&&... __args)
       {
  _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
  __tmp->_M_hook(__position._M_node);
       }



      void
      _M_erase(iterator __position) noexcept
      {
        __position._M_node->_M_unhook();
        _Node* __n = static_cast<_Node*>(__position._M_node);

        _M_get_Node_allocator().destroy(__n);



        _M_put_node(__n);
      }


      void
      _M_check_equal_allocators(list& __x) noexcept
      {
 if (std::__alloc_neq<typename _Base::_Node_alloc_type>::
     _S_do_it(_M_get_Node_allocator(), __x._M_get_Node_allocator()))
   __builtin_abort();
      }
    };
# 1727 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    {
      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;
      const_iterator __end1 = __x.end();
      const_iterator __end2 = __y.end();

      const_iterator __i1 = __x.begin();
      const_iterator __i2 = __y.begin();
      while (__i1 != __end1 && __i2 != __end2 && *__i1 == *__i2)
 {
   ++__i1;
   ++__i2;
 }
      return __i1 == __end1 && __i2 == __end2;
    }
# 1756 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_list.h" 3
  template<typename _Tp, typename _Alloc>
    inline bool
    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return std::lexicographical_compare(__x.begin(), __x.end(),
       __y.begin(), __y.end()); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x == __y); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return __y < __x; }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__y < __x); }


  template<typename _Tp, typename _Alloc>
    inline bool
    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)
    { return !(__x < __y); }


  template<typename _Tp, typename _Alloc>
    inline void
    swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)
    { __x.swap(__y); }


}
# 64 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/list" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/list.tcc" 1 3
# 59 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/list.tcc" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Alloc>
    void
    _List_base<_Tp, _Alloc>::
    _M_clear() noexcept
    {
      typedef _List_node<_Tp> _Node;
      _Node* __cur = static_cast<_Node*>(_M_impl._M_node._M_next);
      while (__cur != &_M_impl._M_node)
 {
   _Node* __tmp = __cur;
   __cur = static_cast<_Node*>(__cur->_M_next);

   _M_get_Node_allocator().destroy(__tmp);



   _M_put_node(__tmp);
 }
    }


  template<typename _Tp, typename _Alloc>
    template<typename... _Args>
      typename list<_Tp, _Alloc>::iterator
      list<_Tp, _Alloc>::
      emplace(const_iterator __position, _Args&&... __args)
      {
 _Node* __tmp = _M_create_node(std::forward<_Args>(__args)...);
 __tmp->_M_hook(__position._M_const_cast()._M_node);
 return iterator(__tmp);
      }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::

    insert(const_iterator __position, const value_type& __x)



    {
      _Node* __tmp = _M_create_node(__x);
      __tmp->_M_hook(__position._M_const_cast()._M_node);
      return iterator(__tmp);
    }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::
    insert(const_iterator __position, size_type __n, const value_type& __x)
    {
      if (__n)
 {
   list __tmp(__n, __x, get_allocator());
   iterator __it = __tmp.begin();
   splice(__position, __tmp);
   return __it;
 }
      return __position._M_const_cast();
    }

  template<typename _Tp, typename _Alloc>
    template<typename _InputIterator, typename>
      typename list<_Tp, _Alloc>::iterator
      list<_Tp, _Alloc>::
      insert(const_iterator __position, _InputIterator __first,
      _InputIterator __last)
      {
 list __tmp(__first, __last, get_allocator());
 if (!__tmp.empty())
   {
     iterator __it = __tmp.begin();
     splice(__position, __tmp);
     return __it;
   }
 return __position._M_const_cast();
      }


  template<typename _Tp, typename _Alloc>
    typename list<_Tp, _Alloc>::iterator
    list<_Tp, _Alloc>::

    erase(const_iterator __position) noexcept



    {
      iterator __ret = iterator(__position._M_node->_M_next);
      _M_erase(__position._M_const_cast());
      return __ret;
    }


  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_default_append(size_type __n)
    {
      size_type __i = 0;
      try
 {
   for (; __i < __n; ++__i)
     emplace_back();
 }
      catch(...)
 {
   for (; __i; --__i)
     pop_back();
   throw;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
 _M_default_append(__new_size - __len);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    resize(size_type __new_size, const value_type& __x)
    {
      iterator __i = begin();
      size_type __len = 0;
      for (; __i != end() && __len < __new_size; ++__i, ++__len)
        ;
      if (__len == __new_size)
        erase(__i, end());
      else
        insert(end(), __new_size - __len, __x);
    }
# 224 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/list.tcc" 3
  template<typename _Tp, typename _Alloc>
    list<_Tp, _Alloc>&
    list<_Tp, _Alloc>::
    operator=(const list& __x)
    {
      if (this != &__x)
 {
   iterator __first1 = begin();
   iterator __last1 = end();
   const_iterator __first2 = __x.begin();
   const_iterator __last2 = __x.end();
   for (; __first1 != __last1 && __first2 != __last2;
        ++__first1, ++__first2)
     *__first1 = *__first2;
   if (__first2 == __last2)
     erase(__first1, __last1);
   else
     insert(__last1, __first2, __last2);
 }
      return *this;
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    _M_fill_assign(size_type __n, const value_type& __val)
    {
      iterator __i = begin();
      for (; __i != end() && __n > 0; ++__i, --__n)
        *__i = __val;
      if (__n > 0)
        insert(end(), __n, __val);
      else
        erase(__i, end());
    }

  template<typename _Tp, typename _Alloc>
    template <typename _InputIterator>
      void
      list<_Tp, _Alloc>::
      _M_assign_dispatch(_InputIterator __first2, _InputIterator __last2,
    __false_type)
      {
        iterator __first1 = begin();
        iterator __last1 = end();
        for (; __first1 != __last1 && __first2 != __last2;
      ++__first1, ++__first2)
          *__first1 = *__first2;
        if (__first2 == __last2)
          erase(__first1, __last1);
        else
          insert(__last1, __first2, __last2);
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    remove(const value_type& __value)
    {
      iterator __first = begin();
      iterator __last = end();
      iterator __extra = __last;
      while (__first != __last)
 {
   iterator __next = __first;
   ++__next;
   if (*__first == __value)
     {



       if (std::__addressof(*__first) != std::__addressof(__value))
  _M_erase(__first);
       else
  __extra = __first;
     }
   __first = __next;
 }
      if (__extra != __last)
 _M_erase(__extra);
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    unique()
    {
      iterator __first = begin();
      iterator __last = end();
      if (__first == __last)
 return;
      iterator __next = __first;
      while (++__next != __last)
 {
   if (*__first == *__next)
     _M_erase(__next);
   else
     __first = __next;
   __next = __first;
 }
    }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::

    merge(list&& __x)



    {


      if (this != &__x)
 {
   _M_check_equal_allocators(__x);

   iterator __first1 = begin();
   iterator __last1 = end();
   iterator __first2 = __x.begin();
   iterator __last2 = __x.end();
   while (__first1 != __last1 && __first2 != __last2)
     if (*__first2 < *__first1)
       {
  iterator __next = __first2;
  _M_transfer(__first1, __first2, ++__next);
  __first2 = __next;
       }
     else
       ++__first1;
   if (__first2 != __last2)
     _M_transfer(__last1, __first2, __last2);
 }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::

      merge(list&& __x, _StrictWeakOrdering __comp)



      {


 if (this != &__x)
   {
     _M_check_equal_allocators(__x);

     iterator __first1 = begin();
     iterator __last1 = end();
     iterator __first2 = __x.begin();
     iterator __last2 = __x.end();
     while (__first1 != __last1 && __first2 != __last2)
       if (__comp(*__first2, *__first1))
  {
    iterator __next = __first2;
    _M_transfer(__first1, __first2, ++__next);
    __first2 = __next;
  }
       else
  ++__first1;
     if (__first2 != __last2)
       _M_transfer(__last1, __first2, __last2);
   }
      }

  template<typename _Tp, typename _Alloc>
    void
    list<_Tp, _Alloc>::
    sort()
    {

      if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
   && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
      {
        list __carry;
        list __tmp[64];
        list * __fill = &__tmp[0];
        list * __counter;

        do
   {
     __carry.splice(__carry.begin(), *this, begin());

     for(__counter = &__tmp[0];
  __counter != __fill && !__counter->empty();
  ++__counter)
       {
  __counter->merge(__carry);
  __carry.swap(*__counter);
       }
     __carry.swap(*__counter);
     if (__counter == __fill)
       ++__fill;
   }
 while ( !empty() );

        for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
          __counter->merge(*(__counter - 1));
        swap( *(__fill - 1) );
      }
    }

  template<typename _Tp, typename _Alloc>
    template <typename _Predicate>
      void
      list<_Tp, _Alloc>::
      remove_if(_Predicate __pred)
      {
        iterator __first = begin();
        iterator __last = end();
        while (__first != __last)
   {
     iterator __next = __first;
     ++__next;
     if (__pred(*__first))
       _M_erase(__first);
     __first = __next;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _BinaryPredicate>
      void
      list<_Tp, _Alloc>::
      unique(_BinaryPredicate __binary_pred)
      {
        iterator __first = begin();
        iterator __last = end();
        if (__first == __last)
   return;
        iterator __next = __first;
        while (++__next != __last)
   {
     if (__binary_pred(*__first, *__next))
       _M_erase(__next);
     else
       __first = __next;
     __next = __first;
   }
      }

  template<typename _Tp, typename _Alloc>
    template <typename _StrictWeakOrdering>
      void
      list<_Tp, _Alloc>::
      sort(_StrictWeakOrdering __comp)
      {

 if (this->_M_impl._M_node._M_next != &this->_M_impl._M_node
     && this->_M_impl._M_node._M_next->_M_next != &this->_M_impl._M_node)
   {
     list __carry;
     list __tmp[64];
     list * __fill = &__tmp[0];
     list * __counter;

     do
       {
  __carry.splice(__carry.begin(), *this, begin());

  for(__counter = &__tmp[0];
      __counter != __fill && !__counter->empty();
      ++__counter)
    {
      __counter->merge(__carry, __comp);
      __carry.swap(*__counter);
    }
  __carry.swap(*__counter);
  if (__counter == __fill)
    ++__fill;
       }
     while ( !empty() );

     for (__counter = &__tmp[1]; __counter != __fill; ++__counter)
       __counter->merge(*(__counter - 1), __comp);
     swap(*(__fill - 1));
   }
      }


}
# 65 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/list" 2 3
# 9 "../Quadris/Engine.h" 2
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 1
# 46 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional"
       
# 47 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_function.h" 1 3
# 63 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_function.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 104 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    struct unary_function
    {

      typedef _Arg argument_type;


      typedef _Result result_type;
    };




  template<typename _Arg1, typename _Arg2, typename _Result>
    struct binary_function
    {

      typedef _Arg1 first_argument_type;


      typedef _Arg2 second_argument_type;


      typedef _Result result_type;
    };
# 166 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_function.h" 3
  template<typename _Tp>
    struct plus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x + __y; }
    };


  template<typename _Tp>
    struct minus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x - __y; }
    };


  template<typename _Tp>
    struct multiplies : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x * __y; }
    };


  template<typename _Tp>
    struct divides : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x / __y; }
    };


  template<typename _Tp>
    struct modulus : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x % __y; }
    };


  template<typename _Tp>
    struct negate : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return -__x; }
    };
# 335 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_function.h" 3
  template<typename _Tp>
    struct equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x == __y; }
    };


  template<typename _Tp>
    struct not_equal_to : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x != __y; }
    };


  template<typename _Tp>
    struct greater : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x > __y; }
    };


  template<typename _Tp>
    struct less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x < __y; }
    };


  template<typename _Tp>
    struct greater_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x >= __y; }
    };


  template<typename _Tp>
    struct less_equal : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x <= __y; }
    };
# 496 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_function.h" 3
  template<typename _Tp>
    struct logical_and : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x && __y; }
    };


  template<typename _Tp>
    struct logical_or : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x || __y; }
    };


  template<typename _Tp>
    struct logical_not : public unary_function<_Tp, bool>
    {
      bool
      operator()(const _Tp& __x) const
      { return !__x; }
    };
# 583 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_function.h" 3
  template<typename _Tp>
    struct bit_and : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x & __y; }
    };

  template<typename _Tp>
    struct bit_or : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x | __y; }
    };

  template<typename _Tp>
    struct bit_xor : public binary_function<_Tp, _Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x, const _Tp& __y) const
      { return __x ^ __y; }
    };

  template<typename _Tp>
    struct bit_not : public unary_function<_Tp, _Tp>
    {
      _Tp
      operator()(const _Tp& __x) const
      { return ~__x; }
    };
# 699 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_function.h" 3
  template<typename _Predicate>
    class unary_negate
    : public unary_function<typename _Predicate::argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      unary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::argument_type& __x) const
      { return !_M_pred(__x); }
    };


  template<typename _Predicate>
    inline unary_negate<_Predicate>
    not1(const _Predicate& __pred)
    { return unary_negate<_Predicate>(__pred); }


  template<typename _Predicate>
    class binary_negate
    : public binary_function<typename _Predicate::first_argument_type,
        typename _Predicate::second_argument_type, bool>
    {
    protected:
      _Predicate _M_pred;

    public:
      explicit
      binary_negate(const _Predicate& __x) : _M_pred(__x) { }

      bool
      operator()(const typename _Predicate::first_argument_type& __x,
   const typename _Predicate::second_argument_type& __y) const
      { return !_M_pred(__x, __y); }
    };


  template<typename _Predicate>
    inline binary_negate<_Predicate>
    not2(const _Predicate& __pred)
    { return binary_negate<_Predicate>(__pred); }
# 770 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_function.h" 3
  template<typename _Arg, typename _Result>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg);

    public:
      pointer_to_unary_function() { }

      explicit
      pointer_to_unary_function(_Result (*__x)(_Arg))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg __x) const
      { return _M_ptr(__x); }
    };


  template<typename _Arg, typename _Result>
    inline pointer_to_unary_function<_Arg, _Result>
    ptr_fun(_Result (*__x)(_Arg))
    { return pointer_to_unary_function<_Arg, _Result>(__x); }


  template<typename _Arg1, typename _Arg2, typename _Result>
    class pointer_to_binary_function
    : public binary_function<_Arg1, _Arg2, _Result>
    {
    protected:
      _Result (*_M_ptr)(_Arg1, _Arg2);

    public:
      pointer_to_binary_function() { }

      explicit
      pointer_to_binary_function(_Result (*__x)(_Arg1, _Arg2))
      : _M_ptr(__x) { }

      _Result
      operator()(_Arg1 __x, _Arg2 __y) const
      { return _M_ptr(__x, __y); }
    };


  template<typename _Arg1, typename _Arg2, typename _Result>
    inline pointer_to_binary_function<_Arg1, _Arg2, _Result>
    ptr_fun(_Result (*__x)(_Arg1, _Arg2))
    { return pointer_to_binary_function<_Arg1, _Arg2, _Result>(__x); }


  template<typename _Tp>
    struct _Identity
    : public unary_function<_Tp,_Tp>
    {
      _Tp&
      operator()(_Tp& __x) const
      { return __x; }

      const _Tp&
      operator()(const _Tp& __x) const
      { return __x; }
    };

  template<typename _Pair>
    struct _Select1st
    : public unary_function<_Pair, typename _Pair::first_type>
    {
      typename _Pair::first_type&
      operator()(_Pair& __x) const
      { return __x.first; }

      const typename _Pair::first_type&
      operator()(const _Pair& __x) const
      { return __x.first; }


      template<typename _Pair2>
        typename _Pair2::first_type&
        operator()(_Pair2& __x) const
        { return __x.first; }

      template<typename _Pair2>
        const typename _Pair2::first_type&
        operator()(const _Pair2& __x) const
        { return __x.first; }

    };

  template<typename _Pair>
    struct _Select2nd
    : public unary_function<_Pair, typename _Pair::second_type>
    {
      typename _Pair::second_type&
      operator()(_Pair& __x) const
      { return __x.second; }

      const typename _Pair::second_type&
      operator()(const _Pair& __x) const
      { return __x.second; }
    };
# 890 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_function.h" 3
  template<typename _Ret, typename _Tp>
    class mem_fun_t : public unary_function<_Tp*, _Ret>
    {
    public:
      explicit
      mem_fun_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
    };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_t : public unary_function<const _Tp*, _Ret>
    {
    public:
      explicit
      const_mem_fun_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p) const
      { return (__p->*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp>
    class mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      mem_fun_ref_t(_Ret (_Tp::*__pf)())
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)();
  };



  template<typename _Ret, typename _Tp>
    class const_mem_fun_ref_t : public unary_function<_Tp, _Ret>
    {
    public:
      explicit
      const_mem_fun_ref_t(_Ret (_Tp::*__pf)() const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r) const
      { return (__r.*_M_f)(); }

    private:
      _Ret (_Tp::*_M_f)() const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_t : public binary_function<_Tp*, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_t : public binary_function<const _Tp*, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp* __p, _Arg __x) const
      { return (__p->*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg))
      : _M_f(__pf) { }

      _Ret
      operator()(_Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg);
    };



  template<typename _Ret, typename _Tp, typename _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Tp, _Arg, _Ret>
    {
    public:
      explicit
      const_mem_fun1_ref_t(_Ret (_Tp::*__pf)(_Arg) const)
      : _M_f(__pf) { }

      _Ret
      operator()(const _Tp& __r, _Arg __x) const
      { return (__r.*_M_f)(__x); }

    private:
      _Ret (_Tp::*_M_f)(_Arg) const;
    };



  template<typename _Ret, typename _Tp>
    inline mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)())
    { return mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_t<_Ret, _Tp>
    mem_fun(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)())
    { return mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp>
    inline const_mem_fun_ref_t<_Ret, _Tp>
    mem_fun_ref(_Ret (_Tp::*__f)() const)
    { return const_mem_fun_ref_t<_Ret, _Tp>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_t<_Ret, _Tp, _Arg>
    mem_fun(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg))
    { return mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }

  template<typename _Ret, typename _Tp, typename _Arg>
    inline const_mem_fun1_ref_t<_Ret, _Tp, _Arg>
    mem_fun_ref(_Ret (_Tp::*__f)(_Arg) const)
    { return const_mem_fun1_ref_t<_Ret, _Tp, _Arg>(__f); }




}


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/binders.h" 1 3
# 59 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/binders.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 103 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/binders.h" 3
  template<typename _Operation>
    class binder1st
    : public unary_function<typename _Operation::second_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::first_argument_type value;

    public:
      binder1st(const _Operation& __x,
  const typename _Operation::first_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }



      typename _Operation::result_type
      operator()(typename _Operation::second_argument_type& __x) const
      { return op(value, __x); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder1st<_Operation>
    bind1st(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::first_argument_type _Arg1_type;
      return binder1st<_Operation>(__fn, _Arg1_type(__x));
    }


  template<typename _Operation>
    class binder2nd
    : public unary_function<typename _Operation::first_argument_type,
       typename _Operation::result_type>
    {
    protected:
      _Operation op;
      typename _Operation::second_argument_type value;

    public:
      binder2nd(const _Operation& __x,
  const typename _Operation::second_argument_type& __y)
      : op(__x), value(__y) { }

      typename _Operation::result_type
      operator()(const typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }



      typename _Operation::result_type
      operator()(typename _Operation::first_argument_type& __x) const
      { return op(__x, value); }
    } __attribute__ ((__deprecated__));


  template<typename _Operation, typename _Tp>
    inline binder2nd<_Operation>
    bind2nd(const _Operation& __fn, const _Tp& __x)
    {
      typedef typename _Operation::second_argument_type _Arg2_type;
      return binder2nd<_Operation>(__fn, _Arg2_type(__x));
    }



}
# 1081 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_function.h" 2 3
# 50 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 2 3



# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/typeinfo" 1 3
# 32 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/typeinfo" 3
       
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/typeinfo" 3



# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/hash_bytes.h" 1 3
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/hash_bytes.h" 3
       
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/hash_bytes.h" 3



namespace std
{







  size_t
  _Hash_bytes(const void* __ptr, size_t __len, size_t __seed);





  size_t
  _Fnv_hash_bytes(const void* __ptr, size_t __len, size_t __seed);


}
# 37 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/typeinfo" 2 3


#pragma GCC visibility push(default)

extern "C++" {

namespace __cxxabiv1
{
  class __class_type_info;
}
# 80 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/typeinfo" 3
namespace std
{






  class type_info
  {
  public:




    virtual ~type_info();



    const char* name() const noexcept
    { return __name[0] == '*' ? __name + 1 : __name; }





    bool before(const type_info& __arg) const noexcept;
    bool operator==(const type_info& __arg) const noexcept;
# 136 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/typeinfo" 3
    bool operator!=(const type_info& __arg) const noexcept
    { return !operator==(__arg); }


    size_t hash_code() const noexcept
    {

      return _Hash_bytes(name(), __builtin_strlen(name()),
    static_cast<size_t>(0xc70f6907UL));



    }



    virtual bool __is_pointer_p() const;


    virtual bool __is_function_p() const;







    virtual bool __do_catch(const type_info *__thr_type, void **__thr_obj,
       unsigned __outer) const;


    virtual bool __do_upcast(const __cxxabiv1::__class_type_info *__target,
        void **__obj_ptr) const;

  protected:
    const char *__name;

    explicit type_info(const char *__n): __name(__n) { }

  private:

    type_info& operator=(const type_info&);
    type_info(const type_info&);
  };







  class bad_cast : public exception
  {
  public:
    bad_cast() noexcept { }



    virtual ~bad_cast() noexcept;


    virtual const char* what() const noexcept;
  };





  class bad_typeid : public exception
  {
  public:
    bad_typeid () noexcept { }



    virtual ~bad_typeid() noexcept;


    virtual const char* what() const noexcept;
  };
}

}

#pragma GCC visibility pop
# 54 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 2 3

# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/tuple" 1 3
# 32 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/tuple" 3
       
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/tuple" 3





# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/utility" 1 3
# 58 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/utility" 3
       
# 59 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/utility" 3
# 69 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/utility" 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_relops.h" 1 3
# 67 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_relops.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{
  namespace rel_ops
  {
 
# 85 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator!=(const _Tp& __x, const _Tp& __y)
      { return !(__x == __y); }
# 98 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>(const _Tp& __x, const _Tp& __y)
      { return __y < __x; }
# 111 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator<=(const _Tp& __x, const _Tp& __y)
      { return !(__y < __x); }
# 124 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_relops.h" 3
    template <class _Tp>
      inline bool
      operator>=(const _Tp& __x, const _Tp& __y)
      { return !(__x < __y); }

 
  }

}
# 70 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/utility" 2 3






namespace std __attribute__ ((__visibility__ ("default")))
{


  template<class _Tp>
    class tuple_size;

  template<std::size_t _Int, class _Tp>
    class tuple_element;


  template<class _Tp1, class _Tp2>
    struct tuple_size<std::pair<_Tp1, _Tp2>>
    : public integral_constant<std::size_t, 2> { };

  template<class _Tp1, class _Tp2>
    struct tuple_element<0, std::pair<_Tp1, _Tp2>>
    { typedef _Tp1 type; };

  template<class _Tp1, class _Tp2>
    struct tuple_element<1, std::pair<_Tp1, _Tp2>>
    { typedef _Tp2 type; };

  template<std::size_t _Int>
    struct __pair_get;

  template<>
    struct __pair_get<0>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp1&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp1>(__pair.first); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp1&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.first; }
    };

  template<>
    struct __pair_get<1>
    {
      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&
        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }

      template<typename _Tp1, typename _Tp2>
        static constexpr _Tp2&&
        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept
        { return std::forward<_Tp2>(__pair.second); }

      template<typename _Tp1, typename _Tp2>
        static constexpr const _Tp2&
        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept
        { return __pair.second; }
    };

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__get(__in); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&
    get(std::pair<_Tp1, _Tp2>&& __in) noexcept
    { return __pair_get<_Int>::__move_get(std::move(__in)); }

  template<std::size_t _Int, class _Tp1, class _Tp2>
    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&
    get(const std::pair<_Tp1, _Tp2>& __in) noexcept
    { return __pair_get<_Int>::__const_get(__in); }
# 199 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/utility" 3
  template<size_t... _Indexes>
    struct _Index_tuple
    {
      typedef _Index_tuple<_Indexes..., sizeof...(_Indexes)> __next;
    };


  template<size_t _Num>
    struct _Build_index_tuple
    {
      typedef typename _Build_index_tuple<_Num - 1>::__type::__next __type;
    };

  template<>
    struct _Build_index_tuple<0>
    {
      typedef _Index_tuple<> __type;
    };
# 258 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/utility" 3

}
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/tuple" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/array" 1 3
# 32 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/array" 3
       
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/array" 3





# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/stdexcept" 1 3
# 36 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/stdexcept" 3
       
# 37 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/stdexcept" 3


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/string" 1 3
# 36 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/string" 3
       
# 37 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/string" 3


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stringfwd.h" 1 3
# 37 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stringfwd.h" 3
       
# 38 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stringfwd.h" 3




namespace std __attribute__ ((__visibility__ ("default")))
{








  template<class _CharT>
    struct char_traits;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
           typename _Alloc = allocator<_CharT> >
    class basic_string;

  template<> struct char_traits<char>;


  typedef basic_string<char> string;


  template<> struct char_traits<wchar_t>;


  typedef basic_string<wchar_t> wstring;





  template<> struct char_traits<char16_t>;
  template<> struct char_traits<char32_t>;


  typedef basic_string<char16_t> u16string;


  typedef basic_string<char32_t> u32string;





}
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/string" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/char_traits.h" 1 3
# 37 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/char_traits.h" 3
       
# 38 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/char_traits.h" 3


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/postypes.h" 1 3
# 38 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/postypes.h" 3
       
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/postypes.h" 3

# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cwchar" 1 3
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cwchar" 3
       
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cwchar" 3




# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/wchar.h" 1 3
# 37 "C:\\ndk/platforms/android-9/arch-arm/usr/include/wchar.h" 3
# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 1 3 4
# 38 "C:\\ndk/platforms/android-9/arch-arm/usr/include/wchar.h" 2 3


# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/time.h" 1 3
# 32 "C:\\ndk/platforms/android-9/arch-arm/usr/include/time.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/time.h" 1 3
# 33 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/time.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/linux/time.h" 1 3
# 19 "C:\\ndk/platforms/android-9/arch-arm/usr/include/linux/time.h" 3
struct timespec {
 time_t tv_sec;
 long tv_nsec;
};


struct timeval {
 time_t tv_sec;
 suseconds_t tv_usec;
};

struct timezone {
 int tz_minuteswest;
 int tz_dsttime;
};
# 47 "C:\\ndk/platforms/android-9/arch-arm/usr/include/linux/time.h" 3
struct itimerspec {
 struct timespec it_interval;
 struct timespec it_value;
};

struct itimerval {
 struct timeval it_interval;
 struct timeval it_value;
};
# 34 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/time.h" 2 3

extern "C" {

extern int gettimeofday(struct timeval *, struct timezone *);
extern int settimeofday(const struct timeval *, const struct timezone *);

extern int getitimer(int, struct itimerval *);
extern int setitimer(int, const struct itimerval *, struct itimerval *);

extern int utimes(const char *, const struct timeval *);
# 76 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/time.h" 3
}
# 33 "C:\\ndk/platforms/android-9/arch-arm/usr/include/time.h" 2 3


# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm/siginfo.h" 1 3
# 15 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm/siginfo.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm-generic/siginfo.h" 1 3
# 18 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm-generic/siginfo.h" 3
typedef union sigval {
 int sival_int;
 void *sival_ptr;
} sigval_t;
# 42 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm-generic/siginfo.h" 3
typedef struct siginfo {
 int si_signo;
 int si_errno;
 int si_code;

 union {
 int _pad[((128 - (3 * sizeof(int))) / sizeof(int))];

 struct {
 pid_t _pid;
 __kernel_uid32_t _uid;
 } _kill;

 struct {
 timer_t _tid;
 int _overrun;
 char _pad[sizeof( __kernel_uid32_t) - sizeof(int)];
 sigval_t _sigval;
 int _sys_private;
 } _timer;

 struct {
 pid_t _pid;
 __kernel_uid32_t _uid;
 sigval_t _sigval;
 } _rt;

 struct {
 pid_t _pid;
 __kernel_uid32_t _uid;
 int _status;
 clock_t _utime;
 clock_t _stime;
 } _sigchld;

 struct {
 void *_addr;



 } _sigfault;

 struct {
 long _band;
 int _fd;
 } _sigpoll;
 } _sifields;
} siginfo_t;
# 194 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm-generic/siginfo.h" 3
typedef struct sigevent {
 sigval_t sigev_value;
 int sigev_signo;
 int sigev_notify;
 union {
 int _pad[((64 - (sizeof(int) * 2 + sizeof(sigval_t))) / sizeof(int))];
 int _tid;

 struct {
 void (*_function)(sigval_t);
 void *_attribute;
 } _sigev_thread;
 } _sigev_un;
} sigevent_t;
# 16 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm/siginfo.h" 2 3
# 36 "C:\\ndk/platforms/android-9/arch-arm/usr/include/time.h" 2 3


extern "C" {

extern time_t time(time_t *);
extern int nanosleep(const struct timespec *, struct timespec *);

extern char *strtotimeval(const char *str, struct timeval *tv);

struct tm {
   int tm_sec;
   int tm_min;
   int tm_hour;
   int tm_mday;
   int tm_mon;
   int tm_year;
   int tm_wday;
   int tm_yday;
   int tm_isdst;

   long int tm_gmtoff;
   const char *tm_zone;

};






extern char* asctime(const struct tm* a);
extern char* asctime_r(const struct tm* a, char* buf);


extern double difftime (time_t __time1, time_t __time0) __attribute__((pcs("aapcs")));
extern time_t mktime (struct tm *a);

extern struct tm* localtime(const time_t *t);
extern struct tm* localtime_r(const time_t *timep, struct tm *result);

extern struct tm* gmtime(const time_t *timep);
extern struct tm* gmtime_r(const time_t *timep, struct tm *result);

extern char* strptime(const char *buf, const char *fmt, struct tm *tm);
extern size_t strftime(char *s, size_t max, const char *format, const struct tm *tm);

extern char *ctime(const time_t *timep);
extern char *ctime_r(const time_t *timep, char *buf);

extern void tzset(void);


extern char* tzname[];
extern int daylight;
extern long int timezone;



extern clock_t clock(void);


extern int clock_getres(clockid_t, struct timespec *);
extern int clock_gettime(clockid_t, struct timespec *);
extern int clock_settime(clockid_t, const struct timespec *);
extern int clock_nanosleep(clockid_t, int, const struct timespec *, struct timespec *);
# 113 "C:\\ndk/platforms/android-9/arch-arm/usr/include/time.h" 3
extern int timer_create(int, struct sigevent*, timer_t*);
extern int timer_delete(timer_t);
extern int timer_settime(timer_t timerid, int flags, const struct itimerspec *value, struct itimerspec *ovalue);
extern int timer_gettime(timer_t timerid, struct itimerspec *value);
extern int timer_getoverrun(timer_t timerid);

}
# 41 "C:\\ndk/platforms/android-9/arch-arm/usr/include/wchar.h" 2 3


# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 1 3 4
# 44 "C:\\ndk/platforms/android-9/arch-arm/usr/include/wchar.h" 2 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/_wchar_limits.h" 1 3
# 45 "C:\\ndk/platforms/android-9/arch-arm/usr/include/wchar.h" 2 3

extern "C" {

typedef unsigned int wint_t;
typedef struct { int dummy; } mbstate_t;

typedef enum {
    WC_TYPE_INVALID = 0,
    WC_TYPE_ALNUM,
    WC_TYPE_ALPHA,
    WC_TYPE_BLANK,
    WC_TYPE_CNTRL,
    WC_TYPE_DIGIT,
    WC_TYPE_GRAPH,
    WC_TYPE_LOWER,
    WC_TYPE_PRINT,
    WC_TYPE_PUNCT,
    WC_TYPE_SPACE,
    WC_TYPE_UPPER,
    WC_TYPE_XDIGIT,
    WC_TYPE_MAX
} wctype_t;



extern wint_t btowc(int);
extern int fwprintf(FILE *, const wchar_t *, ...);
extern int fwscanf(FILE *, const wchar_t *, ...);
extern int iswalnum(wint_t);
extern int iswalpha(wint_t);
extern int iswcntrl(wint_t);
extern int iswdigit(wint_t);
extern int iswgraph(wint_t);
extern int iswlower(wint_t);
extern int iswprint(wint_t);
extern int iswpunct(wint_t);
extern int iswspace(wint_t);
extern int iswupper(wint_t);
extern int iswxdigit(wint_t);
extern int iswctype(wint_t, wctype_t);
extern wint_t fgetwc(FILE *);
extern wchar_t *fgetws(wchar_t *, int, FILE *);
extern wint_t fputwc(wchar_t, FILE *);
extern int fputws(const wchar_t *, FILE *);
extern int fwide(FILE *, int);
extern wint_t getwc(FILE *);
extern wint_t getwchar(void);
extern int mbsinit(const mbstate_t *);
extern size_t mbrlen(const char *, size_t, mbstate_t *);
extern size_t mbrtowc(wchar_t *, const char *, size_t, mbstate_t *);
extern size_t mbsrtowcs(wchar_t *, const char **, size_t, mbstate_t *);
extern size_t mbstowcs(wchar_t *, const char *, size_t);
extern wint_t putwc(wchar_t, FILE *);
extern wint_t putwchar(wchar_t);
extern int swprintf(wchar_t *, size_t, const wchar_t *, ...);
extern int swscanf(const wchar_t *, const wchar_t *, ...);
extern wint_t towlower(wint_t);
extern wint_t towupper(wint_t);
extern wint_t ungetwc(wint_t, FILE *);
extern int vfwprintf(FILE *, const wchar_t *, va_list);
extern int vwprintf(const wchar_t *, va_list);
extern int vswprintf(wchar_t *, size_t, const wchar_t *, va_list);
extern size_t wcrtomb(char *, wchar_t, mbstate_t *);
extern wchar_t *wcscat(wchar_t *, const wchar_t *);
extern wchar_t *wcschr(const wchar_t *, wchar_t);
extern int wcscmp(const wchar_t *, const wchar_t *);
extern int wcscoll(const wchar_t *, const wchar_t *);
extern wchar_t *wcscpy(wchar_t *, const wchar_t *);
extern size_t wcscspn(const wchar_t *, const wchar_t *);
extern size_t wcsftime(wchar_t *, size_t, const wchar_t *, const struct tm *);
extern size_t wcslen(const wchar_t *);
extern wchar_t *wcsncat(wchar_t *, const wchar_t *, size_t);
extern int wcsncmp(const wchar_t *, const wchar_t *, size_t);
extern wchar_t *wcsncpy(wchar_t *, const wchar_t *, size_t);
extern wchar_t *wcspbrk(const wchar_t *, const wchar_t *);
extern wchar_t *wcsrchr(const wchar_t *, wchar_t);
extern size_t wcsrtombs(char *, const wchar_t **, size_t, mbstate_t *);
extern size_t wcsspn(const wchar_t *, const wchar_t *);
extern wchar_t *wcsstr(const wchar_t *, const wchar_t *);
extern double wcstod(const wchar_t *, wchar_t **) __attribute__((pcs("aapcs")));
extern wchar_t *wcstok(wchar_t *, const wchar_t *, wchar_t **);
extern long int wcstol(const wchar_t *, wchar_t **, int);
extern size_t wcstombs(char *, const wchar_t *, size_t);
extern unsigned long int wcstoul(const wchar_t *, wchar_t **, int);
extern wchar_t *wcswcs(const wchar_t *, const wchar_t *);
extern int wcswidth(const wchar_t *, size_t);
extern size_t wcsxfrm(wchar_t *, const wchar_t *, size_t);
extern int wctob(wint_t);
extern wctype_t wctype(const char *);
extern int wcwidth(wchar_t);
extern wchar_t *wmemchr(const wchar_t *, wchar_t, size_t);
extern int wmemcmp(const wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemcpy(wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemmove(wchar_t *, const wchar_t *, size_t);
extern wchar_t *wmemset(wchar_t *, wchar_t, size_t);
extern int wprintf(const wchar_t *, ...);
extern int wscanf(const wchar_t *, ...);


typedef void *wctrans_t;
extern wint_t towctrans(wint_t, wctrans_t);
extern wctrans_t wctrans (const char *);

}
# 45 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cwchar" 2 3
# 62 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cwchar" 3
namespace std
{
  using ::mbstate_t;
}
# 135 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cwchar" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  using ::wint_t;

  using ::btowc;
  using ::fgetwc;
  using ::fgetws;
  using ::fputwc;
  using ::fputws;
  using ::fwide;
  using ::fwprintf;
  using ::fwscanf;
  using ::getwc;
  using ::getwchar;
  using ::mbrlen;
  using ::mbrtowc;
  using ::mbsinit;
  using ::mbsrtowcs;
  using ::putwc;
  using ::putwchar;

  using ::swprintf;

  using ::swscanf;
  using ::ungetwc;
  using ::vfwprintf;




  using ::vswprintf;




  using ::vwprintf;



  using ::wcrtomb;
  using ::wcscat;
  using ::wcscmp;
  using ::wcscoll;
  using ::wcscpy;
  using ::wcscspn;
  using ::wcsftime;
  using ::wcslen;
  using ::wcsncat;
  using ::wcsncmp;
  using ::wcsncpy;
  using ::wcsrtombs;
  using ::wcsspn;
  using ::wcstod;



  using ::wcstok;
  using ::wcstol;
  using ::wcstoul;
  using ::wcsxfrm;
  using ::wctob;
  using ::wmemcmp;
  using ::wmemcpy;
  using ::wmemmove;
  using ::wmemset;
  using ::wprintf;
  using ::wscanf;
  using ::wcschr;
  using ::wcspbrk;
  using ::wcsrchr;
  using ::wcsstr;
  using ::wmemchr;


  inline wchar_t*
  wcschr(wchar_t* __p, wchar_t __c)
  { return wcschr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcspbrk(wchar_t* __s1, const wchar_t* __s2)
  { return wcspbrk(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wcsrchr(wchar_t* __p, wchar_t __c)
  { return wcsrchr(const_cast<const wchar_t*>(__p), __c); }

  inline wchar_t*
  wcsstr(wchar_t* __s1, const wchar_t* __s2)
  { return wcsstr(const_cast<const wchar_t*>(__s1), __s2); }

  inline wchar_t*
  wmemchr(wchar_t* __p, wchar_t __c, size_t __n)
  { return wmemchr(const_cast<const wchar_t*>(__p), __c, __n); }



}
# 277 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cwchar" 3
namespace std
{
# 297 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cwchar" 3
}
# 41 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/postypes.h" 2 3
# 68 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/postypes.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 90 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/postypes.h" 3
  typedef long long streamoff;







  typedef ptrdiff_t streamsize;
# 111 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/postypes.h" 3
  template<typename _StateT>
    class fpos
    {
    private:
      streamoff _M_off;
      _StateT _M_state;

    public:




      fpos()
      : _M_off(0), _M_state() { }
# 133 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/postypes.h" 3
      fpos(streamoff __off)
      : _M_off(__off), _M_state() { }


      operator streamoff() const { return _M_off; }


      void
      state(_StateT __st)
      { _M_state = __st; }


      _StateT
      state() const
      { return _M_state; }





      fpos&
      operator+=(streamoff __off)
      {
 _M_off += __off;
 return *this;
      }





      fpos&
      operator-=(streamoff __off)
      {
 _M_off -= __off;
 return *this;
      }







      fpos
      operator+(streamoff __off) const
      {
 fpos __pos(*this);
 __pos += __off;
 return __pos;
      }







      fpos
      operator-(streamoff __off) const
      {
 fpos __pos(*this);
 __pos -= __off;
 return __pos;
      }






      streamoff
      operator-(const fpos& __other) const
      { return _M_off - __other._M_off; }
    };






  template<typename _StateT>
    inline bool
    operator==(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) == streamoff(__rhs); }

  template<typename _StateT>
    inline bool
    operator!=(const fpos<_StateT>& __lhs, const fpos<_StateT>& __rhs)
    { return streamoff(__lhs) != streamoff(__rhs); }





  typedef fpos<mbstate_t> streampos;

  typedef fpos<mbstate_t> wstreampos;



  typedef fpos<mbstate_t> u16streampos;

  typedef fpos<mbstate_t> u32streampos;



}
# 41 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/char_traits.h" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cwchar" 1 3
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cwchar" 3
       
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cwchar" 3
# 42 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/char_traits.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{

# 57 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/char_traits.h" 3
  template<typename _CharT>
    struct _Char_types
    {
      typedef unsigned long int_type;
      typedef std::streampos pos_type;
      typedef std::streamoff off_type;
      typedef std::mbstate_t state_type;
    };
# 82 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/char_traits.h" 3
  template<typename _CharT>
    struct char_traits
    {
      typedef _CharT char_type;
      typedef typename _Char_types<_CharT>::int_type int_type;
      typedef typename _Char_types<_CharT>::pos_type pos_type;
      typedef typename _Char_types<_CharT>::off_type off_type;
      typedef typename _Char_types<_CharT>::state_type state_type;

      static void
      assign(char_type& __c1, const char_type& __c2)
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2)
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2)
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, std::size_t __n);

      static std::size_t
      length(const char_type* __s);

      static const char_type*
      find(const char_type* __s, std::size_t __n, const char_type& __a);

      static char_type*
      move(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      copy(char_type* __s1, const char_type* __s2, std::size_t __n);

      static char_type*
      assign(char_type* __s, std::size_t __n, char_type __a);

      static constexpr char_type
      to_char_type(const int_type& __c)
      { return static_cast<char_type>(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c)
      { return static_cast<int_type>(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2)
      { return __c1 == __c2; }

      static constexpr int_type
      eof()
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c)
      { return !eq_int_type(__c, eof()) ? __c : to_int_type(char_type()); }
    };

  template<typename _CharT>
    int
    char_traits<_CharT>::
    compare(const char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
 if (lt(__s1[__i], __s2[__i]))
   return -1;
 else if (lt(__s2[__i], __s1[__i]))
   return 1;
      return 0;
    }

  template<typename _CharT>
    std::size_t
    char_traits<_CharT>::
    length(const char_type* __p)
    {
      std::size_t __i = 0;
      while (!eq(__p[__i], char_type()))
        ++__i;
      return __i;
    }

  template<typename _CharT>
    const typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    find(const char_type* __s, std::size_t __n, const char_type& __a)
    {
      for (std::size_t __i = 0; __i < __n; ++__i)
        if (eq(__s[__i], __a))
          return __s + __i;
      return 0;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    move(char_type* __s1, const char_type* __s2, std::size_t __n)
    {
      return static_cast<_CharT*>(__builtin_memmove(__s1, __s2,
          __n * sizeof(char_type)));
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    copy(char_type* __s1, const char_type* __s2, std::size_t __n)
    {

      std::copy(__s2, __s2 + __n, __s1);
      return __s1;
    }

  template<typename _CharT>
    typename char_traits<_CharT>::char_type*
    char_traits<_CharT>::
    assign(char_type* __s, std::size_t __n, char_type __a)
    {

      std::fill_n(__s, __n, __a);
      return __s;
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{

# 226 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/char_traits.h" 3
  template<class _CharT>
    struct char_traits : public __gnu_cxx::char_traits<_CharT>
    { };



  template<>
    struct char_traits<char>
    {
      typedef char char_type;
      typedef int int_type;
      typedef streampos pos_type;
      typedef streamoff off_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      {

 return (static_cast<unsigned char>(__c1)
  < static_cast<unsigned char>(__c2));
      }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return __builtin_memcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return __builtin_strlen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return static_cast<const char_type*>(__builtin_memchr(__s, __a, __n)); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memmove(__s1, __s2, __n)); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return static_cast<char_type*>(__builtin_memcpy(__s1, __s2, __n)); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return static_cast<char_type*>(__builtin_memset(__s, __a, __n)); }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return static_cast<char_type>(__c); }



      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return static_cast<int_type>(static_cast<unsigned char>(__c)); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return (__c == eof()) ? 0 : __c; }
  };




  template<>
    struct char_traits<wchar_t>
    {
      typedef wchar_t char_type;
      typedef wint_t int_type;
      typedef streamoff off_type;
      typedef wstreampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcmp(__s1, __s2, __n); }

      static size_t
      length(const char_type* __s)
      { return wcslen(__s); }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      { return wmemchr(__s, __a, __n); }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemmove(__s1, __s2, __n); }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      { return wmemcpy(__s1, __s2, __n); }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      { return wmemset(__s, __a, __n); }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(((wint_t)(-1))); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
  };



}






namespace std __attribute__ ((__visibility__ ("default")))
{


  template<>
    struct char_traits<char16_t>
    {
      typedef char16_t char_type;
      typedef uint_least16_t int_type;
      typedef streamoff off_type;
      typedef u16streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };

  template<>
    struct char_traits<char32_t>
    {
      typedef char32_t char_type;
      typedef uint_least32_t int_type;
      typedef streamoff off_type;
      typedef u32streampos pos_type;
      typedef mbstate_t state_type;

      static void
      assign(char_type& __c1, const char_type& __c2) noexcept
      { __c1 = __c2; }

      static constexpr bool
      eq(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr bool
      lt(const char_type& __c1, const char_type& __c2) noexcept
      { return __c1 < __c2; }

      static int
      compare(const char_type* __s1, const char_type* __s2, size_t __n)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (lt(__s1[__i], __s2[__i]))
     return -1;
   else if (lt(__s2[__i], __s1[__i]))
     return 1;
 return 0;
      }

      static size_t
      length(const char_type* __s)
      {
 size_t __i = 0;
 while (!eq(__s[__i], char_type()))
   ++__i;
 return __i;
      }

      static const char_type*
      find(const char_type* __s, size_t __n, const char_type& __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   if (eq(__s[__i], __a))
     return __s + __i;
 return 0;
      }

      static char_type*
      move(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memmove(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      copy(char_type* __s1, const char_type* __s2, size_t __n)
      {
 return (static_cast<char_type*>
  (__builtin_memcpy(__s1, __s2, __n * sizeof(char_type))));
      }

      static char_type*
      assign(char_type* __s, size_t __n, char_type __a)
      {
 for (size_t __i = 0; __i < __n; ++__i)
   assign(__s[__i], __a);
 return __s;
      }

      static constexpr char_type
      to_char_type(const int_type& __c) noexcept
      { return char_type(__c); }

      static constexpr int_type
      to_int_type(const char_type& __c) noexcept
      { return int_type(__c); }

      static constexpr bool
      eq_int_type(const int_type& __c1, const int_type& __c2) noexcept
      { return __c1 == __c2; }

      static constexpr int_type
      eof() noexcept
      { return static_cast<int_type>(-1); }

      static constexpr int_type
      not_eof(const int_type& __c) noexcept
      { return eq_int_type(__c, eof()) ? 0 : __c; }
    };


}
# 41 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/string" 2 3


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/localefwd.h" 1 3
# 37 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/localefwd.h" 3
       
# 38 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/localefwd.h" 3


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/c++locale.h" 1 3
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/c++locale.h" 3
       
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/c++locale.h" 3

# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/clocale" 1 3
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/clocale" 3
       
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/clocale" 3


# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/locale.h" 1 3
# 33 "C:\\ndk/platforms/android-9/arch-arm/usr/include/locale.h" 3
extern "C" {

enum {
    LC_CTYPE = 0,
    LC_NUMERIC = 1,
    LC_TIME = 2,
    LC_COLLATE = 3,
    LC_MONETARY = 4,
    LC_MESSAGES = 5,
    LC_ALL = 6,
    LC_PAPER = 7,
    LC_NAME = 8,
    LC_ADDRESS = 9,

    LC_TELEPHONE = 10,
    LC_MEASUREMENT = 11,
    LC_IDENTIFICATION = 12
};

extern char *setlocale(int category, const char *locale);


struct lconv { };
struct lconv *localeconv(void);


}
# 43 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/clocale" 2 3
# 51 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/clocale" 3
namespace std
{
  using ::lconv;
  using ::setlocale;
  using ::localeconv;
}
# 42 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/c++locale.h" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  typedef int* __c_locale;





  inline int
  __convert_from_v(const __c_locale&, char* __out,
     const int __size __attribute__((__unused__)),
     const char* __fmt, ...)
  {
    char* __old = std::setlocale(LC_NUMERIC, 0);
    char* __sav = 0;

    if (__old)
      {

        if (__builtin_strcmp(__old, "C"))
          {
            const size_t __len = __builtin_strlen(__old) + 1;
            __sav = new char[__len];
            __builtin_memcpy(__sav, __old, __len);
            std::setlocale(LC_NUMERIC, "C");
          }

      }


    __builtin_va_list __args;
    __builtin_va_start(__args, __fmt);




    const int __ret = __builtin_vsprintf(__out, __fmt, __args);


    __builtin_va_end(__args);

    if (__sav)
      {
 std::setlocale(LC_NUMERIC, __sav);
 delete [] __sav;
      }
    return __ret;
  }


}
# 41 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/localefwd.h" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/iosfwd" 1 3
# 36 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/iosfwd" 3
       
# 37 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/iosfwd" 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 74 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/iosfwd" 3
  class ios_base;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ios;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_streambuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_istream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_iostream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
     typename _Alloc = allocator<_CharT> >
    class basic_stringbuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_istringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_ostringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT>,
    typename _Alloc = allocator<_CharT> >
    class basic_stringstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_filebuf;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ifstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_ofstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class basic_fstream;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class istreambuf_iterator;

  template<typename _CharT, typename _Traits = char_traits<_CharT> >
    class ostreambuf_iterator;



  typedef basic_ios<char> ios;


  typedef basic_streambuf<char> streambuf;


  typedef basic_istream<char> istream;


  typedef basic_ostream<char> ostream;


  typedef basic_iostream<char> iostream;


  typedef basic_stringbuf<char> stringbuf;


  typedef basic_istringstream<char> istringstream;


  typedef basic_ostringstream<char> ostringstream;


  typedef basic_stringstream<char> stringstream;


  typedef basic_filebuf<char> filebuf;


  typedef basic_ifstream<char> ifstream;


  typedef basic_ofstream<char> ofstream;


  typedef basic_fstream<char> fstream;



  typedef basic_ios<wchar_t> wios;


  typedef basic_streambuf<wchar_t> wstreambuf;


  typedef basic_istream<wchar_t> wistream;


  typedef basic_ostream<wchar_t> wostream;


  typedef basic_iostream<wchar_t> wiostream;


  typedef basic_stringbuf<wchar_t> wstringbuf;


  typedef basic_istringstream<wchar_t> wistringstream;


  typedef basic_ostringstream<wchar_t> wostringstream;


  typedef basic_stringstream<wchar_t> wstringstream;


  typedef basic_filebuf<wchar_t> wfilebuf;


  typedef basic_ifstream<wchar_t> wifstream;


  typedef basic_ofstream<wchar_t> wofstream;


  typedef basic_fstream<wchar_t> wfstream;




}
# 42 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/localefwd.h" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cctype" 1 3
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cctype" 3
       
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cctype" 3


# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/ctype.h" 1 3
# 54 "C:\\ndk/platforms/android-9/arch-arm/usr/include/ctype.h" 3
extern "C" {

extern const char *_ctype_;
extern const short *_tolower_tab_;
extern const short *_toupper_tab_;
# 72 "C:\\ndk/platforms/android-9/arch-arm/usr/include/ctype.h" 3
int isalnum(int);
int isalpha(int);
int iscntrl(int);
int isdigit(int);
int isgraph(int);
int islower(int);
int isprint(int);
int ispunct(int);
int isspace(int);
int isupper(int);
int isxdigit(int);
int tolower(int);
int toupper(int);



int isblank(int);



int isascii(int);
int toascii(int);
int _tolower(int);
int _toupper(int);
# 203 "C:\\ndk/platforms/android-9/arch-arm/usr/include/ctype.h" 3
}
# 43 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cctype" 2 3
# 62 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cctype" 3
namespace std
{
  using ::isalnum;
  using ::isalpha;
  using ::iscntrl;
  using ::isdigit;
  using ::isgraph;
  using ::islower;
  using ::isprint;
  using ::ispunct;
  using ::isspace;
  using ::isupper;
  using ::isxdigit;
  using ::tolower;
  using ::toupper;
}







namespace std
{
  using ::isblank;
}
# 43 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/localefwd.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/localefwd.h" 3
  class locale;

  template<typename _Facet>
    bool
    has_facet(const locale&) throw();

  template<typename _Facet>
    const _Facet&
    use_facet(const locale&);


  template<typename _CharT>
    bool
    isspace(_CharT, const locale&);

  template<typename _CharT>
    bool
    isprint(_CharT, const locale&);

  template<typename _CharT>
    bool
    iscntrl(_CharT, const locale&);

  template<typename _CharT>
    bool
    isupper(_CharT, const locale&);

  template<typename _CharT>
    bool
    islower(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalpha(_CharT, const locale&);

  template<typename _CharT>
    bool
    isdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    ispunct(_CharT, const locale&);

  template<typename _CharT>
    bool
    isxdigit(_CharT, const locale&);

  template<typename _CharT>
    bool
    isalnum(_CharT, const locale&);

  template<typename _CharT>
    bool
    isgraph(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    toupper(_CharT, const locale&);

  template<typename _CharT>
    _CharT
    tolower(_CharT, const locale&);


  class ctype_base;
  template<typename _CharT>
    class ctype;
  template<> class ctype<char>;

  template<> class ctype<wchar_t>;

  template<typename _CharT>
    class ctype_byname;


  class codecvt_base;
  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt;
  template<> class codecvt<char, char, mbstate_t>;

  template<> class codecvt<wchar_t, char, mbstate_t>;

  template<typename _InternT, typename _ExternT, typename _StateT>
    class codecvt_byname;



  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class num_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class num_put;

  template<typename _CharT> class numpunct;
  template<typename _CharT> class numpunct_byname;


  template<typename _CharT>
    class collate;
  template<typename _CharT> class
    collate_byname;


  class time_base;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get;
  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class time_get_byname;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class time_put_byname;


  class money_base;

  template<typename _CharT, typename _InIter = istreambuf_iterator<_CharT> >
    class money_get;
  template<typename _CharT, typename _OutIter = ostreambuf_iterator<_CharT> >
    class money_put;

  template<typename _CharT, bool _Intl = false>
    class moneypunct;
  template<typename _CharT, bool _Intl = false>
    class moneypunct_byname;


  class messages_base;
  template<typename _CharT>
    class messages;
  template<typename _CharT>
    class messages_byname;


}
# 44 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/string" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/ostream_insert.h" 1 3
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/ostream_insert.h" 3
       
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/ostream_insert.h" 3


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/cxxabi_forced.h" 1 3
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/cxxabi_forced.h" 3
       
# 35 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/cxxabi_forced.h" 3

#pragma GCC visibility push(default)


namespace __cxxabiv1
{







  class __forced_unwind
  {
    virtual ~__forced_unwind() throw();


    virtual void __pure_dummy() = 0;
  };
}


#pragma GCC visibility pop
# 37 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/ostream_insert.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits>
    inline void
    __ostream_write(basic_ostream<_CharT, _Traits>& __out,
      const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const streamsize __put = __out.rdbuf()->sputn(__s, __n);
      if (__put != __n)
 __out.setstate(__ios_base::badbit);
    }

  template<typename _CharT, typename _Traits>
    inline void
    __ostream_fill(basic_ostream<_CharT, _Traits>& __out, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      const _CharT __c = __out.fill();
      for (; __n > 0; --__n)
 {
   const typename _Traits::int_type __put = __out.rdbuf()->sputc(__c);
   if (_Traits::eq_int_type(__put, _Traits::eof()))
     {
       __out.setstate(__ios_base::badbit);
       break;
     }
 }
    }

  template<typename _CharT, typename _Traits>
    basic_ostream<_CharT, _Traits>&
    __ostream_insert(basic_ostream<_CharT, _Traits>& __out,
       const _CharT* __s, streamsize __n)
    {
      typedef basic_ostream<_CharT, _Traits> __ostream_type;
      typedef typename __ostream_type::ios_base __ios_base;

      typename __ostream_type::sentry __cerb(__out);
      if (__cerb)
 {
   try
     {
       const streamsize __w = __out.width();
       if (__w > __n)
  {
    const bool __left = ((__out.flags()
     & __ios_base::adjustfield)
           == __ios_base::left);
    if (!__left)
      __ostream_fill(__out, __w - __n);
    if (__out.good())
      __ostream_write(__out, __s, __n);
    if (__left && __out.good())
      __ostream_fill(__out, __w - __n);
  }
       else
  __ostream_write(__out, __s, __n);
       __out.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __out._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     { __out._M_setstate(__ios_base::badbit); }
 }
      return __out;
    }




  extern template ostream& __ostream_insert(ostream&, const char*, streamsize);


  extern template wostream& __ostream_insert(wostream&, const wchar_t*,
          streamsize);




}
# 45 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/string" 2 3







# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 1 3
# 37 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
       
# 38 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3

# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/atomicity.h" 1 3
# 32 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/atomicity.h" 3
       
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/atomicity.h" 3


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/gthr.h" 1 3
# 30 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/gthr.h" 3
#pragma GCC visibility push(default)
# 148 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/gthr.h" 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/gthr-default.h" 1 3
# 48 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/gthr-default.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/pthread.h" 1 3
# 32 "C:\\ndk/platforms/android-9/arch-arm/usr/include/pthread.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/signal.h" 1 3
# 35 "C:\\ndk/platforms/android-9/arch-arm/usr/include/signal.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm/signal.h" 1 3
# 17 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm/signal.h" 3
struct siginfo;


typedef unsigned long sigset_t;
# 82 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm/signal.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm-generic/signal.h" 1 3
# 28 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm-generic/signal.h" 3
typedef void __signalfn_t(int);
typedef __signalfn_t *__sighandler_t;

typedef void __restorefn_t(void);
typedef __restorefn_t *__sigrestore_t;
# 83 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm/signal.h" 2 3

struct sigaction {
 union {
 __sighandler_t _sa_handler;
 void (*_sa_sigaction)(int, struct siginfo *, void *);
 } _u;
 sigset_t sa_mask;
 unsigned long sa_flags;
 void (*sa_restorer)(void);
};




typedef struct sigaltstack {
 void *ss_sp;
 int ss_flags;
 size_t ss_size;
} stack_t;
# 36 "C:\\ndk/platforms/android-9/arch-arm/usr/include/signal.h" 2 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm/sigcontext.h" 1 3
# 15 "C:\\ndk/platforms/android-9/arch-arm/usr/include/asm/sigcontext.h" 3
struct sigcontext {
 unsigned long trap_no;
 unsigned long error_code;
 unsigned long oldmask;
 unsigned long arm_r0;
 unsigned long arm_r1;
 unsigned long arm_r2;
 unsigned long arm_r3;
 unsigned long arm_r4;
 unsigned long arm_r5;
 unsigned long arm_r6;
 unsigned long arm_r7;
 unsigned long arm_r8;
 unsigned long arm_r9;
 unsigned long arm_r10;
 unsigned long arm_fp;
 unsigned long arm_ip;
 unsigned long arm_sp;
 unsigned long arm_lr;
 unsigned long arm_pc;
 unsigned long arm_cpsr;
 unsigned long fault_address;
};
# 37 "C:\\ndk/platforms/android-9/arch-arm/usr/include/signal.h" 2 3





# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/ucontext.h" 1 3
# 32 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/ucontext.h" 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/signal.h" 1 3
# 33 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/ucontext.h" 2 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/user.h" 1 3
# 34 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/user.h" 3
# 1 "c:\\ndk\\toolchains\\arm-linux-androideabi-4.9\\prebuilt\\windows-x86_64\\lib\\gcc\\arm-linux-androideabi\\4.9\\include\\stddef.h" 1 3 4
# 35 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/user.h" 2 3

extern "C" {
# 186 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/user.h" 3
struct user_fpregs {
  struct fp_reg {
    unsigned int sign1:1;
    unsigned int unused:15;
    unsigned int sign2:1;
    unsigned int exponent:14;
    unsigned int j:1;
    unsigned int mantissa1:31;
    unsigned int mantissa0:32;
  } fpregs[8];
  unsigned int fpsr:32;
  unsigned int fpcr:32;
  unsigned char ftype[8];
  unsigned int init_flag;
};
struct user_regs {
  unsigned long uregs[18];
};
struct user_vfp {
  unsigned long long fpregs[32];
  unsigned long fpscr;
};
struct user_vfp_exc {
  unsigned long fpexc;
  unsigned long fpinst;
  unsigned long fpinst2;
};
struct user {
  struct user_regs regs;
  int u_fpvalid;
  unsigned long int u_tsize;
  unsigned long int u_dsize;
  unsigned long int u_ssize;
  unsigned long start_code;
  unsigned long start_stack;
  long int signal;
  int reserved;
  struct user_regs* u_ar0;
  unsigned long magic;
  char u_comm[32];
  int u_debugreg[8];
  struct user_fpregs u_fp;
  struct user_fpregs* u_fp0;
};
# 241 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/user.h" 3
}
# 34 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/ucontext.h" 2 3

extern "C" {



enum {
  REG_R0 = 0,
  REG_R1,
  REG_R2,
  REG_R3,
  REG_R4,
  REG_R5,
  REG_R6,
  REG_R7,
  REG_R8,
  REG_R9,
  REG_R10,
  REG_R11,
  REG_R12,
  REG_R13,
  REG_R14,
  REG_R15,
};



typedef int greg_t;
typedef greg_t gregset_t[18];


typedef struct sigcontext mcontext_t;

typedef struct ucontext {
  unsigned long uc_flags;
  struct ucontext* uc_link;
  stack_t uc_stack;
  mcontext_t uc_mcontext;
  sigset_t uc_sigmask;

  uint32_t __padding_rt_sigset;

  char __padding[120];
  unsigned long uc_regspace[128] __attribute__((__aligned__(8)));
} ucontext_t;
# 287 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sys/ucontext.h" 3
}
# 43 "C:\\ndk/platforms/android-9/arch-arm/usr/include/signal.h" 2 3


extern "C" {

typedef int sig_atomic_t;
# 60 "C:\\ndk/platforms/android-9/arch-arm/usr/include/signal.h" 3
extern const char * const sys_siglist[];
extern const char * const sys_signame[];

static __inline__ int sigismember(sigset_t *set, int signum)
{
    unsigned long *local_set = (unsigned long *)set;
    signum--;
    return (int)((local_set[signum/32] >> (signum%32)) & 1);
}


static __inline__ int sigaddset(sigset_t *set, int signum)
{
    unsigned long *local_set = (unsigned long *)set;
    signum--;
    local_set[signum/32] |= 1UL << (signum%32);
    return 0;
}


static __inline__ int sigdelset(sigset_t *set, int signum)
{
    unsigned long *local_set = (unsigned long *)set;
    signum--;
    local_set[signum/32] &= ~(1UL << (signum%32));
    return 0;
}


static __inline__ int sigemptyset(sigset_t *set)
{
    memset(set, 0, sizeof *set);
    return 0;
}

static __inline__ int sigfillset(sigset_t *set)
{
    memset(set, ~0, sizeof *set);
    return 0;
}



typedef void (*sig_t)(int);
typedef sig_t sighandler_t;


extern __sighandler_t sysv_signal(int, __sighandler_t);
extern __sighandler_t bsd_signal(int, __sighandler_t);


static __inline__ __sighandler_t signal(int s, __sighandler_t f)
{
    return bsd_signal(s,f);
}


extern __sighandler_t __signal(int, __sighandler_t, int);

extern int sigprocmask(int, const sigset_t *, sigset_t *);
extern int sigaction(int, const struct sigaction *, struct sigaction *);

extern int sigpending(sigset_t *);
extern int sigsuspend(const sigset_t *);
extern int sigwait(const sigset_t *set, int *sig);
extern int siginterrupt(int sig, int flag);

extern int raise(int);
extern int kill(pid_t, int);
extern int killpg(int pgrp, int sig);
extern int sigaltstack(const stack_t *ss, stack_t *oss);


}
# 33 "C:\\ndk/platforms/android-9/arch-arm/usr/include/pthread.h" 2 3
# 1 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sched.h" 1 3
# 34 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sched.h" 3
extern "C" {






struct sched_param {
    int sched_priority;
};

extern int sched_setscheduler(pid_t, int, const struct sched_param *);
extern int sched_getscheduler(pid_t);
extern int sched_yield(void);
extern int sched_get_priority_max(int policy);
extern int sched_get_priority_min(int policy);
extern int sched_setparam(pid_t, const struct sched_param *);
extern int sched_getparam(pid_t, struct sched_param *);
extern int sched_rr_get_interval(pid_t pid, struct timespec *tp);
# 73 "C:\\ndk/platforms/android-9/arch-arm/usr/include/sched.h" 3
extern int clone(int (*fn)(void *), void *child_stack, int flags, void* arg, ...);


}
# 34 "C:\\ndk/platforms/android-9/arch-arm/usr/include/pthread.h" 2 3






typedef struct
{
    int volatile value;
} pthread_mutex_t;
# 53 "C:\\ndk/platforms/android-9/arch-arm/usr/include/pthread.h" 3
enum {
    PTHREAD_MUTEX_NORMAL = 0,
    PTHREAD_MUTEX_RECURSIVE = 1,
    PTHREAD_MUTEX_ERRORCHECK = 2,

    PTHREAD_MUTEX_ERRORCHECK_NP = PTHREAD_MUTEX_ERRORCHECK,
    PTHREAD_MUTEX_RECURSIVE_NP = PTHREAD_MUTEX_RECURSIVE,

    PTHREAD_MUTEX_DEFAULT = PTHREAD_MUTEX_NORMAL
};



typedef struct
{
    int volatile value;
} pthread_cond_t;

typedef struct
{
    uint32_t flags;
    void * stack_base;
    size_t stack_size;
    size_t guard_size;
    int32_t sched_policy;
    int32_t sched_priority;
} pthread_attr_t;

typedef long pthread_mutexattr_t;
typedef long pthread_condattr_t;

typedef int pthread_key_t;
typedef long pthread_t;

typedef volatile int pthread_once_t;
# 111 "C:\\ndk/platforms/android-9/arch-arm/usr/include/pthread.h" 3
extern "C" {


int pthread_attr_init(pthread_attr_t * attr);
int pthread_attr_destroy(pthread_attr_t * attr);

int pthread_attr_setdetachstate(pthread_attr_t * attr, int state);
int pthread_attr_getdetachstate(pthread_attr_t const * attr, int * state);

int pthread_attr_setschedpolicy(pthread_attr_t * attr, int policy);
int pthread_attr_getschedpolicy(pthread_attr_t const * attr, int * policy);

int pthread_attr_setschedparam(pthread_attr_t * attr, struct sched_param const * param);
int pthread_attr_getschedparam(pthread_attr_t const * attr, struct sched_param * param);

int pthread_attr_setstacksize(pthread_attr_t * attr, size_t stack_size);
int pthread_attr_getstacksize(pthread_attr_t const * attr, size_t * stack_size);

int pthread_attr_setstackaddr(pthread_attr_t * attr, void * stackaddr);
int pthread_attr_getstackaddr(pthread_attr_t const * attr, void ** stackaddr);

int pthread_attr_setstack(pthread_attr_t * attr, void * stackaddr, size_t stack_size);
int pthread_attr_getstack(pthread_attr_t const * attr, void ** stackaddr, size_t * stack_size);

int pthread_attr_setguardsize(pthread_attr_t * attr, size_t guard_size);
int pthread_attr_getguardsize(pthread_attr_t const * attr, size_t * guard_size);

int pthread_attr_setscope(pthread_attr_t *attr, int scope);
int pthread_attr_getscope(pthread_attr_t const *attr);

int pthread_getattr_np(pthread_t thid, pthread_attr_t * attr);

int pthread_create(pthread_t *thread, pthread_attr_t const * attr,
                   void *(*start_routine)(void *), void * arg);

__attribute__((__noreturn__)) void pthread_exit(void * retval);

int pthread_join(pthread_t thid, void ** ret_val);
int pthread_detach(pthread_t thid);

pthread_t pthread_self(void);
int pthread_equal(pthread_t one, pthread_t two);

int pthread_getschedparam(pthread_t thid, int * policy,
                          struct sched_param * param);
int pthread_setschedparam(pthread_t thid, int poilcy,
                          struct sched_param const * param);

int pthread_mutexattr_init(pthread_mutexattr_t *attr);
int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);
int pthread_mutexattr_gettype(const pthread_mutexattr_t *attr, int *type);
int pthread_mutexattr_settype(pthread_mutexattr_t *attr, int type);
int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared);
int pthread_mutexattr_getpshared(pthread_mutexattr_t *attr, int *pshared);

int pthread_mutex_init(pthread_mutex_t *mutex,
                       const pthread_mutexattr_t *attr);
int pthread_mutex_destroy(pthread_mutex_t *mutex);
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);




int pthread_condattr_init(pthread_condattr_t *attr);
int pthread_condattr_getpshared(pthread_condattr_t *attr, int *pshared);
int pthread_condattr_setpshared(pthread_condattr_t* attr, int pshared);
int pthread_condattr_destroy(pthread_condattr_t *attr);

int pthread_cond_init(pthread_cond_t *cond,
                      const pthread_condattr_t *attr);
int pthread_cond_destroy(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);
int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);
int pthread_cond_timedwait(pthread_cond_t *cond,
                           pthread_mutex_t * mutex,
                           const struct timespec *abstime);





int pthread_cond_timedwait_monotonic_np(pthread_cond_t *cond,
                                        pthread_mutex_t *mutex,
                                        const struct timespec *abstime);




int pthread_cond_timedwait_monotonic(pthread_cond_t *cond,
                                     pthread_mutex_t *mutex,
                                     const struct timespec *abstime);






int pthread_cond_timedwait_relative_np(pthread_cond_t *cond,
                                     pthread_mutex_t *mutex,
                                     const struct timespec *reltime);





int pthread_cond_timeout_np(pthread_cond_t *cond,
                            pthread_mutex_t * mutex,
                            unsigned msecs);






int pthread_mutex_lock_timeout_np(pthread_mutex_t *mutex, unsigned msecs);



typedef int pthread_rwlockattr_t;

typedef struct {
    pthread_mutex_t lock;
    pthread_cond_t cond;
    int numLocks;
    int writerThreadId;
    int pendingReaders;
    int pendingWriters;
    void* reserved[4];
} pthread_rwlock_t;



int pthread_rwlockattr_init(pthread_rwlockattr_t *attr);
int pthread_rwlockattr_destroy(pthread_rwlockattr_t *attr);
int pthread_rwlockattr_setpshared(pthread_rwlockattr_t *attr, int pshared);
int pthread_rwlockattr_getpshared(pthread_rwlockattr_t *attr, int *pshared);

int pthread_rwlock_init(pthread_rwlock_t *rwlock, const pthread_rwlockattr_t *attr);
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);

int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_timedrdlock(pthread_rwlock_t *rwlock, const struct timespec *abs_timeout);

int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *rwlock, const struct timespec *abs_timeout);

int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);


int pthread_key_create(pthread_key_t *key, void (*destructor_function)(void *));
int pthread_key_delete (pthread_key_t);
int pthread_setspecific(pthread_key_t key, const void *value);
void *pthread_getspecific(pthread_key_t key);

int pthread_kill(pthread_t tid, int sig);
int pthread_sigmask(int how, const sigset_t *set, sigset_t *oset);

int pthread_getcpuclockid(pthread_t tid, clockid_t *clockid);

int pthread_once(pthread_once_t *once_control, void (*init_routine)(void));

int pthread_setname_np(pthread_t thid, const char *thname);

typedef void (*__pthread_cleanup_func_t)(void*);

typedef struct __pthread_cleanup_t {
    struct __pthread_cleanup_t* __cleanup_prev;
    __pthread_cleanup_func_t __cleanup_routine;
    void* __cleanup_arg;
} __pthread_cleanup_t;

extern void __pthread_cleanup_push(__pthread_cleanup_t* c,
                                    __pthread_cleanup_func_t routine,
                                    void* arg);

extern void __pthread_cleanup_pop(__pthread_cleanup_t* c,
                                   int execute);
# 312 "C:\\ndk/platforms/android-9/arch-arm/usr/include/pthread.h" 3
}
# 49 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/gthr-default.h" 2 3
# 60 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/gthr-default.h" 3
typedef pthread_t __gthread_t;
typedef pthread_key_t __gthread_key_t;
typedef pthread_once_t __gthread_once_t;
typedef pthread_mutex_t __gthread_mutex_t;
typedef pthread_mutex_t __gthread_recursive_mutex_t;
typedef pthread_cond_t __gthread_cond_t;
typedef struct timespec __gthread_time_t;
# 114 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/gthr-default.h" 3



































# 311 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/gthr-default.h" 3
static inline int
__gthread_active_p (void)
{
  return 1;
}
# 671 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/gthr-default.h" 3
static inline int
__gthread_create (__gthread_t *__threadid, void *(*__func) (void*),
    void *__args)
{
  return pthread_create (__threadid, __null, __func, __args);
}

static inline int
__gthread_join (__gthread_t __threadid, void **__value_ptr)
{
  return pthread_join (__threadid, __value_ptr);
}

static inline int
__gthread_detach (__gthread_t __threadid)
{
  return pthread_detach (__threadid);
}

static inline int
__gthread_equal (__gthread_t __t1, __gthread_t __t2)
{
  return pthread_equal (__t1, __t2);
}

static inline __gthread_t
__gthread_self (void)
{
  return pthread_self ();
}

static inline int
__gthread_yield (void)
{
  return sched_yield ();
}

static inline int
__gthread_once (__gthread_once_t *__once, void (*__func) (void))
{
  if (__gthread_active_p ())
    return pthread_once (__once, __func);
  else
    return -1;
}

static inline int
__gthread_key_create (__gthread_key_t *__key, void (*__dtor) (void *))
{
  return pthread_key_create (__key, __dtor);
}

static inline int
__gthread_key_delete (__gthread_key_t __key)
{
  return pthread_key_delete (__key);
}

static inline void *
__gthread_getspecific (__gthread_key_t __key)
{
  return pthread_getspecific (__key);
}

static inline int
__gthread_setspecific (__gthread_key_t __key, const void *__ptr)
{
  return pthread_setspecific (__key, __ptr);
}

static inline void
__gthread_mutex_init_function (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    pthread_mutex_init (__mutex, __null);
}

static inline int
__gthread_mutex_destroy (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_destroy (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_lock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_lock (__mutex);
  else
    return 0;
}

static inline int
__gthread_mutex_trylock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_trylock (__mutex);
  else
    return 0;
}
# 787 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/gthr-default.h" 3
static inline int
__gthread_mutex_unlock (__gthread_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    return pthread_mutex_unlock (__mutex);
  else
    return 0;
}



static inline int
__gthread_recursive_mutex_init_function (__gthread_recursive_mutex_t *__mutex)
{
  if (__gthread_active_p ())
    {
      pthread_mutexattr_t __attr;
      int __r;

      __r = pthread_mutexattr_init (&__attr);
      if (!__r)
 __r = pthread_mutexattr_settype (&__attr,
         PTHREAD_MUTEX_RECURSIVE);
      if (!__r)
 __r = pthread_mutex_init (__mutex, &__attr);
      if (!__r)
 __r = pthread_mutexattr_destroy (&__attr);
      return __r;
    }
  return 0;
}


static inline int
__gthread_recursive_mutex_lock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_lock (__mutex);
}

static inline int
__gthread_recursive_mutex_trylock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_trylock (__mutex);
}
# 841 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/gthr-default.h" 3
static inline int
__gthread_recursive_mutex_unlock (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_unlock (__mutex);
}

static inline int
__gthread_recursive_mutex_destroy (__gthread_recursive_mutex_t *__mutex)
{
  return __gthread_mutex_destroy (__mutex);
}
# 862 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/gthr-default.h" 3
static inline int
__gthread_cond_broadcast (__gthread_cond_t *__cond)
{
  return pthread_cond_broadcast (__cond);
}

static inline int
__gthread_cond_signal (__gthread_cond_t *__cond)
{
  return pthread_cond_signal (__cond);
}

static inline int
__gthread_cond_wait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex)
{
  return pthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_timedwait (__gthread_cond_t *__cond, __gthread_mutex_t *__mutex,
     const __gthread_time_t *__abs_timeout)
{
  return pthread_cond_timedwait (__cond, __mutex, __abs_timeout);
}

static inline int
__gthread_cond_wait_recursive (__gthread_cond_t *__cond,
          __gthread_recursive_mutex_t *__mutex)
{
  return __gthread_cond_wait (__cond, __mutex);
}

static inline int
__gthread_cond_destroy (__gthread_cond_t* __cond)
{
  return pthread_cond_destroy (__cond);
}
# 149 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/gthr.h" 2 3


#pragma GCC visibility pop
# 36 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/atomicity.h" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/atomic_word.h" 1 3
# 32 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/libs/armeabi-v7a/include/bits/atomic_word.h" 3
typedef int _Atomic_word;
# 37 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/atomicity.h" 2 3

namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  static inline _Atomic_word
  __exchange_and_add(volatile _Atomic_word* __mem, int __val)
  { return __atomic_fetch_add(__mem, __val, 4); }

  static inline void
  __atomic_add(volatile _Atomic_word* __mem, int __val)
  { __atomic_fetch_add(__mem, __val, 4); }
# 64 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/atomicity.h" 3
  static inline _Atomic_word
  __exchange_and_add_single(_Atomic_word* __mem, int __val)
  {
    _Atomic_word __result = *__mem;
    *__mem += __val;
    return __result;
  }

  static inline void
  __atomic_add_single(_Atomic_word* __mem, int __val)
  { *__mem += __val; }

  static inline _Atomic_word
  __attribute__ ((__unused__))
  __exchange_and_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      return __exchange_and_add(__mem, __val);
    else
      return __exchange_and_add_single(__mem, __val);



  }

  static inline void
  __attribute__ ((__unused__))
  __atomic_add_dispatch(_Atomic_word* __mem, int __val)
  {

    if (__gthread_active_p())
      __atomic_add(__mem, __val);
    else
      __atomic_add_single(__mem, __val);



  }


}
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 2 3





namespace std __attribute__ ((__visibility__ ("default")))
{

# 111 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    class basic_string
    {
      typedef typename _Alloc::template rebind<_CharT>::other _CharT_alloc_type;


    public:
      typedef _Traits traits_type;
      typedef typename _Traits::char_type value_type;
      typedef _Alloc allocator_type;
      typedef typename _CharT_alloc_type::size_type size_type;
      typedef typename _CharT_alloc_type::difference_type difference_type;
      typedef typename _CharT_alloc_type::reference reference;
      typedef typename _CharT_alloc_type::const_reference const_reference;
      typedef typename _CharT_alloc_type::pointer pointer;
      typedef typename _CharT_alloc_type::const_pointer const_pointer;
      typedef __gnu_cxx::__normal_iterator<pointer, basic_string> iterator;
      typedef __gnu_cxx::__normal_iterator<const_pointer, basic_string>
                                                            const_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;
      typedef std::reverse_iterator<iterator> reverse_iterator;

    private:
# 148 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      struct _Rep_base
      {
 size_type _M_length;
 size_type _M_capacity;
 _Atomic_word _M_refcount;
      };

      struct _Rep : _Rep_base
      {

 typedef typename _Alloc::template rebind<char>::other _Raw_bytes_alloc;
# 173 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
 static const size_type _S_max_size;
 static const _CharT _S_terminal;



        static size_type _S_empty_rep_storage[];

        static _Rep&
        _S_empty_rep() noexcept
        {



   void* __p = reinterpret_cast<void*>(&_S_empty_rep_storage);
   return *reinterpret_cast<_Rep*>(__p);
 }

        bool
 _M_is_leaked() const noexcept
        { return this->_M_refcount < 0; }

        bool
 _M_is_shared() const noexcept
        { return this->_M_refcount > 0; }

        void
 _M_set_leaked() noexcept
        { this->_M_refcount = -1; }

        void
 _M_set_sharable() noexcept
        { this->_M_refcount = 0; }

 void
 _M_set_length_and_sharable(size_type __n) noexcept
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {
       this->_M_set_sharable();
       this->_M_length = __n;
       traits_type::assign(this->_M_refdata()[__n], _S_terminal);


     }
 }

 _CharT*
 _M_refdata() throw()
 { return reinterpret_cast<_CharT*>(this + 1); }

 _CharT*
 _M_grab(const _Alloc& __alloc1, const _Alloc& __alloc2)
 {
   return (!_M_is_leaked() && __alloc1 == __alloc2)
           ? _M_refcopy() : _M_clone(__alloc1);
 }


 static _Rep*
 _S_create(size_type, size_type, const _Alloc&);

 void
 _M_dispose(const _Alloc& __a) noexcept
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

     {

       ;
       if (__gnu_cxx::__exchange_and_add_dispatch(&this->_M_refcount,
        -1) <= 0)
  {
    ;
    _M_destroy(__a);
  }
     }
 }

 void
 _M_destroy(const _Alloc&) throw();

 _CharT*
 _M_refcopy() throw()
 {

   if (__builtin_expect(this != &_S_empty_rep(), false))

            __gnu_cxx::__atomic_add_dispatch(&this->_M_refcount, 1);
   return _M_refdata();
 }

 _CharT*
 _M_clone(const _Alloc&, size_type __res = 0);
      };


      struct _Alloc_hider : _Alloc
      {
 _Alloc_hider(_CharT* __dat, const _Alloc& __a) noexcept
 : _Alloc(__a), _M_p(__dat) { }

 _CharT* _M_p;
      };

    public:




      static const size_type npos = static_cast<size_type>(-1);

    private:

      mutable _Alloc_hider _M_dataplus;

      _CharT*
      _M_data() const noexcept
      { return _M_dataplus._M_p; }

      _CharT*
      _M_data(_CharT* __p) noexcept
      { return (_M_dataplus._M_p = __p); }

      _Rep*
      _M_rep() const noexcept
      { return &((reinterpret_cast<_Rep*> (_M_data()))[-1]); }



      iterator
      _M_ibegin() const noexcept
      { return iterator(_M_data()); }

      iterator
      _M_iend() const noexcept
      { return iterator(_M_data() + this->size()); }

      void
      _M_leak()
      {
 if (!_M_rep()->_M_is_leaked())
   _M_leak_hard();
      }

      size_type
      _M_check(size_type __pos, const char* __s) const
      {
 if (__pos > this->size())
   __throw_out_of_range_fmt(("%s: __pos (which is %zu) > " "this->size() (which is %zu)")
                                         ,
       __s, __pos, this->size());
 return __pos;
      }

      void
      _M_check_length(size_type __n1, size_type __n2, const char* __s) const
      {
 if (this->max_size() - (this->size() - __n1) < __n2)
   __throw_length_error((__s));
      }


      size_type
      _M_limit(size_type __pos, size_type __off) const noexcept
      {
 const bool __testoff = __off < this->size() - __pos;
 return __testoff ? __off : this->size() - __pos;
      }


      bool
      _M_disjunct(const _CharT* __s) const noexcept
      {
 return (less<const _CharT*>()(__s, _M_data())
  || less<const _CharT*>()(_M_data() + this->size(), __s));
      }



      static void
      _M_copy(_CharT* __d, const _CharT* __s, size_type __n) noexcept
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::copy(__d, __s, __n);
      }

      static void
      _M_move(_CharT* __d, const _CharT* __s, size_type __n) noexcept
      {
 if (__n == 1)
   traits_type::assign(*__d, *__s);
 else
   traits_type::move(__d, __s, __n);
      }

      static void
      _M_assign(_CharT* __d, size_type __n, _CharT __c) noexcept
      {
 if (__n == 1)
   traits_type::assign(*__d, __c);
 else
   traits_type::assign(__d, __n, __c);
      }



      template<class _Iterator>
        static void
        _S_copy_chars(_CharT* __p, _Iterator __k1, _Iterator __k2)
 noexcept
        {
   for (; __k1 != __k2; ++__k1, ++__p)
     traits_type::assign(*__p, *__k1);
 }

      static void
      _S_copy_chars(_CharT* __p, iterator __k1, iterator __k2) noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, const_iterator __k1, const_iterator __k2)
      noexcept
      { _S_copy_chars(__p, __k1.base(), __k2.base()); }

      static void
      _S_copy_chars(_CharT* __p, _CharT* __k1, _CharT* __k2) noexcept
      { _M_copy(__p, __k1, __k2 - __k1); }

      static void
      _S_copy_chars(_CharT* __p, const _CharT* __k1, const _CharT* __k2)
      noexcept
      { _M_copy(__p, __k1, __k2 - __k1); }

      static int
      _S_compare(size_type __n1, size_type __n2) noexcept
      {
 const difference_type __d = difference_type(__n1 - __n2);

 if (__d > __gnu_cxx::__numeric_traits<int>::__max)
   return __gnu_cxx::__numeric_traits<int>::__max;
 else if (__d < __gnu_cxx::__numeric_traits<int>::__min)
   return __gnu_cxx::__numeric_traits<int>::__min;
 else
   return int(__d);
      }

      void
      _M_mutate(size_type __pos, size_type __len1, size_type __len2);

      void
      _M_leak_hard();

      static _Rep&
      _S_empty_rep() noexcept
      { return _Rep::_S_empty_rep(); }

    public:







      basic_string()

      : _M_dataplus(_S_empty_rep()._M_refdata(), _Alloc()) { }







      explicit
      basic_string(const _Alloc& __a);






      basic_string(const basic_string& __str);






      basic_string(const basic_string& __str, size_type __pos,
     size_type __n = npos);







      basic_string(const basic_string& __str, size_type __pos,
     size_type __n, const _Alloc& __a);
# 488 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string(const _CharT* __s, size_type __n,
     const _Alloc& __a = _Alloc());





      basic_string(const _CharT* __s, const _Alloc& __a = _Alloc());






      basic_string(size_type __n, _CharT __c, const _Alloc& __a = _Alloc());
# 512 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string(basic_string&& __str)

      noexcept

      : _M_dataplus(__str._M_dataplus)
      {

 __str._M_data(_S_empty_rep()._M_refdata());



      }






      basic_string(initializer_list<_CharT> __l, const _Alloc& __a = _Alloc());
# 539 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string(_InputIterator __beg, _InputIterator __end,
       const _Alloc& __a = _Alloc());




      ~basic_string() noexcept
      { _M_rep()->_M_dispose(this->get_allocator()); }





      basic_string&
      operator=(const basic_string& __str)
      { return this->assign(__str); }





      basic_string&
      operator=(const _CharT* __s)
      { return this->assign(__s); }
# 572 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      operator=(_CharT __c)
      {
 this->assign(1, __c);
 return *this;
      }
# 588 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      operator=(basic_string&& __str)
      {

 this->swap(__str);
 return *this;
      }





      basic_string&
      operator=(initializer_list<_CharT> __l)
      {
 this->assign(__l.begin(), __l.size());
 return *this;
      }







      iterator
      begin()
      {
 _M_leak();
 return iterator(_M_data());
      }





      const_iterator
      begin() const noexcept
      { return const_iterator(_M_data()); }





      iterator
      end()
      {
 _M_leak();
 return iterator(_M_data() + this->size());
      }





      const_iterator
      end() const noexcept
      { return const_iterator(_M_data() + this->size()); }






      reverse_iterator
      rbegin()
      { return reverse_iterator(this->end()); }






      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      reverse_iterator
      rend()
      { return reverse_iterator(this->begin()); }






      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(this->begin()); }






      const_iterator
      cbegin() const noexcept
      { return const_iterator(this->_M_data()); }





      const_iterator
      cend() const noexcept
      { return const_iterator(this->_M_data() + this->size()); }






      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(this->end()); }






      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(this->begin()); }


    public:



      size_type
      size() const noexcept
      { return _M_rep()->_M_length; }



      size_type
      length() const noexcept
      { return _M_rep()->_M_length; }


      size_type
      max_size() const noexcept
      { return _Rep::_S_max_size; }
# 748 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      void
      resize(size_type __n, _CharT __c);
# 761 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      void
      resize(size_type __n)
      { this->resize(__n, _CharT()); }



      void
      shrink_to_fit() noexcept
      {
 if (capacity() > size())
   {
     try
       { reserve(0); }
     catch(...)
       { }
   }
      }






      size_type
      capacity() const noexcept
      { return _M_rep()->_M_capacity; }
# 805 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      void
      reserve(size_type __res_arg = 0);





      void
      clear()
      { _M_mutate(0, this->size(), 0); }





      bool
      empty() const noexcept
      { return this->size() == 0; }
# 835 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      const_reference
      operator[] (size_type __pos) const noexcept
      {
 ;
 return _M_data()[__pos];
      }
# 852 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      reference
      operator[](size_type __pos)
      {


 ;

 ;
 _M_leak();
 return _M_data()[__pos];
      }
# 874 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      const_reference
      at(size_type __n) const
      {
 if (__n >= this->size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 return _M_data()[__n];
      }
# 896 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      reference
      at(size_type __n)
      {
 if (__n >= size())
   __throw_out_of_range_fmt(("basic_string::at: __n " "(which is %zu) >= this->size() " "(which is %zu)")

                            ,
       __n, this->size());
 _M_leak();
 return _M_data()[__n];
      }






      reference
      front()
      { return operator[](0); }





      const_reference
      front() const noexcept
      { return operator[](0); }





      reference
      back()
      { return operator[](this->size() - 1); }





      const_reference
      back() const noexcept
      { return operator[](this->size() - 1); }
# 948 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      operator+=(const basic_string& __str)
      { return this->append(__str); }






      basic_string&
      operator+=(const _CharT* __s)
      { return this->append(__s); }






      basic_string&
      operator+=(_CharT __c)
      {
 this->push_back(__c);
 return *this;
      }







      basic_string&
      operator+=(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }







      basic_string&
      append(const basic_string& __str);
# 1005 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      append(const basic_string& __str, size_type __pos, size_type __n);







      basic_string&
      append(const _CharT* __s, size_type __n);






      basic_string&
      append(const _CharT* __s)
      {
 ;
 return this->append(__s, traits_type::length(__s));
      }
# 1037 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      append(size_type __n, _CharT __c);







      basic_string&
      append(initializer_list<_CharT> __l)
      { return this->append(__l.begin(), __l.size()); }
# 1059 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        append(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_iend(), _M_iend(), __first, __last); }





      void
      push_back(_CharT __c)
      {
 const size_type __len = 1 + this->size();
 if (__len > this->capacity() || _M_rep()->_M_is_shared())
   this->reserve(__len);
 traits_type::assign(_M_data()[this->size()], __c);
 _M_rep()->_M_set_length_and_sharable(__len);
      }






      basic_string&
      assign(const basic_string& __str);
# 1096 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      assign(basic_string&& __str)
      {
 this->swap(__str);
 return *this;
      }
# 1117 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      assign(const basic_string& __str, size_type __pos, size_type __n)
      { return this->assign(__str._M_data()
       + __str._M_check(__pos, "basic_string::assign"),
       __str._M_limit(__pos, __n)); }
# 1133 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s, size_type __n);
# 1145 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      assign(const _CharT* __s)
      {
 ;
 return this->assign(__s, traits_type::length(__s));
      }
# 1161 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      assign(size_type __n, _CharT __c)
      { return _M_replace_aux(size_type(0), this->size(), __n, __c); }
# 1173 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        assign(_InputIterator __first, _InputIterator __last)
        { return this->replace(_M_ibegin(), _M_iend(), __first, __last); }







      basic_string&
      assign(initializer_list<_CharT> __l)
      { return this->assign(__l.begin(), __l.size()); }
# 1202 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      void
      insert(iterator __p, size_type __n, _CharT __c)
      { this->replace(__p, __p, __n, __c); }
# 1218 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      template<class _InputIterator>
        void
        insert(iterator __p, _InputIterator __beg, _InputIterator __end)
        { this->replace(__p, __p, __beg, __end); }
# 1230 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      void
      insert(iterator __p, initializer_list<_CharT> __l)
      {
 ;
 this->insert(__p - _M_ibegin(), __l.begin(), __l.size());
      }
# 1250 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str)
      { return this->insert(__pos1, __str, size_type(0), __str.size()); }
# 1272 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos1, const basic_string& __str,
      size_type __pos2, size_type __n)
      { return this->insert(__pos1, __str._M_data()
       + __str._M_check(__pos2, "basic_string::insert"),
       __str._M_limit(__pos2, __n)); }
# 1295 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s, size_type __n);
# 1313 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, const _CharT* __s)
      {
 ;
 return this->insert(__pos, __s, traits_type::length(__s));
      }
# 1336 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      insert(size_type __pos, size_type __n, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::insert"),
         size_type(0), __n, __c); }
# 1354 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      iterator
      insert(iterator __p, _CharT __c)
      {
 ;
 const size_type __pos = __p - _M_ibegin();
 _M_replace_aux(__pos, size_type(0), size_type(1), __c);
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1379 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      erase(size_type __pos = 0, size_type __n = npos)
      {
 _M_mutate(_M_check(__pos, "basic_string::erase"),
    _M_limit(__pos, __n), size_type(0));
 return *this;
      }
# 1395 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      iterator
      erase(iterator __position)
      {

                               ;
 const size_type __pos = __position - _M_ibegin();
 _M_mutate(__pos, size_type(1), size_type(0));
 _M_rep()->_M_set_leaked();
 return iterator(_M_data() + __pos);
      }
# 1415 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      iterator
      erase(iterator __first, iterator __last);







      void
      pop_back()
      { erase(size()-1, 1); }
# 1446 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n, const basic_string& __str)
      { return this->replace(__pos, __n, __str._M_data(), __str.size()); }
# 1468 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2)
      { return this->replace(__pos1, __n1, __str._M_data()
        + __str._M_check(__pos2, "basic_string::replace"),
        __str._M_limit(__pos2, __n2)); }
# 1493 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2);
# 1513 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, const _CharT* __s)
      {
 ;
 return this->replace(__pos, __n1, __s, traits_type::length(__s));
      }
# 1537 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)
      { return _M_replace_aux(_M_check(__pos, "basic_string::replace"),
         _M_limit(__pos, __n1), __n2, __c); }
# 1555 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const basic_string& __str)
      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }
# 1574 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)
      {

                          ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n);
      }
# 1595 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, const _CharT* __s)
      {
 ;
 return this->replace(__i1, __i2, __s, traits_type::length(__s));
      }
# 1616 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string&
      replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)
      {

                          ;
 return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __c);
      }
# 1639 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      template<class _InputIterator>
        basic_string&
        replace(iterator __i1, iterator __i2,
  _InputIterator __k1, _InputIterator __k2)
        {
  
                            ;
   ;
   typedef typename std::__is_integer<_InputIterator>::__type _Integral;
   return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral());
 }



      basic_string&
      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const _CharT* __k1, const _CharT* __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1, __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }

      basic_string&
      replace(iterator __i1, iterator __i2,
       const_iterator __k1, const_iterator __k2)
      {

                          ;
 ;
 return this->replace(__i1 - _M_ibegin(), __i2 - __i1,
        __k1.base(), __k2 - __k1);
      }
# 1710 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string& replace(iterator __i1, iterator __i2,
       initializer_list<_CharT> __l)
      { return this->replace(__i1, __i2, __l.begin(), __l.end()); }


    private:
      template<class _Integer>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _Integer __n,
       _Integer __val, __true_type)
        { return _M_replace_aux(__i1 - _M_ibegin(), __i2 - __i1, __n, __val); }

      template<class _InputIterator>
 basic_string&
 _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
       _InputIterator __k2, __false_type);

      basic_string&
      _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
       _CharT __c);

      basic_string&
      _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
        size_type __n2);



      template<class _InIterator>
        static _CharT*
        _S_construct_aux(_InIterator __beg, _InIterator __end,
    const _Alloc& __a, __false_type)
 {
          typedef typename iterator_traits<_InIterator>::iterator_category _Tag;
          return _S_construct(__beg, __end, __a, _Tag());
 }



      template<class _Integer>
        static _CharT*
        _S_construct_aux(_Integer __beg, _Integer __end,
    const _Alloc& __a, __true_type)
        { return _S_construct_aux_2(static_cast<size_type>(__beg),
        __end, __a); }

      static _CharT*
      _S_construct_aux_2(size_type __req, _CharT __c, const _Alloc& __a)
      { return _S_construct(__req, __c, __a); }

      template<class _InIterator>
        static _CharT*
        _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a)
 {
   typedef typename std::__is_integer<_InIterator>::__type _Integral;
   return _S_construct_aux(__beg, __end, __a, _Integral());
        }


      template<class _InIterator>
        static _CharT*
         _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
        input_iterator_tag);



      template<class _FwdIterator>
        static _CharT*
        _S_construct(_FwdIterator __beg, _FwdIterator __end, const _Alloc& __a,
       forward_iterator_tag);

      static _CharT*
      _S_construct(size_type __req, _CharT __c, const _Alloc& __a);

    public:
# 1797 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      copy(_CharT* __s, size_type __n, size_type __pos = 0) const;
# 1808 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      void
      swap(basic_string& __s);
# 1818 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      const _CharT*
      c_str() const noexcept
      { return _M_data(); }







      const _CharT*
      data() const noexcept
      { return _M_data(); }




      allocator_type
      get_allocator() const noexcept
      { return _M_dataplus; }
# 1851 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos, size_type __n) const;
# 1864 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find(__str.data(), __pos, __str.size()); }
# 1879 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find(__s, __pos, traits_type::length(__s));
      }
# 1896 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find(_CharT __c, size_type __pos = 0) const noexcept;
# 1909 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      rfind(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->rfind(__str.data(), __pos, __str.size()); }
# 1926 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos, size_type __n) const;
# 1939 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      rfind(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->rfind(__s, __pos, traits_type::length(__s));
      }
# 1956 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      rfind(_CharT __c, size_type __pos = npos) const noexcept;
# 1970 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find_first_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_of(__str.data(), __pos, __str.size()); }
# 1987 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2000 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find_first_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_of(__s, __pos, traits_type::length(__s));
      }
# 2019 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find_first_of(_CharT __c, size_type __pos = 0) const noexcept
      { return this->find(__c, __pos); }
# 2034 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find_last_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_of(__str.data(), __pos, __str.size()); }
# 2051 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos, size_type __n) const;
# 2064 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find_last_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_of(__s, __pos, traits_type::length(__s));
      }
# 2083 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find_last_of(_CharT __c, size_type __pos = npos) const noexcept
      { return this->rfind(__c, __pos); }
# 2097 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find_first_not_of(const basic_string& __str, size_type __pos = 0) const
 noexcept
      { return this->find_first_not_of(__str.data(), __pos, __str.size()); }
# 2114 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos,
   size_type __n) const;
# 2128 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find_first_not_of(const _CharT* __s, size_type __pos = 0) const
      {
 ;
 return this->find_first_not_of(__s, __pos, traits_type::length(__s));
      }
# 2145 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find_first_not_of(_CharT __c, size_type __pos = 0) const
 noexcept;
# 2160 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find_last_not_of(const basic_string& __str, size_type __pos = npos) const
 noexcept
      { return this->find_last_not_of(__str.data(), __pos, __str.size()); }
# 2177 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos,
         size_type __n) const;
# 2191 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find_last_not_of(const _CharT* __s, size_type __pos = npos) const
      {
 ;
 return this->find_last_not_of(__s, __pos, traits_type::length(__s));
      }
# 2208 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      size_type
      find_last_not_of(_CharT __c, size_type __pos = npos) const
 noexcept;
# 2224 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      basic_string
      substr(size_type __pos = 0, size_type __n = npos) const
      { return basic_string(*this,
       _M_check(__pos, "basic_string::substr"), __n); }
# 2243 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      int
      compare(const basic_string& __str) const
      {
 const size_type __size = this->size();
 const size_type __osize = __str.size();
 const size_type __len = std::min(__size, __osize);

 int __r = traits_type::compare(_M_data(), __str.data(), __len);
 if (!__r)
   __r = _S_compare(__size, __osize);
 return __r;
      }
# 2275 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n, const basic_string& __str) const;
# 2301 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      int
      compare(size_type __pos1, size_type __n1, const basic_string& __str,
       size_type __pos2, size_type __n2) const;
# 2319 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      int
      compare(const _CharT* __s) const;
# 2343 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s) const;
# 2370 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
      int
      compare(size_type __pos, size_type __n1, const _CharT* __s,
       size_type __n2) const;
  };
# 2382 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT,_Traits,_Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Alloc>& __rhs);







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
      const _CharT* __rhs)
    {
      basic_string<_CharT, _Traits, _Alloc> __str(__lhs);
      __str.append(__rhs);
      return __str;
    }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs, _CharT __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str(__lhs);
      __str.append(__size_type(1), __rhs);
      return __str;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    {
      const auto __size = __lhs.size() + __rhs.size();
      const bool __cond = (__size > __lhs.capacity()
      && __size <= __rhs.capacity());
      return __cond ? std::move(__rhs.insert(0, __lhs))
             : std::move(__lhs.append(__rhs));
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs,
       basic_string<_CharT, _Traits, _Alloc>&& __rhs)
    { return std::move(__rhs.insert(0, 1, __lhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       const _CharT* __rhs)
    { return std::move(__lhs.append(__rhs)); }

  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_string<_CharT, _Traits, _Alloc>
    operator+(basic_string<_CharT, _Traits, _Alloc>&& __lhs,
       _CharT __rhs)
    { return std::move(__lhs.append(1, __rhs)); }
# 2503 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) == 0; }

  template<typename _CharT>
    inline
    typename __gnu_cxx::__enable_if<__is_char<_CharT>::__value, bool>::__type
    operator==(const basic_string<_CharT>& __lhs,
        const basic_string<_CharT>& __rhs)
    { return (__lhs.size() == __rhs.size()
       && !std::char_traits<_CharT>::compare(__lhs.data(), __rhs.data(),
          __lhs.size())); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) == 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator==(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) == 0; }
# 2549 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return !(__lhs == __rhs); }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator!=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return !(__lhs == __rhs); }
# 2586 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) < 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) > 0; }
# 2623 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
       const _CharT* __rhs)
    { return __lhs.compare(__rhs) > 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) < 0; }
# 2660 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) <= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator<=(const _CharT* __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) >= 0; }
# 2697 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const basic_string<_CharT, _Traits, _Alloc>& __lhs,
        const _CharT* __rhs)
    { return __lhs.compare(__rhs) >= 0; }







  template<typename _CharT, typename _Traits, typename _Alloc>
    inline bool
    operator>=(const _CharT* __lhs,
      const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { return __rhs.compare(__lhs) <= 0; }
# 2734 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline void
    swap(basic_string<_CharT, _Traits, _Alloc>& __lhs,
  basic_string<_CharT, _Traits, _Alloc>& __rhs)
    { __lhs.swap(__rhs); }
# 2752 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __is,
        basic_string<_CharT, _Traits, _Alloc>& __str);

  template<>
    basic_istream<char>&
    operator>>(basic_istream<char>& __is, basic_string<char>& __str);
# 2770 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __os,
        const basic_string<_CharT, _Traits, _Alloc>& __str)
    {


      return __ostream_insert(__os, __str.data(), __str.size());
    }
# 2793 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim);
# 2810 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str, __is.widen('\n')); }



  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    { return std::getline(__is, __str, __delim); }


  template<typename _CharT, typename _Traits, typename _Alloc>
    inline basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>&& __is,
     basic_string<_CharT, _Traits, _Alloc>& __str)
    { return std::getline(__is, __str); }


  template<>
    basic_istream<char>&
    getline(basic_istream<char>& __in, basic_string<char>& __str,
     char __delim);


  template<>
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>& __in, basic_string<wchar_t>& __str,
     wchar_t __delim);



}
# 3068 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/functional_hash.h" 1 3
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/functional_hash.h" 3
       
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/functional_hash.h" 3



namespace std __attribute__ ((__visibility__ ("default")))
{

# 49 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/functional_hash.h" 3
  template<typename _Result, typename _Arg>
    struct __hash_base
    {
      typedef _Result result_type;
      typedef _Arg argument_type;
    };


  template<typename _Tp>
    struct hash;


  template<typename _Tp>
    struct hash<_Tp*> : public __hash_base<size_t, _Tp*>
    {
      size_t
      operator()(_Tp* __p) const noexcept
      { return reinterpret_cast<size_t>(__p); }
    };
# 80 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/functional_hash.h" 3
  template<> struct hash<bool> : public __hash_base<size_t, bool> { size_t operator()(bool __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char> : public __hash_base<size_t, char> { size_t operator()(char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<signed char> : public __hash_base<size_t, signed char> { size_t operator()(signed char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned char> : public __hash_base<size_t, unsigned char> { size_t operator()(unsigned char __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<wchar_t> : public __hash_base<size_t, wchar_t> { size_t operator()(wchar_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char16_t> : public __hash_base<size_t, char16_t> { size_t operator()(char16_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<char32_t> : public __hash_base<size_t, char32_t> { size_t operator()(char32_t __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<short> : public __hash_base<size_t, short> { size_t operator()(short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<int> : public __hash_base<size_t, int> { size_t operator()(int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long> : public __hash_base<size_t, long> { size_t operator()(long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<long long> : public __hash_base<size_t, long long> { size_t operator()(long long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned short> : public __hash_base<size_t, unsigned short> { size_t operator()(unsigned short __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned int> : public __hash_base<size_t, unsigned int> { size_t operator()(unsigned int __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long> : public __hash_base<size_t, unsigned long> { size_t operator()(unsigned long __val) const noexcept { return static_cast<size_t>(__val); } };


  template<> struct hash<unsigned long long> : public __hash_base<size_t, unsigned long long> { size_t operator()(unsigned long long __val) const noexcept { return static_cast<size_t>(__val); } };



  struct _Hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(0xc70f6907UL))
    { return _Hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };

  struct _Fnv_hash_impl
  {
    static size_t
    hash(const void* __ptr, size_t __clength,
  size_t __seed = static_cast<size_t>(2166136261UL))
    { return _Fnv_hash_bytes(__ptr, __clength, __seed); }

    template<typename _Tp>
      static size_t
      hash(const _Tp& __val)
      { return hash(&__val, sizeof(__val)); }

    template<typename _Tp>
      static size_t
      __hash_combine(const _Tp& __val, size_t __hash)
      { return hash(&__val, sizeof(__val), __hash); }
  };


  template<>
    struct hash<float> : public __hash_base<size_t, float>
    {
      size_t
      operator()(float __val) const noexcept
      {

 return __val != 0.0f ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<double> : public __hash_base<size_t, double>
    {
      size_t
      operator()(double __val) const noexcept
      {

 return __val != 0.0 ? std::_Hash_impl::hash(__val) : 0;
      }
    };


  template<>
    struct hash<long double>
    : public __hash_base<size_t, long double>
    {
      __attribute__ ((__pure__)) size_t
      operator()(long double __val) const noexcept;
    };







  template<typename _Hash>
    struct __is_fast_hash : public std::true_type
    { };

  template<>
    struct __is_fast_hash<hash<long double>> : public std::false_type
    { };


}
# 3069 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{






  template<>
    struct hash<string>
    : public __hash_base<size_t, string>
    {
      size_t
      operator()(const string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(), __s.length()); }
    };

  template<>
    struct __is_fast_hash<hash<string>> : std::false_type
    { };



  template<>
    struct hash<wstring>
    : public __hash_base<size_t, wstring>
    {
      size_t
      operator()(const wstring& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(wchar_t)); }
    };

  template<>
    struct __is_fast_hash<hash<wstring>> : std::false_type
    { };





  template<>
    struct hash<u16string>
    : public __hash_base<size_t, u16string>
    {
      size_t
      operator()(const u16string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char16_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u16string>> : std::false_type
    { };


  template<>
    struct hash<u32string>
    : public __hash_base<size_t, u32string>
    {
      size_t
      operator()(const u32string& __s) const noexcept
      { return std::_Hash_impl::hash(__s.data(),
                                     __s.length() * sizeof(char32_t)); }
    };

  template<>
    struct __is_fast_hash<hash<u32string>> : std::false_type
    { };
# 3173 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.h" 3

}
# 53 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/string" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.tcc" 1 3
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.tcc" 3
       
# 41 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.tcc" 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_max_size = (((npos - sizeof(_Rep_base))/sizeof(_CharT)) - 1) / 4;

  template<typename _CharT, typename _Traits, typename _Alloc>
    const _CharT
    basic_string<_CharT, _Traits, _Alloc>::
    _Rep::_S_terminal = _CharT();

  template<typename _CharT, typename _Traits, typename _Alloc>
    const typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::npos;



  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::_Rep::_S_empty_rep_storage[
    (sizeof(_Rep_base) + sizeof(_CharT) + sizeof(size_type) - 1) /
      sizeof(size_type)];





  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     input_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 _CharT __buf[128];
 size_type __len = 0;
 while (__beg != __end && __len < sizeof(__buf) / sizeof(_CharT))
   {
     __buf[__len++] = *__beg;
     ++__beg;
   }
 _Rep* __r = _Rep::_S_create(__len, size_type(0), __a);
 _M_copy(__r->_M_refdata(), __buf, __len);
 try
   {
     while (__beg != __end)
       {
  if (__len == __r->_M_capacity)
    {

      _Rep* __another = _Rep::_S_create(__len + 1, __len, __a);
      _M_copy(__another->_M_refdata(), __r->_M_refdata(), __len);
      __r->_M_destroy(__a);
      __r = __another;
    }
  __r->_M_refdata()[__len++] = *__beg;
  ++__beg;
       }
   }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__len);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template <typename _InIterator>
      _CharT*
      basic_string<_CharT, _Traits, _Alloc>::
      _S_construct(_InIterator __beg, _InIterator __end, const _Alloc& __a,
     forward_iterator_tag)
      {

 if (__beg == __end && __a == _Alloc())
   return _S_empty_rep()._M_refdata();


 if (__gnu_cxx::__is_null_pointer(__beg) && __beg != __end)
   __throw_logic_error(("basic_string::_S_construct null not valid"));

 const size_type __dnew = static_cast<size_type>(std::distance(__beg,
              __end));

 _Rep* __r = _Rep::_S_create(__dnew, size_type(0), __a);
 try
   { _S_copy_chars(__r->_M_refdata(), __beg, __end); }
 catch(...)
   {
     __r->_M_destroy(__a);
     throw;
   }
 __r->_M_set_length_and_sharable(__dnew);
 return __r->_M_refdata();
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::
    _S_construct(size_type __n, _CharT __c, const _Alloc& __a)
    {

      if (__n == 0 && __a == _Alloc())
 return _S_empty_rep()._M_refdata();


      _Rep* __r = _Rep::_S_create(__n, size_type(0), __a);
      if (__n)
 _M_assign(__r->_M_refdata(), __n, __c);

      __r->_M_set_length_and_sharable(__n);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str)
    : _M_dataplus(__str._M_rep()->_M_grab(_Alloc(__str.get_allocator()),
       __str.get_allocator()),
    __str.get_allocator())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _Alloc& __a)
    : _M_dataplus(_S_construct(size_type(), _CharT(), __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos, size_type __n)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, _Alloc()), _Alloc())
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const basic_string& __str, size_type __pos,
   size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__str._M_data()
          + __str._M_check(__pos,
      "basic_string::basic_string"),
          __str._M_data() + __str._M_limit(__pos, __n)
          + __pos, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(const _CharT* __s, const _Alloc& __a)
    : _M_dataplus(_S_construct(__s, __s ? __s + traits_type::length(__s) :
          __s + npos, __a), __a)
    { }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(size_type __n, _CharT __c, const _Alloc& __a)
    : _M_dataplus(_S_construct(__n, __c, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(_InputIterator __beg, _InputIterator __end, const _Alloc& __a)
    : _M_dataplus(_S_construct(__beg, __end, __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>::
    basic_string(initializer_list<_CharT> __l, const _Alloc& __a)
    : _M_dataplus(_S_construct(__l.begin(), __l.end(), __a), __a)
    { }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const basic_string& __str)
    {
      if (_M_rep() != __str._M_rep())
 {

   const allocator_type __a = this->get_allocator();
   _CharT* __tmp = __str._M_rep()->_M_grab(__a, __str.get_allocator());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    assign(const _CharT* __s, size_type __n)
    {
      ;
      _M_check_length(this->size(), __n, "basic_string::assign");
      if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
 return _M_replace_safe(size_type(0), this->size(), __s, __n);
      else
 {

   const size_type __pos = __s - _M_data();
   if (__pos >= __n)
     _M_copy(_M_data(), __s, __n);
   else if (__pos)
     _M_move(_M_data(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__n);
   return *this;
 }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(size_type __n, _CharT __c)
    {
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_assign(_M_data() + this->size(), __n, __c);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const _CharT* __s, size_type __n)
    {
      ;
      if (__n)
 {
   _M_check_length(size_type(0), __n, "basic_string::append");
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     {
       if (_M_disjunct(__s))
  this->reserve(__len);
       else
  {
    const size_type __off = __s - _M_data();
    this->reserve(__len);
    __s = _M_data() + __off;
  }
     }
   _M_copy(_M_data() + this->size(), __s, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str)
    {
      const size_type __size = __str.size();
      if (__size)
 {
   const size_type __len = __size + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data(), __size);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    append(const basic_string& __str, size_type __pos, size_type __n)
    {
      __str._M_check(__pos, "basic_string::append");
      __n = __str._M_limit(__pos, __n);
      if (__n)
 {
   const size_type __len = __n + this->size();
   if (__len > this->capacity() || _M_rep()->_M_is_shared())
     this->reserve(__len);
   _M_copy(_M_data() + this->size(), __str._M_data() + __pos, __n);
   _M_rep()->_M_set_length_and_sharable(__len);
 }
      return *this;
    }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     insert(size_type __pos, const _CharT* __s, size_type __n)
     {
       ;
       _M_check(__pos, "basic_string::insert");
       _M_check_length(size_type(0), __n, "basic_string::insert");
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, size_type(0), __s, __n);
       else
         {

           const size_type __off = __s - _M_data();
           _M_mutate(__pos, 0, __n);
           __s = _M_data() + __off;
           _CharT* __p = _M_data() + __pos;
           if (__s + __n <= __p)
             _M_copy(__p, __s, __n);
           else if (__s >= __p)
             _M_copy(__p, __s + __n, __n);
           else
             {
        const size_type __nleft = __p - __s;
               _M_copy(__p, __s, __nleft);
               _M_copy(__p + __nleft, __p + __n, __n - __nleft);
             }
           return *this;
         }
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     typename basic_string<_CharT, _Traits, _Alloc>::iterator
     basic_string<_CharT, _Traits, _Alloc>::
     erase(iterator __first, iterator __last)
     {
      
                           ;




       const size_type __size = __last - __first;
       if (__size)
  {
    const size_type __pos = __first - _M_ibegin();
    _M_mutate(__pos, __size, size_type(0));
    _M_rep()->_M_set_leaked();
    return iterator(_M_data() + __pos);
  }
       else
  return __first;
     }

   template<typename _CharT, typename _Traits, typename _Alloc>
     basic_string<_CharT, _Traits, _Alloc>&
     basic_string<_CharT, _Traits, _Alloc>::
     replace(size_type __pos, size_type __n1, const _CharT* __s,
      size_type __n2)
     {
       ;
       _M_check(__pos, "basic_string::replace");
       __n1 = _M_limit(__pos, __n1);
       _M_check_length(__n1, __n2, "basic_string::replace");
       bool __left;
       if (_M_disjunct(__s) || _M_rep()->_M_is_shared())
         return _M_replace_safe(__pos, __n1, __s, __n2);
       else if ((__left = __s + __n2 <= _M_data() + __pos)
  || _M_data() + __pos + __n1 <= __s)
  {

    size_type __off = __s - _M_data();
    __left ? __off : (__off += __n2 - __n1);
    _M_mutate(__pos, __n1, __n2);
    _M_copy(_M_data() + __pos, _M_data() + __off, __n2);
    return *this;
  }
       else
  {

    const basic_string __tmp(__s, __n2);
    return _M_replace_safe(__pos, __n1, __tmp._M_data(), __n2);
  }
     }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_destroy(const _Alloc& __a) throw ()
    {
      const size_type __size = sizeof(_Rep_base) +
                        (this->_M_capacity + 1) * sizeof(_CharT);
      _Raw_bytes_alloc(__a).deallocate(reinterpret_cast<char*>(this), __size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_leak_hard()
    {

      if (_M_rep() == &_S_empty_rep())
 return;

      if (_M_rep()->_M_is_shared())
 _M_mutate(0, 0, 0);
      _M_rep()->_M_set_leaked();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    _M_mutate(size_type __pos, size_type __len1, size_type __len2)
    {
      const size_type __old_size = this->size();
      const size_type __new_size = __old_size + __len2 - __len1;
      const size_type __how_much = __old_size - __pos - __len1;

      if (__new_size > this->capacity() || _M_rep()->_M_is_shared())
 {

   const allocator_type __a = get_allocator();
   _Rep* __r = _Rep::_S_create(__new_size, this->capacity(), __a);

   if (__pos)
     _M_copy(__r->_M_refdata(), _M_data(), __pos);
   if (__how_much)
     _M_copy(__r->_M_refdata() + __pos + __len2,
      _M_data() + __pos + __len1, __how_much);

   _M_rep()->_M_dispose(__a);
   _M_data(__r->_M_refdata());
 }
      else if (__how_much && __len1 != __len2)
 {

   _M_move(_M_data() + __pos + __len2,
    _M_data() + __pos + __len1, __how_much);
 }
      _M_rep()->_M_set_length_and_sharable(__new_size);
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    reserve(size_type __res)
    {
      if (__res != this->capacity() || _M_rep()->_M_is_shared())
        {

   if (__res < this->size())
     __res = this->size();
   const allocator_type __a = get_allocator();
   _CharT* __tmp = _M_rep()->_M_clone(__a, __res - this->size());
   _M_rep()->_M_dispose(__a);
   _M_data(__tmp);
        }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    swap(basic_string& __s)
    {
      if (_M_rep()->_M_is_leaked())
 _M_rep()->_M_set_sharable();
      if (__s._M_rep()->_M_is_leaked())
 __s._M_rep()->_M_set_sharable();
      if (this->get_allocator() == __s.get_allocator())
 {
   _CharT* __tmp = _M_data();
   _M_data(__s._M_data());
   __s._M_data(__tmp);
 }

      else
 {
   const basic_string __tmp1(_M_ibegin(), _M_iend(),
        __s.get_allocator());
   const basic_string __tmp2(__s._M_ibegin(), __s._M_iend(),
        this->get_allocator());
   *this = __tmp2;
   __s = __tmp1;
 }
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::_Rep*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _S_create(size_type __capacity, size_type __old_capacity,
       const _Alloc& __alloc)
    {


      if (__capacity > _S_max_size)
 __throw_length_error(("basic_string::_S_create"));
# 577 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/basic_string.tcc" 3
      const size_type __pagesize = 4096;
      const size_type __malloc_header_size = 4 * sizeof(void*);







      if (__capacity > __old_capacity && __capacity < 2 * __old_capacity)
 __capacity = 2 * __old_capacity;




      size_type __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);

      const size_type __adj_size = __size + __malloc_header_size;
      if (__adj_size > __pagesize && __capacity > __old_capacity)
 {
   const size_type __extra = __pagesize - __adj_size % __pagesize;
   __capacity += __extra / sizeof(_CharT);

   if (__capacity > _S_max_size)
     __capacity = _S_max_size;
   __size = (__capacity + 1) * sizeof(_CharT) + sizeof(_Rep);
 }



      void* __place = _Raw_bytes_alloc(__alloc).allocate(__size);
      _Rep *__p = new (__place) _Rep;
      __p->_M_capacity = __capacity;







      __p->_M_set_sharable();
      return __p;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    _CharT*
    basic_string<_CharT, _Traits, _Alloc>::_Rep::
    _M_clone(const _Alloc& __alloc, size_type __res)
    {

      const size_type __requested_cap = this->_M_length + __res;
      _Rep* __r = _Rep::_S_create(__requested_cap, this->_M_capacity,
      __alloc);
      if (this->_M_length)
 _M_copy(__r->_M_refdata(), _M_refdata(), this->_M_length);

      __r->_M_set_length_and_sharable(this->_M_length);
      return __r->_M_refdata();
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    void
    basic_string<_CharT, _Traits, _Alloc>::
    resize(size_type __n, _CharT __c)
    {
      const size_type __size = this->size();
      _M_check_length(__size, __n, "basic_string::resize");
      if (__size < __n)
 this->append(__n - __size, __c);
      else if (__n < __size)
 this->erase(__n);

    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    template<typename _InputIterator>
      basic_string<_CharT, _Traits, _Alloc>&
      basic_string<_CharT, _Traits, _Alloc>::
      _M_replace_dispatch(iterator __i1, iterator __i2, _InputIterator __k1,
     _InputIterator __k2, __false_type)
      {
 const basic_string __s(__k1, __k2);
 const size_type __n1 = __i2 - __i1;
 _M_check_length(__n1, __s.size(), "basic_string::_M_replace_dispatch");
 return _M_replace_safe(__i1 - _M_ibegin(), __n1, __s._M_data(),
          __s.size());
      }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_aux(size_type __pos1, size_type __n1, size_type __n2,
     _CharT __c)
    {
      _M_check_length(__n1, __n2, "basic_string::_M_replace_aux");
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_assign(_M_data() + __pos1, __n2, __c);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>&
    basic_string<_CharT, _Traits, _Alloc>::
    _M_replace_safe(size_type __pos1, size_type __n1, const _CharT* __s,
      size_type __n2)
    {
      _M_mutate(__pos1, __n1, __n2);
      if (__n2)
 _M_copy(_M_data() + __pos1, __s, __n2);
      return *this;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(const _CharT* __lhs,
       const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      ;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      const __size_type __len = _Traits::length(__lhs);
      __string_type __str;
      __str.reserve(__len + __rhs.size());
      __str.append(__lhs, __len);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_string<_CharT, _Traits, _Alloc>
    operator+(_CharT __lhs, const basic_string<_CharT, _Traits, _Alloc>& __rhs)
    {
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __string_type::size_type __size_type;
      __string_type __str;
      const __size_type __len = __rhs.size();
      __str.reserve(__len + 1);
      __str.append(__size_type(1), __lhs);
      __str.append(__rhs);
      return __str;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    copy(_CharT* __s, size_type __n, size_type __pos) const
    {
      _M_check(__pos, "basic_string::copy");
      __n = _M_limit(__pos, __n);
      ;
      if (__n)
 _M_copy(__s, _M_data() + __pos, __n);

      return __n;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      const _CharT* __data = _M_data();

      if (__n == 0)
 return __pos <= __size ? __pos : npos;

      if (__n <= __size)
 {
   for (; __pos <= __size - __n; ++__pos)
     if (traits_type::eq(__data[__pos], __s[0])
  && traits_type::compare(__data + __pos + 1,
     __s + 1, __n - 1) == 0)
       return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find(_CharT __c, size_type __pos) const noexcept
    {
      size_type __ret = npos;
      const size_type __size = this->size();
      if (__pos < __size)
 {
   const _CharT* __data = _M_data();
   const size_type __n = __size - __pos;
   const _CharT* __p = traits_type::find(__data + __pos, __n, __c);
   if (__p)
     __ret = __p - __data;
 }
      return __ret;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      const size_type __size = this->size();
      if (__n <= __size)
 {
   __pos = std::min(size_type(__size - __n), __pos);
   const _CharT* __data = _M_data();
   do
     {
       if (traits_type::compare(__data + __pos, __s, __n) == 0)
  return __pos;
     }
   while (__pos-- > 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    rfind(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   for (++__size; __size-- > 0; )
     if (traits_type::eq(_M_data()[__size], __c))
       return __size;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __n && __pos < this->size(); ++__pos)
 {
   const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);
   if (__p)
     return __pos;
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size && __n)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size-- != 0);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::find(__s, __n, _M_data()[__pos]))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_first_not_of(_CharT __c, size_type __pos) const noexcept
    {
      for (; __pos < this->size(); ++__pos)
 if (!traits_type::eq(_M_data()[__pos], __c))
   return __pos;
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const
    {
      ;
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::find(__s, __n, _M_data()[__size]))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    typename basic_string<_CharT, _Traits, _Alloc>::size_type
    basic_string<_CharT, _Traits, _Alloc>::
    find_last_not_of(_CharT __c, size_type __pos) const noexcept
    {
      size_type __size = this->size();
      if (__size)
 {
   if (--__size > __pos)
     __size = __pos;
   do
     {
       if (!traits_type::eq(_M_data()[__size], __c))
  return __size;
     }
   while (__size--);
 }
      return npos;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n, const basic_string& __str) const
    {
      _M_check(__pos, "basic_string::compare");
      __n = _M_limit(__pos, __n);
      const size_type __osize = __str.size();
      const size_type __len = std::min(__n, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __str.data(), __len);
      if (!__r)
 __r = _S_compare(__n, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(size_type __pos1, size_type __n1, const basic_string& __str,
     size_type __pos2, size_type __n2) const
    {
      _M_check(__pos1, "basic_string::compare");
      __str._M_check(__pos2, "basic_string::compare");
      __n1 = _M_limit(__pos1, __n1);
      __n2 = __str._M_limit(__pos2, __n2);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos1,
         __str.data() + __pos2, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string<_CharT, _Traits, _Alloc>::
    compare(const _CharT* __s) const
    {
      ;
      const size_type __size = this->size();
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__size, __osize);
      int __r = traits_type::compare(_M_data(), __s, __len);
      if (!__r)
 __r = _S_compare(__size, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __osize = traits_type::length(__s);
      const size_type __len = std::min(__n1, __osize);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __osize);
      return __r;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    int
    basic_string <_CharT, _Traits, _Alloc>::
    compare(size_type __pos, size_type __n1, const _CharT* __s,
     size_type __n2) const
    {
      ;
      _M_check(__pos, "basic_string::compare");
      __n1 = _M_limit(__pos, __n1);
      const size_type __len = std::min(__n1, __n2);
      int __r = traits_type::compare(_M_data() + __pos, __s, __len);
      if (!__r)
 __r = _S_compare(__n1, __n2);
      return __r;
    }


  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    operator>>(basic_istream<_CharT, _Traits>& __in,
        basic_string<_CharT, _Traits, _Alloc>& __str)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;
      typedef ctype<_CharT> __ctype_type;
      typedef typename __ctype_type::ctype_base __ctype_base;

      __size_type __extracted = 0;
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, false);
      if (__cerb)
 {
   try
     {

       __str.erase();
       _CharT __buf[128];
       __size_type __len = 0;
       const streamsize __w = __in.width();
       const __size_type __n = __w > 0 ? static_cast<__size_type>(__w)
                                : __str.max_size();
       const __ctype_type& __ct = use_facet<__ctype_type>(__in.getloc());
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !__ct.is(__ctype_base::space,
     _Traits::to_char_type(__c)))
  {
    if (__len == sizeof(__buf) / sizeof(_CharT))
      {
        __str.append(__buf, sizeof(__buf) / sizeof(_CharT));
        __len = 0;
      }
    __buf[__len++] = _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }
       __str.append(__buf, __len);

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       __in.width(0);
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }

      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }

  template<typename _CharT, typename _Traits, typename _Alloc>
    basic_istream<_CharT, _Traits>&
    getline(basic_istream<_CharT, _Traits>& __in,
     basic_string<_CharT, _Traits, _Alloc>& __str, _CharT __delim)
    {
      typedef basic_istream<_CharT, _Traits> __istream_type;
      typedef basic_string<_CharT, _Traits, _Alloc> __string_type;
      typedef typename __istream_type::ios_base __ios_base;
      typedef typename __istream_type::int_type __int_type;
      typedef typename __string_type::size_type __size_type;

      __size_type __extracted = 0;
      const __size_type __n = __str.max_size();
      typename __ios_base::iostate __err = __ios_base::goodbit;
      typename __istream_type::sentry __cerb(__in, true);
      if (__cerb)
 {
   try
     {
       __str.erase();
       const __int_type __idelim = _Traits::to_int_type(__delim);
       const __int_type __eof = _Traits::eof();
       __int_type __c = __in.rdbuf()->sgetc();

       while (__extracted < __n
       && !_Traits::eq_int_type(__c, __eof)
       && !_Traits::eq_int_type(__c, __idelim))
  {
    __str += _Traits::to_char_type(__c);
    ++__extracted;
    __c = __in.rdbuf()->snextc();
  }

       if (_Traits::eq_int_type(__c, __eof))
  __err |= __ios_base::eofbit;
       else if (_Traits::eq_int_type(__c, __idelim))
  {
    ++__extracted;
    __in.rdbuf()->sbumpc();
  }
       else
  __err |= __ios_base::failbit;
     }
   catch(__cxxabiv1::__forced_unwind&)
     {
       __in._M_setstate(__ios_base::badbit);
       throw;
     }
   catch(...)
     {



       __in._M_setstate(__ios_base::badbit);
     }
 }
      if (!__extracted)
 __err |= __ios_base::failbit;
      if (__err)
 __in.setstate(__err);
      return __in;
    }




  extern template class basic_string<char>;
  extern template
    basic_istream<char>&
    operator>>(basic_istream<char>&, string&);
  extern template
    basic_ostream<char>&
    operator<<(basic_ostream<char>&, const string&);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&, char);
  extern template
    basic_istream<char>&
    getline(basic_istream<char>&, string&);


  extern template class basic_string<wchar_t>;
  extern template
    basic_istream<wchar_t>&
    operator>>(basic_istream<wchar_t>&, wstring&);
  extern template
    basic_ostream<wchar_t>&
    operator<<(basic_ostream<wchar_t>&, const wstring&);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&, wchar_t);
  extern template
    basic_istream<wchar_t>&
    getline(basic_istream<wchar_t>&, wstring&);




}
# 54 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/string" 2 3
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/stdexcept" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/stdexcept" 3
  class logic_error : public exception
  {
    string _M_msg;

  public:

    explicit
    logic_error(const string& __arg);

    virtual ~logic_error() noexcept;



    virtual const char*
    what() const noexcept;
  };



  class domain_error : public logic_error
  {
  public:
    explicit domain_error(const string& __arg);
    virtual ~domain_error() noexcept;
  };


  class invalid_argument : public logic_error
  {
  public:
    explicit invalid_argument(const string& __arg);
    virtual ~invalid_argument() noexcept;
  };



  class length_error : public logic_error
  {
  public:
    explicit length_error(const string& __arg);
    virtual ~length_error() noexcept;
  };



  class out_of_range : public logic_error
  {
  public:
    explicit out_of_range(const string& __arg);
    virtual ~out_of_range() noexcept;
  };






  class runtime_error : public exception
  {
    string _M_msg;

  public:

    explicit
    runtime_error(const string& __arg);

    virtual ~runtime_error() noexcept;



    virtual const char*
    what() const noexcept;
  };


  class range_error : public runtime_error
  {
  public:
    explicit range_error(const string& __arg);
    virtual ~range_error() noexcept;
  };


  class overflow_error : public runtime_error
  {
  public:
    explicit overflow_error(const string& __arg);
    virtual ~overflow_error() noexcept;
  };


  class underflow_error : public runtime_error
  {
  public:
    explicit underflow_error(const string& __arg);
    virtual ~underflow_error() noexcept;
  };




}
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/array" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, std::size_t _Nm>
    struct __array_traits
    {
      typedef _Tp _Type[_Nm];

      static constexpr _Tp&
      _S_ref(const _Type& __t, std::size_t __n) noexcept
      { return const_cast<_Tp&>(__t[__n]); }
    };

 template<typename _Tp>
   struct __array_traits<_Tp, 0>
   {
     struct _Type { };

     static constexpr _Tp&
     _S_ref(const _Type&, std::size_t) noexcept
     { return *static_cast<_Tp*>(nullptr); }
   };
# 80 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/array" 3
  template<typename _Tp, std::size_t _Nm>
    struct array
    {
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef const value_type* const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;
      typedef value_type* iterator;
      typedef const value_type* const_iterator;
      typedef std::size_t size_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::reverse_iterator<iterator> reverse_iterator;
      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;


      typedef std::__array_traits<_Tp, _Nm> _AT_Type;
      typename _AT_Type::_Type _M_elems;




      void
      fill(const value_type& __u)
      { std::fill_n(begin(), size(), __u); }

      void
      swap(array& __other)
      noexcept(noexcept(swap(std::declval<_Tp&>(), std::declval<_Tp&>())))
      { std::swap_ranges(begin(), end(), __other.begin()); }


      iterator
      begin() noexcept
      { return iterator(data()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(data()); }

      iterator
      end() noexcept
      { return iterator(data() + _Nm); }

      const_iterator
      end() const noexcept
      { return const_iterator(data() + _Nm); }

      reverse_iterator
      rbegin() noexcept
      { return reverse_iterator(end()); }

      const_reverse_iterator
      rbegin() const noexcept
      { return const_reverse_iterator(end()); }

      reverse_iterator
      rend() noexcept
      { return reverse_iterator(begin()); }

      const_reverse_iterator
      rend() const noexcept
      { return const_reverse_iterator(begin()); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(data()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(data() + _Nm); }

      const_reverse_iterator
      crbegin() const noexcept
      { return const_reverse_iterator(end()); }

      const_reverse_iterator
      crend() const noexcept
      { return const_reverse_iterator(begin()); }


      constexpr size_type
      size() const noexcept { return _Nm; }

      constexpr size_type
      max_size() const noexcept { return _Nm; }

      constexpr bool
      empty() const noexcept { return size() == 0; }


      reference
      operator[](size_type __n) noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      constexpr const_reference
      operator[](size_type __n) const noexcept
      { return _AT_Type::_S_ref(_M_elems, __n); }

      reference
      at(size_type __n)
      {
 if (__n >= _Nm)
   std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                 ,
     __n, _Nm);
 return _AT_Type::_S_ref(_M_elems, __n);
      }

      constexpr const_reference
      at(size_type __n) const
      {


 return __n < _Nm ? _AT_Type::_S_ref(_M_elems, __n)
   : (std::__throw_out_of_range_fmt(("array::at: __n (which is %zu) " ">= _Nm (which is %zu)")
                                    ,
        __n, _Nm),
      _AT_Type::_S_ref(_M_elems, 0));
      }

      reference
      front() noexcept
      { return *begin(); }

      constexpr const_reference
      front() const noexcept
      { return _AT_Type::_S_ref(_M_elems, 0); }

      reference
      back() noexcept
      { return _Nm ? *(end() - 1) : *end(); }

      constexpr const_reference
      back() const noexcept
      {
 return _Nm ? _AT_Type::_S_ref(_M_elems, _Nm - 1)
             : _AT_Type::_S_ref(_M_elems, 0);
      }

      pointer
      data() noexcept
      { return std::__addressof(_AT_Type::_S_ref(_M_elems, 0)); }

      const_pointer
      data() const noexcept
      { return std::__addressof(_AT_Type::_S_ref(_M_elems, 0)); }
    };


  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator==(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return std::equal(__one.begin(), __one.end(), __two.begin()); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator!=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one == __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<(const array<_Tp, _Nm>& __a, const array<_Tp, _Nm>& __b)
    {
      return std::lexicographical_compare(__a.begin(), __a.end(),
       __b.begin(), __b.end());
    }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return __two < __one; }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator<=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one > __two); }

  template<typename _Tp, std::size_t _Nm>
    inline bool
    operator>=(const array<_Tp, _Nm>& __one, const array<_Tp, _Nm>& __two)
    { return !(__one < __two); }


  template<typename _Tp, std::size_t _Nm>
    inline void
    swap(array<_Tp, _Nm>& __one, array<_Tp, _Nm>& __two)
    noexcept(noexcept(__one.swap(__two)))
    { __one.swap(__two); }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&
    get(array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr _Tp&&
    get(array<_Tp, _Nm>&& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::move(get<_Int>(__arr));
    }

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    constexpr const _Tp&
    get(const array<_Tp, _Nm>& __arr) noexcept
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      return std::__array_traits<_Tp, _Nm>::
 _S_ref(__arr._M_elems, _Int);
    }


}

namespace std __attribute__ ((__visibility__ ("default")))
{





  template<typename _Tp>
    class tuple_size;

  template<typename _Tp, std::size_t _Nm>
    struct tuple_size<std::array<_Tp, _Nm>>
    : public integral_constant<std::size_t, _Nm> { };


  template<std::size_t _Int, typename _Tp>
    class tuple_element;

  template<std::size_t _Int, typename _Tp, std::size_t _Nm>
    struct tuple_element<_Int, std::array<_Tp, _Nm>>
    {
      static_assert(_Int < _Nm, "index is out of bounds");
      typedef _Tp type;
    };


}
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/tuple" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/uses_allocator.h" 1 3
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/uses_allocator.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  struct allocator_arg_t { };

  constexpr allocator_arg_t allocator_arg = allocator_arg_t();

template<typename _Tp> class __has_allocator_type_helper { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static true_type __test(_Wrap_type<typename _Up::allocator_type>*); template<typename _Up> static false_type __test(...); public: typedef decltype(__test<_Tp>(0)) type; }; template<typename _Tp> struct __has_allocator_type : public __has_allocator_type_helper <typename remove_cv<_Tp>::type>::type { };

  template<typename _Tp, typename _Alloc,
    bool = __has_allocator_type<_Tp>::value>
    struct __uses_allocator_helper
    : public false_type { };

  template<typename _Tp, typename _Alloc>
    struct __uses_allocator_helper<_Tp, _Alloc, true>
    : public integral_constant<bool, is_convertible<_Alloc,
         typename _Tp::allocator_type>::value>
    { };


  template<typename _Tp, typename _Alloc>
    struct uses_allocator
    : public integral_constant<bool,
          __uses_allocator_helper<_Tp, _Alloc>::value>
    { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_allocator_arg
    : is_constructible<_Tp, _Alloc, _Args...>
    { static_assert( uses_allocator<_Tp, _Alloc>::value, "uses allocator" ); };

  struct __uses_alloc_base { };
  struct __uses_alloc0 : __uses_alloc_base
  { struct _Anything { _Anything(...) { } } _M_a; };
  template<typename _Alloc>
    struct __uses_alloc1 : __uses_alloc_base { const _Alloc* _M_a; };
  template<typename _Alloc>
    struct __uses_alloc2 : __uses_alloc_base { const _Alloc* _M_a; };

  template<bool, typename _Alloc, typename... _Args>
    struct __uses_alloc;

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<true, _Tp, _Alloc, _Args...>
    : conditional<
        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value,
        __uses_alloc1<_Alloc>,
        __uses_alloc2<_Alloc>>::type
    { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc<false, _Tp, _Alloc, _Args...>
    : __uses_alloc0 { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    struct __uses_alloc_impl
    : __uses_alloc<uses_allocator<_Tp, _Alloc>::value, _Tp, _Alloc, _Args...>
    { };

  template<typename _Tp, typename _Alloc, typename... _Args>
    __uses_alloc_impl<_Tp, _Alloc, _Args...>
    __use_alloc(const _Alloc& __a)
    {
      __uses_alloc_impl<_Tp, _Alloc, _Args...> __ret;
      __ret._M_a = &__a;
      return __ret;
    }


}
# 41 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/tuple" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








  template<typename _Tp>
    struct __add_c_ref
    { typedef const _Tp& type; };

  template<typename _Tp>
    struct __add_c_ref<_Tp&>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct __add_ref
    { typedef _Tp& type; };

  template<typename _Tp>
    struct __add_ref<_Tp&>
    { typedef _Tp& type; };


  template<typename _Tp>
    struct __add_r_ref
    { typedef _Tp&& type; };

  template<typename _Tp>
    struct __add_r_ref<_Tp&>
    { typedef _Tp& type; };

  template<std::size_t _Idx, typename _Head, bool _IsEmptyNotFinal>
    struct _Head_base;

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, true>
    : public _Head
    {
      constexpr _Head_base()
      : _Head() { }

      constexpr _Head_base(const _Head& __h)
      : _Head(__h) { }

      template<typename _UHead, typename = typename
        enable_if<!is_convertible<_UHead,
                                  __uses_alloc_base>::value>::type>
        constexpr _Head_base(_UHead&& __h)
 : _Head(std::forward<_UHead>(__h)) { }

      _Head_base(__uses_alloc0)
      : _Head() { }

      template<typename _Alloc>
 _Head_base(__uses_alloc1<_Alloc> __a)
 : _Head(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(__uses_alloc2<_Alloc> __a)
 : _Head(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _Head(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _Head(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b; }
    };

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }

      constexpr _Head_base(const _Head& __h)
      : _M_head_impl(__h) { }

      template<typename _UHead, typename = typename
        enable_if<!is_convertible<_UHead,
                                  __uses_alloc_base>::value>::type>
        constexpr _Head_base(_UHead&& __h)
 : _M_head_impl(std::forward<_UHead>(__h)) { }

      _Head_base(__uses_alloc0)
      : _M_head_impl() { }

      template<typename _Alloc>
 _Head_base(__uses_alloc1<_Alloc> __a)
 : _M_head_impl(allocator_arg, *__a._M_a) { }

      template<typename _Alloc>
 _Head_base(__uses_alloc2<_Alloc> __a)
 : _M_head_impl(*__a._M_a) { }

      template<typename _UHead>
 _Head_base(__uses_alloc0, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead)) { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc1<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(allocator_arg, *__a._M_a, std::forward<_UHead>(__uhead))
 { }

      template<typename _Alloc, typename _UHead>
 _Head_base(__uses_alloc2<_Alloc> __a, _UHead&& __uhead)
 : _M_head_impl(std::forward<_UHead>(__uhead), *__a._M_a) { }

      static constexpr _Head&
      _M_head(_Head_base& __b) noexcept { return __b._M_head_impl; }

      static constexpr const _Head&
      _M_head(const _Head_base& __b) noexcept { return __b._M_head_impl; }

      _Head _M_head_impl;
    };
# 183 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/tuple" 3
  template<std::size_t _Idx, typename... _Elements>
    struct _Tuple_impl;





  template<std::size_t _Idx>
    struct _Tuple_impl<_Idx>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      _Tuple_impl() = default;

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t, const _Alloc&) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t, const _Alloc&, const _Tuple_impl&) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t, const _Alloc&, _Tuple_impl&&) { }

    protected:
      void _M_swap(_Tuple_impl&) noexcept { }
    };

  template<typename _Tp>
    struct __is_empty_non_tuple : is_empty<_Tp> { };


  template<typename _El0, typename... _El>
    struct __is_empty_non_tuple<tuple<_El0, _El...>> : false_type { };


  template<typename _Tp>
    using __empty_not_final
    = typename conditional<__is_final(_Tp), false_type,
      __is_empty_non_tuple<_Tp>>::type;






  template<std::size_t _Idx, typename _Head, typename... _Tail>
    struct _Tuple_impl<_Idx, _Head, _Tail...>
    : public _Tuple_impl<_Idx + 1, _Tail...>,
      private _Head_base<_Idx, _Head, __empty_not_final<_Head>::value>
    {
      template<std::size_t, typename...> friend class _Tuple_impl;

      typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;
      typedef _Head_base<_Idx, _Head, __empty_not_final<_Head>::value> _Base;

      static constexpr _Head&
      _M_head(_Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr const _Head&
      _M_head(const _Tuple_impl& __t) noexcept { return _Base::_M_head(__t); }

      static constexpr _Inherited&
      _M_tail(_Tuple_impl& __t) noexcept { return __t; }

      static constexpr const _Inherited&
      _M_tail(const _Tuple_impl& __t) noexcept { return __t; }

      constexpr _Tuple_impl()
      : _Inherited(), _Base() { }

      explicit
      constexpr _Tuple_impl(const _Head& __head, const _Tail&... __tail)
      : _Inherited(__tail...), _Base(__head) { }

      template<typename _UHead, typename... _UTail, typename = typename
               enable_if<sizeof...(_Tail) == sizeof...(_UTail)>::type>
        explicit
        constexpr _Tuple_impl(_UHead&& __head, _UTail&&... __tail)
 : _Inherited(std::forward<_UTail>(__tail)...),
   _Base(std::forward<_UHead>(__head)) { }

      constexpr _Tuple_impl(const _Tuple_impl&) = default;

      constexpr
      _Tuple_impl(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_constructible<_Head>,
               is_nothrow_move_constructible<_Inherited>>::value)
      : _Inherited(std::move(_M_tail(__in))),
 _Base(std::forward<_Head>(_M_head(__in))) { }

      template<typename... _UElements>
        constexpr _Tuple_impl(const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(_Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(_Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _UHead, typename... _UTails>
        constexpr _Tuple_impl(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a),
          _Base(__use_alloc<_Head>(__a)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
      const _Head& __head, const _Tail&... __tail)
 : _Inherited(__tag, __a, __tail...),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), __head) { }

      template<typename _Alloc, typename _UHead, typename... _UTail,
               typename = typename enable_if<sizeof...(_Tail)
          == sizeof...(_UTail)>::type>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _UHead&& __head, _UTail&&... __tail)
 : _Inherited(__tag, __a, std::forward<_UTail>(__tail)...),
          _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
         std::forward<_UHead>(__head)) { }

      template<typename _Alloc>
        _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl& __in)
 : _Inherited(__tag, __a, _M_tail(__in)),
          _Base(__use_alloc<_Head, _Alloc, _Head>(__a), _M_head(__in)) { }

      template<typename _Alloc>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl&& __in)
 : _Inherited(__tag, __a, std::move(_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
         std::forward<_Head>(_M_head(__in))) { }

      template<typename _Alloc, typename... _UElements>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             const _Tuple_impl<_Idx, _UElements...>& __in)
 : _Inherited(__tag, __a,
       _Tuple_impl<_Idx, _UElements...>::_M_tail(__in)),
   _Base(__use_alloc<_Head, _Alloc, _Head>(__a),
  _Tuple_impl<_Idx, _UElements...>::_M_head(__in)) { }

      template<typename _Alloc, typename _UHead, typename... _UTails>
 _Tuple_impl(allocator_arg_t __tag, const _Alloc& __a,
             _Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
 : _Inherited(__tag, __a, std::move
       (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in))),
   _Base(__use_alloc<_Head, _Alloc, _UHead>(__a),
                std::forward<_UHead>
  (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in))) { }

      _Tuple_impl&
      operator=(const _Tuple_impl& __in)
      {
 _M_head(*this) = _M_head(__in);
 _M_tail(*this) = _M_tail(__in);
 return *this;
      }

      _Tuple_impl&
      operator=(_Tuple_impl&& __in)
      noexcept(__and_<is_nothrow_move_assignable<_Head>,
               is_nothrow_move_assignable<_Inherited>>::value)
      {
 _M_head(*this) = std::forward<_Head>(_M_head(__in));
 _M_tail(*this) = std::move(_M_tail(__in));
 return *this;
      }

      template<typename... _UElements>
        _Tuple_impl&
        operator=(const _Tuple_impl<_Idx, _UElements...>& __in)
        {
   _M_head(*this) = _Tuple_impl<_Idx, _UElements...>::_M_head(__in);
   _M_tail(*this) = _Tuple_impl<_Idx, _UElements...>::_M_tail(__in);
   return *this;
 }

      template<typename _UHead, typename... _UTails>
        _Tuple_impl&
        operator=(_Tuple_impl<_Idx, _UHead, _UTails...>&& __in)
        {
   _M_head(*this) = std::forward<_UHead>
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_head(__in));
   _M_tail(*this) = std::move
     (_Tuple_impl<_Idx, _UHead, _UTails...>::_M_tail(__in));
   return *this;
 }

    protected:
      void
      _M_swap(_Tuple_impl& __in)
      noexcept(noexcept(swap(std::declval<_Head&>(),
        std::declval<_Head&>()))
        && noexcept(_M_tail(__in)._M_swap(_M_tail(__in))))
      {
 using std::swap;
 swap(_M_head(*this), _M_head(__in));
 _Inherited::_M_swap(_M_tail(__in));
      }
    };


  template<typename... _Elements>
    class tuple : public _Tuple_impl<0, _Elements...>
    {
      typedef _Tuple_impl<0, _Elements...> _Inherited;

    public:
      constexpr tuple()
      : _Inherited() { }

      explicit
      constexpr tuple(const _Elements&... __elements)
      : _Inherited(__elements...) { }

      template<typename... _UElements, typename = typename
        enable_if<__and_<is_convertible<_UElements,
     _Elements>...>::value>::type>
 explicit
        constexpr tuple(_UElements&&... __elements)
 : _Inherited(std::forward<_UElements>(__elements)...) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename... _UElements, typename = typename
        enable_if<__and_<is_convertible<const _UElements&,
     _Elements>...>::value>::type>
        constexpr tuple(const tuple<_UElements...>& __in)
        : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
        { }

      template<typename... _UElements, typename = typename
        enable_if<__and_<is_convertible<_UElements,
     _Elements>...>::value>::type>
        constexpr tuple(tuple<_UElements...>&& __in)
        : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _Elements&... __elements)
 : _Inherited(__tag, __a, __elements...) { }

      template<typename _Alloc, typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       _UElements&&... __elements)
 : _Inherited(__tag, __a, std::forward<_UElements>(__elements)...)
        { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_UElements...>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _UElements...>&>(__in))
 { }

      template<typename _Alloc, typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       tuple<_UElements...>&& __in)
 : _Inherited(__tag, __a,
              static_cast<_Tuple_impl<0, _UElements...>&&>(__in))
 { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
        tuple&
        operator=(const tuple<_UElements...>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename... _UElements, typename = typename
        enable_if<sizeof...(_UElements)
    == sizeof...(_Elements)>::type>
        tuple&
        operator=(tuple<_UElements...>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };


  template<>
    class tuple<>
    {
    public:
      void swap(tuple&) noexcept { }
    };



  template<typename _T1, typename _T2>
    class tuple<_T1, _T2> : public _Tuple_impl<0, _T1, _T2>
    {
      typedef _Tuple_impl<0, _T1, _T2> _Inherited;

    public:
      constexpr tuple()
      : _Inherited() { }

      explicit
      constexpr tuple(const _T1& __a1, const _T2& __a2)
      : _Inherited(__a1, __a2) { }

      template<typename _U1, typename _U2, typename = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
        explicit
        constexpr tuple(_U1&& __a1, _U2&& __a2)
 : _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }

      constexpr tuple(const tuple&) = default;

      constexpr tuple(tuple&&) = default;

      template<typename _U1, typename _U2, typename = typename
 enable_if<__and_<is_convertible<const _U1&, _T1>,
    is_convertible<const _U2&, _T2>>::value>::type>
        constexpr tuple(const tuple<_U1, _U2>& __in)
 : _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }

      template<typename _U1, typename _U2, typename = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
        constexpr tuple(tuple<_U1, _U2>&& __in)
 : _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }

      template<typename _U1, typename _U2, typename = typename
 enable_if<__and_<is_convertible<const _U1&, _T1>,
    is_convertible<const _U2&, _T2>>::value>::type>
        constexpr tuple(const pair<_U1, _U2>& __in)
 : _Inherited(__in.first, __in.second) { }

      template<typename _U1, typename _U2, typename = typename
        enable_if<__and_<is_convertible<_U1, _T1>,
    is_convertible<_U2, _T2>>::value>::type>
        constexpr tuple(pair<_U1, _U2>&& __in)
 : _Inherited(std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }



      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a)
 : _Inherited(__tag, __a) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const _T1& __a1, const _T2& __a2)
 : _Inherited(__tag, __a, __a1, __a2) { }

      template<typename _Alloc, typename _U1, typename _U2>
 tuple(allocator_arg_t __tag, const _Alloc& __a, _U1&& __a1, _U2&& __a2)
 : _Inherited(__tag, __a, std::forward<_U1>(__a1),
              std::forward<_U2>(__a2)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, const tuple& __in)
 : _Inherited(__tag, __a, static_cast<const _Inherited&>(__in)) { }

      template<typename _Alloc>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple&& __in)
 : _Inherited(__tag, __a, static_cast<_Inherited&&>(__in)) { }

      template<typename _Alloc, typename _U1, typename _U2>
 tuple(allocator_arg_t __tag, const _Alloc& __a,
       const tuple<_U1, _U2>& __in)
 : _Inherited(__tag, __a,
              static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2>
 tuple(allocator_arg_t __tag, const _Alloc& __a, tuple<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in))
 { }

      template<typename _Alloc, typename _U1, typename _U2>
        tuple(allocator_arg_t __tag, const _Alloc& __a,
       const pair<_U1, _U2>& __in)
 : _Inherited(__tag, __a, __in.first, __in.second) { }

      template<typename _Alloc, typename _U1, typename _U2>
        tuple(allocator_arg_t __tag, const _Alloc& __a, pair<_U1, _U2>&& __in)
 : _Inherited(__tag, __a, std::forward<_U1>(__in.first),
       std::forward<_U2>(__in.second)) { }

      tuple&
      operator=(const tuple& __in)
      {
 static_cast<_Inherited&>(*this) = __in;
 return *this;
      }

      tuple&
      operator=(tuple&& __in)
      noexcept(is_nothrow_move_assignable<_Inherited>::value)
      {
 static_cast<_Inherited&>(*this) = std::move(__in);
 return *this;
      }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const tuple<_U1, _U2>& __in)
        {
   static_cast<_Inherited&>(*this) = __in;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(tuple<_U1, _U2>&& __in)
        {
   static_cast<_Inherited&>(*this) = std::move(__in);
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(const pair<_U1, _U2>& __in)
        {
   this->_M_head(*this) = __in.first;
   this->_M_tail(*this)._M_head(*this) = __in.second;
   return *this;
 }

      template<typename _U1, typename _U2>
        tuple&
        operator=(pair<_U1, _U2>&& __in)
        {
   this->_M_head(*this) = std::forward<_U1>(__in.first);
   this->_M_tail(*this)._M_head(*this) = std::forward<_U2>(__in.second);
   return *this;
 }

      void
      swap(tuple& __in)
      noexcept(noexcept(__in._M_swap(__in)))
      { _Inherited::_M_swap(__in); }
    };



  template<std::size_t __i, typename _Tp>
    struct tuple_element;





  template<std::size_t __i, typename _Head, typename... _Tail>
    struct tuple_element<__i, tuple<_Head, _Tail...> >
    : tuple_element<__i - 1, tuple<_Tail...> > { };




  template<typename _Head, typename... _Tail>
    struct tuple_element<0, tuple<_Head, _Tail...> >
    {
      typedef _Head type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const _Tp>
    {
      typedef typename
      add_const<typename tuple_element<__i, _Tp>::type>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, volatile _Tp>
    {
      typedef typename
      add_volatile<typename tuple_element<__i, _Tp>::type>::type type;
    };

  template<std::size_t __i, typename _Tp>
    struct tuple_element<__i, const volatile _Tp>
    {
      typedef typename
      add_cv<typename tuple_element<__i, _Tp>::type>::type type;
    };







  template<typename _Tp>
    struct tuple_size;



  template<typename _Tp>
    struct tuple_size<const _Tp>
    : public integral_constant<size_t, tuple_size<_Tp>::value> { };

  template<typename _Tp>
    struct tuple_size<volatile _Tp>
    : public integral_constant<size_t, tuple_size<_Tp>::value> { };

  template<typename _Tp>
    struct tuple_size<const volatile _Tp>
    : public integral_constant<size_t, tuple_size<_Tp>::value> { };


  template<typename... _Elements>
    struct tuple_size<tuple<_Elements...>>
    : public integral_constant<std::size_t, sizeof...(_Elements)> { };

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr typename __add_ref<_Head>::type
    __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }

  template<std::size_t __i, typename _Head, typename... _Tail>
    constexpr typename __add_c_ref<_Head>::type
    __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept
    { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr typename __add_ref<
                      typename tuple_element<__i, tuple<_Elements...>>::type
                    >::type
    get(tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr typename __add_c_ref<
                      typename tuple_element<__i, tuple<_Elements...>>::type
                    >::type
    get(const tuple<_Elements...>& __t) noexcept
    { return std::__get_helper<__i>(__t); }


  template<std::size_t __i, typename... _Elements>
    constexpr typename __add_r_ref<
                      typename tuple_element<__i, tuple<_Elements...>>::type
                    >::type
    get(tuple<_Elements...>&& __t) noexcept
    { return std::forward<typename tuple_element<__i,
 tuple<_Elements...>>::type&&>(get<__i>(__t)); }
# 808 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/tuple" 3
  template<std::size_t __check_equal_size, std::size_t __i, std::size_t __j,
    typename _Tp, typename _Up>
    struct __tuple_compare;

  template<std::size_t __i, std::size_t __j, typename _Tp, typename _Up>
    struct __tuple_compare<0, __i, __j, _Tp, _Up>
    {
      static constexpr bool
      __eq(const _Tp& __t, const _Up& __u)
      {
 return (get<__i>(__t) == get<__i>(__u) &&
  __tuple_compare<0, __i + 1, __j, _Tp, _Up>::__eq(__t, __u));
      }

      static constexpr bool
      __less(const _Tp& __t, const _Up& __u)
      {
 return ((get<__i>(__t) < get<__i>(__u))
  || !(get<__i>(__u) < get<__i>(__t)) &&
  __tuple_compare<0, __i + 1, __j, _Tp, _Up>::__less(__t, __u));
      }
    };

  template<std::size_t __i, typename _Tp, typename _Up>
    struct __tuple_compare<0, __i, __i, _Tp, _Up>
    {
      static constexpr bool
      __eq(const _Tp&, const _Up&) { return true; }

      static constexpr bool
      __less(const _Tp&, const _Up&) { return false; }
    };

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator==(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    {
      typedef tuple<_TElements...> _Tp;
      typedef tuple<_UElements...> _Up;
      return bool(__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Up>::value,
       0, tuple_size<_Tp>::value, _Tp, _Up>::__eq(__t, __u));
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    {
      typedef tuple<_TElements...> _Tp;
      typedef tuple<_UElements...> _Up;
      return bool(__tuple_compare<tuple_size<_Tp>::value - tuple_size<_Up>::value,
       0, tuple_size<_Tp>::value, _Tp, _Up>::__less(__t, __u));
    }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator!=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t == __u); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>(const tuple<_TElements...>& __t,
       const tuple<_UElements...>& __u)
    { return __u < __t; }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator<=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__u < __t); }

  template<typename... _TElements, typename... _UElements>
    constexpr bool
    operator>=(const tuple<_TElements...>& __t,
        const tuple<_UElements...>& __u)
    { return !(__t < __u); }


  template<typename... _Elements>
    constexpr tuple<typename __decay_and_strip<_Elements>::__type...>
    make_tuple(_Elements&&... __args)
    {
      typedef tuple<typename __decay_and_strip<_Elements>::__type...>
 __result_type;
      return __result_type(std::forward<_Elements>(__args)...);
    }

  template<typename... _Elements>
    tuple<_Elements&&...>
    forward_as_tuple(_Elements&&... __args) noexcept
    { return tuple<_Elements&&...>(std::forward<_Elements>(__args)...); }

  template<typename>
    struct __is_tuple_like_impl : false_type
    { };

  template<typename... _Tps>
    struct __is_tuple_like_impl<tuple<_Tps...>> : true_type
    { };

  template<typename _T1, typename _T2>
    struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type
    { };

  template<typename _Tp, std::size_t _Nm>
    struct __is_tuple_like_impl<array<_Tp, _Nm>> : true_type
    { };


  template<typename _Tp>
    struct __is_tuple_like
    : public __is_tuple_like_impl<typename std::remove_cv
            <typename std::remove_reference<_Tp>::type>::type>::type
    { };

  template<std::size_t, typename, typename, std::size_t>
    struct __make_tuple_impl;

  template<std::size_t _Idx, typename _Tuple, typename... _Tp,
           std::size_t _Nm>
    struct __make_tuple_impl<_Idx, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef typename __make_tuple_impl<_Idx + 1, tuple<_Tp...,
 typename std::tuple_element<_Idx, _Tuple>::type>, _Tuple, _Nm>::__type
      __type;
    };

  template<std::size_t _Nm, typename _Tuple, typename... _Tp>
    struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>
    {
      typedef tuple<_Tp...> __type;
    };

  template<typename _Tuple>
    struct __do_make_tuple
    : public __make_tuple_impl<0, tuple<>, _Tuple,
                               std::tuple_size<_Tuple>::value>
    { };


  template<typename _Tuple>
    struct __make_tuple
    : public __do_make_tuple<typename std::remove_cv
            <typename std::remove_reference<_Tuple>::type>::type>
    { };


  template<typename...>
    struct __combine_tuples;

  template<>
    struct __combine_tuples<>
    {
      typedef tuple<> __type;
    };

  template<typename... _Ts>
    struct __combine_tuples<tuple<_Ts...>>
    {
      typedef tuple<_Ts...> __type;
    };

  template<typename... _T1s, typename... _T2s, typename... _Rem>
    struct __combine_tuples<tuple<_T1s...>, tuple<_T2s...>, _Rem...>
    {
      typedef typename __combine_tuples<tuple<_T1s..., _T2s...>,
     _Rem...>::__type __type;
    };


  template<typename... _Tpls>
    struct __tuple_cat_result
    {
      typedef typename __combine_tuples
        <typename __make_tuple<_Tpls>::__type...>::__type __type;
    };



  template<typename...>
    struct __make_1st_indices;

  template<>
    struct __make_1st_indices<>
    {
      typedef std::_Index_tuple<> __type;
    };

  template<typename _Tp, typename... _Tpls>
    struct __make_1st_indices<_Tp, _Tpls...>
    {
      typedef typename std::_Build_index_tuple<std::tuple_size<
 typename std::remove_reference<_Tp>::type>::value>::__type __type;
    };




  template<typename _Ret, typename _Indices, typename... _Tpls>
    struct __tuple_concater;

  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>
    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>
    {
      template<typename... _Us>
        static constexpr _Ret
        _S_do(_Tp&& __tp, _Tpls&&... __tps, _Us&&... __us)
        {
   typedef typename __make_1st_indices<_Tpls...>::__type __idx;
   typedef __tuple_concater<_Ret, __idx, _Tpls...> __next;
   return __next::_S_do(std::forward<_Tpls>(__tps)...,
          std::forward<_Us>(__us)...,
          std::get<_Is>(std::forward<_Tp>(__tp))...);
 }
    };

  template<typename _Ret>
    struct __tuple_concater<_Ret, std::_Index_tuple<>>
    {
      template<typename... _Us>
 static constexpr _Ret
 _S_do(_Us&&... __us)
        {
   return _Ret(std::forward<_Us>(__us)...);
 }
    };


  template<typename... _Tpls, typename = typename
           enable_if<__and_<__is_tuple_like<_Tpls>...>::value>::type>
    constexpr auto
    tuple_cat(_Tpls&&... __tpls)
    -> typename __tuple_cat_result<_Tpls...>::__type
    {
      typedef typename __tuple_cat_result<_Tpls...>::__type __ret;
      typedef typename __make_1st_indices<_Tpls...>::__type __idx;
      typedef __tuple_concater<__ret, __idx, _Tpls...> __concater;
      return __concater::_S_do(std::forward<_Tpls>(__tpls)...);
    }


  template<typename... _Elements>
    inline tuple<_Elements&...>
    tie(_Elements&... __args) noexcept
    { return tuple<_Elements&...>(__args...); }


  template<typename... _Elements>
    inline void
    swap(tuple<_Elements...>& __x, tuple<_Elements...>& __y)
    noexcept(noexcept(__x.swap(__y)))
    { __x.swap(__y); }



  struct _Swallow_assign
  {
    template<class _Tp>
      const _Swallow_assign&
      operator=(const _Tp&) const
      { return *this; }
  };

  const _Swallow_assign ignore{};


  template<typename... _Types, typename _Alloc>
    struct uses_allocator<tuple<_Types...>, _Alloc> : true_type { };


  template<class _T1, class _T2>
    template<typename... _Args1, typename... _Args2>
      inline
      pair<_T1, _T2>::
      pair(piecewise_construct_t,
    tuple<_Args1...> __first, tuple<_Args2...> __second)
      : pair(__first, __second,
      typename _Build_index_tuple<sizeof...(_Args1)>::__type(),
      typename _Build_index_tuple<sizeof...(_Args2)>::__type())
      { }

  template<class _T1, class _T2>
    template<typename... _Args1, std::size_t... _Indexes1,
             typename... _Args2, std::size_t... _Indexes2>
      inline
      pair<_T1, _T2>::
      pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,
    _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)
      : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),
        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)
      { }




}
# 56 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 2 3




namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _MemberPointer>
    class _Mem_fn;
  template<typename _Tp, typename _Class>
    _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::*) noexcept;

template<typename _Tp> class __has_result_type_helper { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static true_type __test(_Wrap_type<typename _Up::result_type>*); template<typename _Up> static false_type __test(...); public: typedef decltype(__test<_Tp>(0)) type; }; template<typename _Tp> struct __has_result_type : public __has_result_type_helper <typename remove_cv<_Tp>::type>::type { };


  template<bool _Has_result_type, typename _Functor>
    struct _Maybe_get_result_type
    { };

  template<typename _Functor>
    struct _Maybe_get_result_type<true, _Functor>
    { typedef typename _Functor::result_type result_type; };





  template<typename _Functor>
    struct _Weak_result_type_impl
    : _Maybe_get_result_type<__has_result_type<_Functor>::value, _Functor>
    { };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes...) const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(_ArgTypes......) const volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(&)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res(*)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) const>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) const>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...) volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......) volatile>
    { typedef _Res result_type; };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes...)
      const volatile>
    { typedef _Res result_type; };

  template<typename _Res, typename _Class, typename... _ArgTypes>
    struct _Weak_result_type_impl<_Res (_Class::*)(_ArgTypes......)
      const volatile>
    { typedef _Res result_type; };





  template<typename _Functor>
    struct _Weak_result_type
    : _Weak_result_type_impl<typename remove_cv<_Functor>::type>
    { };





  template<typename _Functor, typename... _Args>
    inline
    typename enable_if<
      (!is_member_pointer<_Functor>::value
       && !is_function<_Functor>::value
       && !is_function<typename remove_pointer<_Functor>::type>::value),
      typename result_of<_Functor&(_Args&&...)>::type
    >::type
    __invoke(_Functor& __f, _Args&&... __args)
    {
      return __f(std::forward<_Args>(__args)...);
    }

  template<typename _Functor, typename... _Args>
    inline
    typename enable_if<
             (is_member_pointer<_Functor>::value
              && !is_function<_Functor>::value
              && !is_function<typename remove_pointer<_Functor>::type>::value),
             typename result_of<_Functor(_Args&&...)>::type
           >::type
    __invoke(_Functor& __f, _Args&&... __args)
    {
      return std::mem_fn(__f)(std::forward<_Args>(__args)...);
    }


  template<typename _Functor, typename... _Args>
    inline
    typename enable_if<
      (is_pointer<_Functor>::value
       && is_function<typename remove_pointer<_Functor>::type>::value),
      typename result_of<_Functor(_Args&&...)>::type
    >::type
    __invoke(_Functor __f, _Args&&... __args)
    {
      return __f(std::forward<_Args>(__args)...);
    }






  template<bool _Unary, bool _Binary, typename _Tp>
    struct _Reference_wrapper_base_impl;


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, false, _Tp>
    : _Weak_result_type<_Tp>
    { };


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, false, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::argument_type argument_type;
    };


  template<typename _Tp>
    struct _Reference_wrapper_base_impl<false, true, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };


   template<typename _Tp>
    struct _Reference_wrapper_base_impl<true, true, _Tp>
    : _Weak_result_type<_Tp>
    {
      typedef typename _Tp::argument_type argument_type;
      typedef typename _Tp::first_argument_type first_argument_type;
      typedef typename _Tp::second_argument_type second_argument_type;
    };

  template<typename _Tp> class __has_argument_type_helper { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static true_type __test(_Wrap_type<typename _Up::argument_type>*); template<typename _Up> static false_type __test(...); public: typedef decltype(__test<_Tp>(0)) type; }; template<typename _Tp> struct __has_argument_type : public __has_argument_type_helper <typename remove_cv<_Tp>::type>::type { };
  template<typename _Tp> class __has_first_argument_type_helper { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static true_type __test(_Wrap_type<typename _Up::first_argument_type>*); template<typename _Up> static false_type __test(...); public: typedef decltype(__test<_Tp>(0)) type; }; template<typename _Tp> struct __has_first_argument_type : public __has_first_argument_type_helper <typename remove_cv<_Tp>::type>::type { };
  template<typename _Tp> class __has_second_argument_type_helper { template<typename _Up> struct _Wrap_type { }; template<typename _Up> static true_type __test(_Wrap_type<typename _Up::second_argument_type>*); template<typename _Up> static false_type __test(...); public: typedef decltype(__test<_Tp>(0)) type; }; template<typename _Tp> struct __has_second_argument_type : public __has_second_argument_type_helper <typename remove_cv<_Tp>::type>::type { };







  template<typename _Tp>
    struct _Reference_wrapper_base
    : _Reference_wrapper_base_impl<
      __has_argument_type<_Tp>::value,
      __has_first_argument_type<_Tp>::value
      && __has_second_argument_type<_Tp>::value,
      _Tp>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1)>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) volatile>
    : unary_function<_T1, _Res>
    { };

  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(_T1) const volatile>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) volatile>
    : binary_function<_T1, _T2, _Res>
    { };

  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(_T1, _T2) const volatile>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res(*)(_T1)>
    : unary_function<_T1, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res(*)(_T1, _T2)>
    : binary_function<_T1, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)()>
    : unary_function<_T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2)>
    : binary_function<_T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const>
    : unary_function<const _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const>
    : binary_function<const _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() volatile>
    : unary_function<volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) volatile>
    : binary_function<volatile _T1*, _T2, _Res>
    { };


  template<typename _Res, typename _T1>
    struct _Reference_wrapper_base<_Res (_T1::*)() const volatile>
    : unary_function<const volatile _T1*, _Res>
    { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Reference_wrapper_base<_Res (_T1::*)(_T2) const volatile>
    : binary_function<const volatile _T1*, _T2, _Res>
    { };






  template<typename _Tp>
    class reference_wrapper
    : public _Reference_wrapper_base<typename remove_cv<_Tp>::type>
    {
      _Tp* _M_data;

    public:
      typedef _Tp type;

      reference_wrapper(_Tp& __indata) noexcept
      : _M_data(std::__addressof(__indata))
      { }

      reference_wrapper(_Tp&&) = delete;

      reference_wrapper(const reference_wrapper<_Tp>& __inref) noexcept
      : _M_data(__inref._M_data)
      { }

      reference_wrapper&
      operator=(const reference_wrapper<_Tp>& __inref) noexcept
      {
 _M_data = __inref._M_data;
 return *this;
      }

      operator _Tp&() const noexcept
      { return this->get(); }

      _Tp&
      get() const noexcept
      { return *_M_data; }

      template<typename... _Args>
 typename result_of<_Tp&(_Args&&...)>::type
 operator()(_Args&&... __args) const
 {
   return __invoke(get(), std::forward<_Args>(__args)...);
 }
    };



  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(_Tp& __t) noexcept
    { return reference_wrapper<_Tp>(__t); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(const _Tp& __t) noexcept
    { return reference_wrapper<const _Tp>(__t); }

  template<typename _Tp>
    void ref(const _Tp&&) = delete;

  template<typename _Tp>
    void cref(const _Tp&&) = delete;


  template<typename _Tp>
    inline reference_wrapper<_Tp>
    ref(reference_wrapper<_Tp> __t) noexcept
    { return ref(__t.get()); }


  template<typename _Tp>
    inline reference_wrapper<const _Tp>
    cref(reference_wrapper<_Tp> __t) noexcept
    { return cref(__t.get()); }



  template<typename... _Types>
    struct _Pack : integral_constant<size_t, sizeof...(_Types)>
    { };

  template<typename _From, typename _To, bool = _From::value == _To::value>
    struct _AllConvertible : false_type
    { };

  template<typename... _From, typename... _To>
    struct _AllConvertible<_Pack<_From...>, _Pack<_To...>, true>
    : __and_<is_convertible<_From, _To>...>
    { };

  template<typename _Tp1, typename _Tp2>
    using _NotSame = __not_<is_same<typename std::decay<_Tp1>::type,
        typename std::decay<_Tp2>::type>>;






  template<typename _Res, typename... _ArgTypes>
    struct _Maybe_unary_or_binary_function { };


  template<typename _Res, typename _T1>
    struct _Maybe_unary_or_binary_function<_Res, _T1>
    : std::unary_function<_T1, _Res> { };


  template<typename _Res, typename _T1, typename _T2>
    struct _Maybe_unary_or_binary_function<_Res, _T1, _T2>
    : std::binary_function<_T1, _T2, _Res> { };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _Class*, _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...);

      template<typename _Tp, typename... _Args>
 _Res
 _M_call(_Tp&& __object, const volatile _Class *,
  _Args&&... __args) const
 {
   return (std::forward<_Tp>(__object).*__pmf)
     (std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args>
 _Res
 _M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const
 { return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }


      template<typename... _Args>
 using _RequireValidArgs
   = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;



      template<typename _Tp, typename... _Args>
 using _RequireValidArgs2
   = _Require<_NotSame<_Class, _Tp>, _NotSame<_Class*, _Tp>,
       _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;



      template<typename _Tp, typename... _Args>
 using _RequireValidArgs3
   = _Require<is_base_of<_Class, _Tp>,
       _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

    public:
      typedef _Res result_type;

      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }


      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(_Class& __object, _Args&&... __args) const
 { return (__object.*__pmf)(std::forward<_Args>(__args)...); }

      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(_Class&& __object, _Args&&... __args) const
 {
   return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);
 }


      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(_Class* __object, _Args&&... __args) const
 { return (__object->*__pmf)(std::forward<_Args>(__args)...); }


      template<typename _Tp, typename... _Args,
        typename _Req = _RequireValidArgs2<_Tp, _Args...>>
 _Res
 operator()(_Tp&& __object, _Args&&... __args) const
 {
   return _M_call(std::forward<_Tp>(__object), &__object,
       std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args,
        typename _Req = _RequireValidArgs3<_Tp, _Args...>>
 _Res
 operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
 { return operator()(__ref.get(), std::forward<_Args>(__args)...); }

    private:
      _Functor __pmf;
    };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const>
    : public _Maybe_unary_or_binary_function<_Res, const _Class*,
          _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...) const;

      template<typename _Tp, typename... _Args>
 _Res
 _M_call(_Tp&& __object, const volatile _Class *,
  _Args&&... __args) const
 {
   return (std::forward<_Tp>(__object).*__pmf)
     (std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args>
 _Res
 _M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const
 { return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }

      template<typename... _Args>
 using _RequireValidArgs
   = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

      template<typename _Tp, typename... _Args>
 using _RequireValidArgs2
   = _Require<_NotSame<_Class, _Tp>, _NotSame<const _Class*, _Tp>,
       _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

      template<typename _Tp, typename... _Args>
 using _RequireValidArgs3
   = _Require<is_base_of<_Class, _Tp>,
       _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

    public:
      typedef _Res result_type;

      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }


      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(const _Class& __object, _Args&&... __args) const
 { return (__object.*__pmf)(std::forward<_Args>(__args)...); }

      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(const _Class&& __object, _Args&&... __args) const
 {
   return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);
 }


      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(const _Class* __object, _Args&&... __args) const
 { return (__object->*__pmf)(std::forward<_Args>(__args)...); }


      template<typename _Tp, typename... _Args,
        typename _Req = _RequireValidArgs2<_Tp, _Args...>>
 _Res operator()(_Tp&& __object, _Args&&... __args) const
 {
   return _M_call(std::forward<_Tp>(__object), &__object,
       std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args,
        typename _Req = _RequireValidArgs3<_Tp, _Args...>>
 _Res
 operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
 { return operator()(__ref.get(), std::forward<_Args>(__args)...); }

    private:
      _Functor __pmf;
    };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) volatile>
    : public _Maybe_unary_or_binary_function<_Res, volatile _Class*,
          _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...) volatile;

      template<typename _Tp, typename... _Args>
 _Res
 _M_call(_Tp&& __object, const volatile _Class *,
  _Args&&... __args) const
 {
   return (std::forward<_Tp>(__object).*__pmf)
     (std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args>
 _Res
 _M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const
 { return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }

      template<typename... _Args>
 using _RequireValidArgs
   = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

      template<typename _Tp, typename... _Args>
 using _RequireValidArgs2
   = _Require<_NotSame<_Class, _Tp>, _NotSame<volatile _Class*, _Tp>,
       _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

      template<typename _Tp, typename... _Args>
 using _RequireValidArgs3
   = _Require<is_base_of<_Class, _Tp>,
       _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

    public:
      typedef _Res result_type;

      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }


      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(volatile _Class& __object, _Args&&... __args) const
 { return (__object.*__pmf)(std::forward<_Args>(__args)...); }

      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(volatile _Class&& __object, _Args&&... __args) const
 {
   return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);
 }


      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(volatile _Class* __object, _Args&&... __args) const
 { return (__object->*__pmf)(std::forward<_Args>(__args)...); }


      template<typename _Tp, typename... _Args,
        typename _Req = _RequireValidArgs2<_Tp, _Args...>>
 _Res
 operator()(_Tp&& __object, _Args&&... __args) const
 {
   return _M_call(std::forward<_Tp>(__object), &__object,
       std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args,
        typename _Req = _RequireValidArgs3<_Tp, _Args...>>
 _Res
 operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
 { return operator()(__ref.get(), std::forward<_Args>(__args)...); }

    private:
      _Functor __pmf;
    };


  template<typename _Res, typename _Class, typename... _ArgTypes>
    class _Mem_fn<_Res (_Class::*)(_ArgTypes...) const volatile>
    : public _Maybe_unary_or_binary_function<_Res, const volatile _Class*,
          _ArgTypes...>
    {
      typedef _Res (_Class::*_Functor)(_ArgTypes...) const volatile;

      template<typename _Tp, typename... _Args>
 _Res
 _M_call(_Tp&& __object, const volatile _Class *,
  _Args&&... __args) const
 {
   return (std::forward<_Tp>(__object).*__pmf)
     (std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args>
 _Res
 _M_call(_Tp&& __ptr, const volatile void *, _Args&&... __args) const
 { return ((*__ptr).*__pmf)(std::forward<_Args>(__args)...); }

      template<typename... _Args>
 using _RequireValidArgs
   = _Require<_AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

      template<typename _Tp, typename... _Args>
 using _RequireValidArgs2
   = _Require<_NotSame<_Class, _Tp>,
       _NotSame<const volatile _Class*, _Tp>,
       _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

      template<typename _Tp, typename... _Args>
 using _RequireValidArgs3
   = _Require<is_base_of<_Class, _Tp>,
       _AllConvertible<_Pack<_Args...>, _Pack<_ArgTypes...>>>;

    public:
      typedef _Res result_type;

      explicit _Mem_fn(_Functor __pmf) : __pmf(__pmf) { }


      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(const volatile _Class& __object, _Args&&... __args) const
 { return (__object.*__pmf)(std::forward<_Args>(__args)...); }

      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(const volatile _Class&& __object, _Args&&... __args) const
 {
   return (std::move(__object).*__pmf)(std::forward<_Args>(__args)...);
 }


      template<typename... _Args, typename _Req = _RequireValidArgs<_Args...>>
 _Res
 operator()(const volatile _Class* __object, _Args&&... __args) const
 { return (__object->*__pmf)(std::forward<_Args>(__args)...); }


      template<typename _Tp, typename... _Args,
        typename _Req = _RequireValidArgs2<_Tp, _Args...>>
 _Res operator()(_Tp&& __object, _Args&&... __args) const
 {
   return _M_call(std::forward<_Tp>(__object), &__object,
       std::forward<_Args>(__args)...);
 }

      template<typename _Tp, typename... _Args,
        typename _Req = _RequireValidArgs3<_Tp, _Args...>>
 _Res
 operator()(reference_wrapper<_Tp> __ref, _Args&&... __args) const
 { return operator()(__ref.get(), std::forward<_Args>(__args)...); }

    private:
      _Functor __pmf;
    };


  template<typename _Tp, bool>
    struct _Mem_fn_const_or_non
    {
      typedef const _Tp& type;
    };

  template<typename _Tp>
    struct _Mem_fn_const_or_non<_Tp, false>
    {
      typedef _Tp& type;
    };

  template<typename _Res, typename _Class>
    class _Mem_fn<_Res _Class::*>
    {
      using __pm_type = _Res _Class::*;




      template<typename _Tp>
 auto
 _M_call(_Tp&& __object, const _Class *) const noexcept
 -> decltype(std::forward<_Tp>(__object).*std::declval<__pm_type&>())
 { return std::forward<_Tp>(__object).*__pm; }

      template<typename _Tp, typename _Up>
 auto
 _M_call(_Tp&& __object, _Up * const *) const noexcept
 -> decltype((*std::forward<_Tp>(__object)).*std::declval<__pm_type&>())
 { return (*std::forward<_Tp>(__object)).*__pm; }

      template<typename _Tp>
 auto
 _M_call(_Tp&& __ptr, const volatile void*) const
 noexcept(noexcept((*__ptr).*std::declval<__pm_type&>()))
 -> decltype((*__ptr).*std::declval<__pm_type&>())
 { return (*__ptr).*__pm; }

    public:
      explicit
      _Mem_fn(_Res _Class::*__pm) noexcept : __pm(__pm) { }


      _Res&
      operator()(_Class& __object) const noexcept
      { return __object.*__pm; }

      const _Res&
      operator()(const _Class& __object) const noexcept
      { return __object.*__pm; }

      _Res&&
      operator()(_Class&& __object) const noexcept
      { return std::forward<_Class>(__object).*__pm; }

      const _Res&&
      operator()(const _Class&& __object) const noexcept
      { return std::forward<const _Class>(__object).*__pm; }


      _Res&
      operator()(_Class* __object) const noexcept
      { return __object->*__pm; }

      const _Res&
      operator()(const _Class* __object) const noexcept
      { return __object->*__pm; }


      template<typename _Tp, typename _Req = _Require<_NotSame<_Class*, _Tp>>>
 auto
 operator()(_Tp&& __unknown) const
 noexcept(noexcept(std::declval<_Mem_fn*>()->_M_call
     (std::forward<_Tp>(__unknown), &__unknown)))
 -> decltype(this->_M_call(std::forward<_Tp>(__unknown), &__unknown))
 { return _M_call(std::forward<_Tp>(__unknown), &__unknown); }

      template<typename _Tp, typename _Req = _Require<is_base_of<_Class, _Tp>>>
 auto
 operator()(reference_wrapper<_Tp> __ref) const
 noexcept(noexcept(std::declval<_Mem_fn&>()(__ref.get())))
 -> decltype((*this)(__ref.get()))
 { return (*this)(__ref.get()); }

    private:
      _Res _Class::*__pm;
    };
# 927 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
  template<typename _Tp, typename _Class>
    inline _Mem_fn<_Tp _Class::*>
    mem_fn(_Tp _Class::* __pm) noexcept
    {
      return _Mem_fn<_Tp _Class::*>(__pm);
    }







  template<typename _Tp>
    struct is_bind_expression
    : public false_type { };






  template<typename _Tp>
    struct is_placeholder
    : public integral_constant<int, 0>
    { };




  template<int _Num> struct _Placeholder { };

 





  namespace placeholders
  {
 




    extern const _Placeholder<1> _1;
    extern const _Placeholder<2> _2;
    extern const _Placeholder<3> _3;
    extern const _Placeholder<4> _4;
    extern const _Placeholder<5> _5;
    extern const _Placeholder<6> _6;
    extern const _Placeholder<7> _7;
    extern const _Placeholder<8> _8;
    extern const _Placeholder<9> _9;
    extern const _Placeholder<10> _10;
    extern const _Placeholder<11> _11;
    extern const _Placeholder<12> _12;
    extern const _Placeholder<13> _13;
    extern const _Placeholder<14> _14;
    extern const _Placeholder<15> _15;
    extern const _Placeholder<16> _16;
    extern const _Placeholder<17> _17;
    extern const _Placeholder<18> _18;
    extern const _Placeholder<19> _19;
    extern const _Placeholder<20> _20;
    extern const _Placeholder<21> _21;
    extern const _Placeholder<22> _22;
    extern const _Placeholder<23> _23;
    extern const _Placeholder<24> _24;
    extern const _Placeholder<25> _25;
    extern const _Placeholder<26> _26;
    extern const _Placeholder<27> _27;
    extern const _Placeholder<28> _28;
    extern const _Placeholder<29> _29;
 
  }

 






  template<int _Num>
    struct is_placeholder<_Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };

  template<int _Num>
    struct is_placeholder<const _Placeholder<_Num> >
    : public integral_constant<int, _Num>
    { };





  struct _No_tuple_element;






  template<std::size_t __i, typename _Tuple, bool _IsSafe>
    struct _Safe_tuple_element_impl
    : tuple_element<__i, _Tuple> { };






  template<std::size_t __i, typename _Tuple>
    struct _Safe_tuple_element_impl<__i, _Tuple, false>
    {
      typedef _No_tuple_element type;
    };





 template<std::size_t __i, typename _Tuple>
   struct _Safe_tuple_element
   : _Safe_tuple_element_impl<__i, _Tuple,
         (__i < tuple_size<_Tuple>::value)>
   { };
# 1068 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
  template<typename _Arg,
    bool _IsBindExp = is_bind_expression<_Arg>::value,
    bool _IsPlaceholder = (is_placeholder<_Arg>::value > 0)>
    class _Mu;





  template<typename _Tp>
    class _Mu<reference_wrapper<_Tp>, false, false>
    {
    public:
      typedef _Tp& result_type;





      template<typename _CVRef, typename _Tuple>
 result_type
 operator()(_CVRef& __arg, _Tuple&) const volatile
 { return __arg.get(); }
    };






  template<typename _Arg>
    class _Mu<_Arg, true, false>
    {
    public:
      template<typename _CVArg, typename... _Args>
 auto
 operator()(_CVArg& __arg,
     tuple<_Args...>& __tuple) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {

   typedef typename _Build_index_tuple<sizeof...(_Args)>::__type
     _Indexes;
   return this->__call(__arg, __tuple, _Indexes());
 }

    private:


      template<typename _CVArg, typename... _Args, std::size_t... _Indexes>
 auto
 __call(_CVArg& __arg, tuple<_Args...>& __tuple,
        const _Index_tuple<_Indexes...>&) const volatile
 -> decltype(__arg(declval<_Args>()...))
 {
   return __arg(std::forward<_Args>(get<_Indexes>(__tuple))...);
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, true>
    {
    public:
      template<typename _Signature> class result;

      template<typename _CVMu, typename _CVArg, typename _Tuple>
 class result<_CVMu(_CVArg, _Tuple)>
 {



   typedef typename _Safe_tuple_element<(is_placeholder<_Arg>::value
      - 1), _Tuple>::type
     __base_type;

 public:
   typedef typename add_rvalue_reference<__base_type>::type type;
 };

      template<typename _Tuple>
 typename result<_Mu(_Arg, _Tuple)>::type
 operator()(const volatile _Arg&, _Tuple& __tuple) const volatile
 {
   return std::forward<typename result<_Mu(_Arg, _Tuple)>::type>(
       ::std::get<(is_placeholder<_Arg>::value - 1)>(__tuple));
 }
    };






  template<typename _Arg>
    class _Mu<_Arg, false, false>
    {
    public:
      template<typename _Signature> struct result;

      template<typename _CVMu, typename _CVArg, typename _Tuple>
 struct result<_CVMu(_CVArg, _Tuple)>
 {
   typedef typename add_lvalue_reference<_CVArg>::type type;
 };


      template<typename _CVArg, typename _Tuple>
 _CVArg&&
 operator()(_CVArg&& __arg, _Tuple&) const volatile
 { return std::forward<_CVArg>(__arg); }
    };






  template<typename _Tp>
    struct _Maybe_wrap_member_pointer
    {
      typedef _Tp type;

      static const _Tp&
      __do_wrap(const _Tp& __x)
      { return __x; }

      static _Tp&&
      __do_wrap(_Tp&& __x)
      { return static_cast<_Tp&&>(__x); }
    };






  template<typename _Tp, typename _Class>
    struct _Maybe_wrap_member_pointer<_Tp _Class::*>
    {
      typedef _Mem_fn<_Tp _Class::*> type;

      static type
      __do_wrap(_Tp _Class::* __pm)
      { return type(__pm); }
    };





  template<>
    struct _Maybe_wrap_member_pointer<void>
    {
      typedef void type;
    };


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(volatile tuple<_Tp...>& __tuple)
    -> typename tuple_element<_Ind, tuple<_Tp...>>::type volatile&
    { return std::get<_Ind>(const_cast<tuple<_Tp...>&>(__tuple)); }


  template<std::size_t _Ind, typename... _Tp>
    inline auto
    __volget(const volatile tuple<_Tp...>& __tuple)
    -> typename tuple_element<_Ind, tuple<_Tp...>>::type const volatile&
    { return std::get<_Ind>(const_cast<const tuple<_Tp...>&>(__tuple)); }


  template<typename _Signature>
    struct _Bind;

   template<typename _Functor, typename... _Bound_args>
    class _Bind<_Functor(_Bound_args...)>
    : public _Weak_result_type<_Functor>
    {
      typedef _Bind __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
 {
   return _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const
 {
   return _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_v(tuple<_Args...>&& __args,
   _Index_tuple<_Indexes...>) volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Result, typename... _Args, std::size_t... _Indexes>
 _Result
 __call_c_v(tuple<_Args...>&& __args,
     _Index_tuple<_Indexes...>) const volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

     public:
      template<typename... _Args>
 explicit _Bind(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind(const _Bind&) = default;

      _Bind(_Bind&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args, typename _Result
 = decltype( std::declval<_Functor>()(
       _Mu<_Bound_args>()( std::declval<_Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
         typename add_const<_Functor>::type>::type>()(
       _Mu<_Bound_args>()( std::declval<const _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) const
 {
   return this->__call_c<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                       typename add_volatile<_Functor>::type>::type>()(
       _Mu<_Bound_args>()( std::declval<volatile _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) volatile
 {
   return this->__call_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args, typename _Result
 = decltype( std::declval<typename enable_if<(sizeof...(_Args) >= 0),
                       typename add_cv<_Functor>::type>::type>()(
       _Mu<_Bound_args>()( std::declval<const volatile _Bound_args&>(),
      std::declval<tuple<_Args...>&>() )... ) )>
 _Result
 operator()(_Args&&... __args) const volatile
 {
   return this->__call_c_v<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };


  template<typename _Result, typename _Signature>
    struct _Bind_result;

  template<typename _Result, typename _Functor, typename... _Bound_args>
    class _Bind_result<_Result, _Functor(_Bound_args...)>
    {
      typedef _Bind_result __self_type;
      typedef typename _Build_index_tuple<sizeof...(_Bound_args)>::__type
 _Bound_indexes;

      _Functor _M_f;
      tuple<_Bound_args...> _M_bound_args;


      template<typename _Res>
 struct __enable_if_void : enable_if<is_void<_Res>::value, int> { };
      template<typename _Res>
 struct __disable_if_void : enable_if<!is_void<_Res>::value, int> { };


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0)
 {
   return _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0)
 {
   _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) const
 {
   return _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) const
 {
   _M_f(_Mu<_Bound_args>()
        (get<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) volatile
 {
   _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 _Result
 __call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>,
     typename __disable_if_void<_Res>::type = 0) const volatile
 {
   return _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }


      template<typename _Res, typename... _Args, std::size_t... _Indexes>
 void
 __call(tuple<_Args...>&& __args,
        _Index_tuple<_Indexes...>,
     typename __enable_if_void<_Res>::type = 0) const volatile
 {
   _M_f(_Mu<_Bound_args>()
        (__volget<_Indexes>(_M_bound_args), __args)...);
 }

    public:
      typedef _Result result_type;

      template<typename... _Args>
 explicit _Bind_result(const _Functor& __f, _Args&&... __args)
 : _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      template<typename... _Args>
 explicit _Bind_result(_Functor&& __f, _Args&&... __args)
 : _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
 { }

      _Bind_result(const _Bind_result&) = default;

      _Bind_result(_Bind_result&& __b)
      : _M_f(std::move(__b._M_f)), _M_bound_args(std::move(__b._M_bound_args))
      { }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args)
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }


      template<typename... _Args>
 result_type
 operator()(_Args&&... __args) const volatile
 {
   return this->__call<_Result>(
       std::forward_as_tuple(std::forward<_Args>(__args)...),
       _Bound_indexes());
 }
    };





  template<typename _Signature>
    struct is_bind_expression<_Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<volatile _Bind<_Signature> >
    : public true_type { };





  template<typename _Signature>
    struct is_bind_expression<const volatile _Bind<_Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<_Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<volatile _Bind_result<_Result, _Signature>>
    : public true_type { };





  template<typename _Result, typename _Signature>
    struct is_bind_expression<const volatile _Bind_result<_Result, _Signature>>
    : public true_type { };




  template<typename _Tp, typename _Tp2 = typename decay<_Tp>::type>
    using __is_socketlike = __or_<is_integral<_Tp2>, is_enum<_Tp2>>;

  template<bool _SocketLike, typename _Func, typename... _BoundArgs>
    struct _Bind_helper
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
 __maybe_type;
      typedef typename __maybe_type::type __func_type;
      typedef _Bind<__func_type(typename decay<_BoundArgs>::type...)> type;
    };




  template<typename _Func, typename... _BoundArgs>
    struct _Bind_helper<true, _Func, _BoundArgs...>
    { };





  template<typename _Func, typename... _BoundArgs>
    inline typename
    _Bind_helper<__is_socketlike<_Func>::value, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bind_helper<false, _Func, _BoundArgs...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::type __result_type;
      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
      std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Result, typename _Func, typename... _BoundArgs>
    struct _Bindres_helper
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
 __maybe_type;
      typedef typename __maybe_type::type __functor_type;
      typedef _Bind_result<_Result,
      __functor_type(typename decay<_BoundArgs>::type...)>
 type;
    };





  template<typename _Result, typename _Func, typename... _BoundArgs>
    inline
    typename _Bindres_helper<_Result, _Func, _BoundArgs...>::type
    bind(_Func&& __f, _BoundArgs&&... __args)
    {
      typedef _Bindres_helper<_Result, _Func, _BoundArgs...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::type __result_type;
      return __result_type(__maybe_type::__do_wrap(std::forward<_Func>(__f)),
      std::forward<_BoundArgs>(__args)...);
    }

  template<typename _Signature>
    struct _Bind_simple;

  template<typename _Callable, typename... _Args>
    struct _Bind_simple<_Callable(_Args...)>
    {
      typedef typename result_of<_Callable(_Args...)>::type result_type;

      template<typename... _Args2, typename = typename
               enable_if< sizeof...(_Args) == sizeof...(_Args2)>::type>
        explicit
        _Bind_simple(const _Callable& __callable, _Args2&&... __args)
        : _M_bound(__callable, std::forward<_Args2>(__args)...)
        { }

      template<typename... _Args2, typename = typename
               enable_if< sizeof...(_Args) == sizeof...(_Args2)>::type>
        explicit
        _Bind_simple(_Callable&& __callable, _Args2&&... __args)
        : _M_bound(std::move(__callable), std::forward<_Args2>(__args)...)
        { }

      _Bind_simple(const _Bind_simple&) = default;
      _Bind_simple(_Bind_simple&&) = default;

      result_type
      operator()()
      {
        typedef typename _Build_index_tuple<sizeof...(_Args)>::__type _Indices;
        return _M_invoke(_Indices());
      }

    private:

      template<std::size_t... _Indices>
        typename result_of<_Callable(_Args...)>::type
        _M_invoke(_Index_tuple<_Indices...>)
        {


          return std::forward<_Callable>(std::get<0>(_M_bound))(
              std::forward<_Args>(std::get<_Indices+1>(_M_bound))...);
        }

      std::tuple<_Callable, _Args...> _M_bound;
    };

  template<typename _Func, typename... _BoundArgs>
    struct _Bind_simple_helper
    {
      typedef _Maybe_wrap_member_pointer<typename decay<_Func>::type>
        __maybe_type;
      typedef typename __maybe_type::type __func_type;
      typedef _Bind_simple<__func_type(typename decay<_BoundArgs>::type...)>
        __type;
    };



  template<typename _Callable, typename... _Args>
    typename _Bind_simple_helper<_Callable, _Args...>::__type
    __bind_simple(_Callable&& __callable, _Args&&... __args)
    {
      typedef _Bind_simple_helper<_Callable, _Args...> __helper_type;
      typedef typename __helper_type::__maybe_type __maybe_type;
      typedef typename __helper_type::__type __result_type;
      return __result_type(
          __maybe_type::__do_wrap( std::forward<_Callable>(__callable)),
          std::forward<_Args>(__args)...);
    }






  class bad_function_call : public std::exception
  {
  public:
    virtual ~bad_function_call() noexcept;

    const char* what() const noexcept;
  };






  template<typename _Tp>
    struct __is_location_invariant
    : integral_constant<bool, (is_pointer<_Tp>::value
          || is_member_pointer<_Tp>::value)>
    { };

  class _Undefined_class;

  union _Nocopy_types
  {
    void* _M_object;
    const void* _M_const_object;
    void (*_M_function_pointer)();
    void (_Undefined_class::*_M_member_pointer)();
  };

  union _Any_data
  {
    void* _M_access() { return &_M_pod_data[0]; }
    const void* _M_access() const { return &_M_pod_data[0]; }

    template<typename _Tp>
      _Tp&
      _M_access()
      { return *static_cast<_Tp*>(_M_access()); }

    template<typename _Tp>
      const _Tp&
      _M_access() const
      { return *static_cast<const _Tp*>(_M_access()); }

    _Nocopy_types _M_unused;
    char _M_pod_data[sizeof(_Nocopy_types)];
  };

  enum _Manager_operation
  {
    __get_type_info,
    __get_functor_ptr,
    __clone_functor,
    __destroy_functor
  };



  template<typename _Tp>
    struct _Simple_type_wrapper
    {
      _Simple_type_wrapper(_Tp __value) : __value(__value) { }

      _Tp __value;
    };

  template<typename _Tp>
    struct __is_location_invariant<_Simple_type_wrapper<_Tp> >
    : __is_location_invariant<_Tp>
    { };



  template<typename _Functor>
    inline _Functor&
    __callable_functor(_Functor& __f)
    { return __f; }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* const &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* volatile &__p)
    { return std::mem_fn(__p); }

  template<typename _Member, typename _Class>
    inline _Mem_fn<_Member _Class::*>
    __callable_functor(_Member _Class::* const volatile &__p)
    { return std::mem_fn(__p); }

  template<typename _Signature>
    class function;


  class _Function_base
  {
  public:
    static const std::size_t _M_max_size = sizeof(_Nocopy_types);
    static const std::size_t _M_max_align = __alignof__(_Nocopy_types);

    template<typename _Functor>
      class _Base_manager
      {
      protected:
 static const bool __stored_locally =
 (__is_location_invariant<_Functor>::value
  && sizeof(_Functor) <= _M_max_size
  && __alignof__(_Functor) <= _M_max_align
  && (_M_max_align % __alignof__(_Functor) == 0));

 typedef integral_constant<bool, __stored_locally> _Local_storage;


 static _Functor*
 _M_get_pointer(const _Any_data& __source)
 {
   const _Functor* __ptr =
     __stored_locally? std::__addressof(__source._M_access<_Functor>())
                                 : __source._M_access<_Functor*>();
   return const_cast<_Functor*>(__ptr);
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
 {
   new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 }



 static void
 _M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
 {
   __dest._M_access<_Functor*>() =
     new _Functor(*__source._M_access<_Functor*>());
 }



 static void
 _M_destroy(_Any_data& __victim, true_type)
 {
   __victim._M_access<_Functor>().~_Functor();
 }


 static void
 _M_destroy(_Any_data& __victim, false_type)
 {
   delete __victim._M_access<_Functor*>();
 }

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = _M_get_pointer(__source);
       break;

     case __clone_functor:
       _M_clone(__dest, __source, _Local_storage());
       break;

     case __destroy_functor:
       _M_destroy(__dest, _Local_storage());
       break;
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f)
 { _M_init_functor(__functor, std::move(__f), _Local_storage()); }

 template<typename _Signature>
   static bool
   _M_not_empty_function(const function<_Signature>& __f)
   { return static_cast<bool>(__f); }

 template<typename _Tp>
   static bool
   _M_not_empty_function(_Tp* const& __fp)
   { return __fp; }

 template<typename _Class, typename _Tp>
   static bool
   _M_not_empty_function(_Tp _Class::* const& __mp)
   { return __mp; }

 template<typename _Tp>
   static bool
   _M_not_empty_function(const _Tp&)
   { return true; }

      private:
 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
 { new (__functor._M_access()) _Functor(std::move(__f)); }

 static void
 _M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
 { __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
      };

    template<typename _Functor>
      class _Ref_manager : public _Base_manager<_Functor*>
      {
 typedef _Function_base::_Base_manager<_Functor*> _Base;

      public:
 static bool
 _M_manager(_Any_data& __dest, const _Any_data& __source,
     _Manager_operation __op)
 {
   switch (__op)
     {

     case __get_type_info:
       __dest._M_access<const type_info*>() = &typeid(_Functor);
       break;

     case __get_functor_ptr:
       __dest._M_access<_Functor*>() = *_Base::_M_get_pointer(__source);
       return is_const<_Functor>::value;
       break;

     default:
       _Base::_M_manager(__dest, __source, __op);
     }
   return false;
 }

 static void
 _M_init_functor(_Any_data& __functor, reference_wrapper<_Functor> __f)
 {
   _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
 }
      };

    _Function_base() : _M_manager(0) { }

    ~_Function_base()
    {
      if (_M_manager)
 _M_manager(_M_functor, _M_functor, __destroy_functor);
    }


    bool _M_empty() const { return !_M_manager; }

    typedef bool (*_Manager_type)(_Any_data&, const _Any_data&,
      _Manager_operation);

    _Any_data _M_functor;
    _Manager_type _M_manager;
  };

  template<typename _Signature, typename _Functor>
    class _Function_handler;

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

    public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 return (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Functor>
    : public _Function_base::_Base_manager<_Functor>
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 (*_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Res, typename _Functor, typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 return __callable_functor(**_Base::_M_get_pointer(__functor))(
       std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Functor, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), reference_wrapper<_Functor> >
    : public _Function_base::_Ref_manager<_Functor>
    {
      typedef _Function_base::_Ref_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 __callable_functor(**_Base::_M_get_pointer(__functor))(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename _Res,
    typename... _ArgTypes>
    class _Function_handler<_Res(_ArgTypes...), _Member _Class::*>
    : public _Function_handler<void(_ArgTypes...), _Member _Class::*>
    {
      typedef _Function_handler<void(_ArgTypes...), _Member _Class::*>
 _Base;

     public:
      static _Res
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 return std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _Class, typename _Member, typename... _ArgTypes>
    class _Function_handler<void(_ArgTypes...), _Member _Class::*>
    : public _Function_base::_Base_manager<
   _Simple_type_wrapper< _Member _Class::* > >
    {
      typedef _Member _Class::* _Functor;
      typedef _Simple_type_wrapper<_Functor> _Wrapper;
      typedef _Function_base::_Base_manager<_Wrapper> _Base;

    public:
      static bool
      _M_manager(_Any_data& __dest, const _Any_data& __source,
   _Manager_operation __op)
      {
 switch (__op)
   {

   case __get_type_info:
     __dest._M_access<const type_info*>() = &typeid(_Functor);
     break;

   case __get_functor_ptr:
     __dest._M_access<_Functor*>() =
       &_Base::_M_get_pointer(__source)->__value;
     break;

   default:
     _Base::_M_manager(__dest, __source, __op);
   }
 return false;
      }

      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes... __args)
      {
 std::mem_fn(_Base::_M_get_pointer(__functor)->__value)(
     std::forward<_ArgTypes>(__args)...);
      }
    };

  template<typename _From, typename _To>
    using __check_func_return_type
      = __or_<is_void<_To>, is_convertible<_From, _To>>;







  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
    : public _Maybe_unary_or_binary_function<_Res, _ArgTypes...>,
      private _Function_base
    {
      typedef _Res _Signature_type(_ArgTypes...);

      template<typename _Functor>
 using _Invoke = decltype(__callable_functor(std::declval<_Functor&>())
     (std::declval<_ArgTypes>()...) );



      template<typename _Tp>
 using _NotSelf = __not_<is_same<_Tp, function>>;

      template<typename _Functor>
 using _Callable
   = __and_<_NotSelf<_Functor>,
     __check_func_return_type<_Invoke<_Functor>, _Res>>;

      template<typename _Cond, typename _Tp>
 using _Requires = typename enable_if<_Cond::value, _Tp>::type;

    public:
      typedef _Res result_type;







      function() noexcept
      : _Function_base() { }





      function(nullptr_t) noexcept
      : _Function_base() { }
# 2192 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
      function(const function& __x);
# 2201 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
      function(function&& __x) : _Function_base()
      {
 __x.swap(*this);
      }
# 2224 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
      template<typename _Functor,
        typename = _Requires<_Callable<_Functor>, void>>
 function(_Functor);
# 2240 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
      function&
      operator=(const function& __x)
      {
 function(__x).swap(*this);
 return *this;
      }
# 2258 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
      function&
      operator=(function&& __x)
      {
 function(std::move(__x)).swap(*this);
 return *this;
      }
# 2272 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
      function&
      operator=(nullptr_t)
      {
 if (_M_manager)
   {
     _M_manager(_M_functor, _M_functor, __destroy_functor);
     _M_manager = 0;
     _M_invoker = 0;
   }
 return *this;
      }
# 2300 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
      template<typename _Functor>
 _Requires<_Callable<typename decay<_Functor>::type>, function&>
 operator=(_Functor&& __f)
 {
   function(std::forward<_Functor>(__f)).swap(*this);
   return *this;
 }


      template<typename _Functor>
 function&
 operator=(reference_wrapper<_Functor> __f) noexcept
 {
   function(__f).swap(*this);
   return *this;
 }
# 2326 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
      void swap(function& __x)
      {
 std::swap(_M_functor, __x._M_functor);
 std::swap(_M_manager, __x._M_manager);
 std::swap(_M_invoker, __x._M_invoker);
      }
# 2354 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
      explicit operator bool() const noexcept
      { return !_M_empty(); }
# 2367 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
      _Res operator()(_ArgTypes... __args) const;
# 2380 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
      const type_info& target_type() const noexcept;
# 2391 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
      template<typename _Functor> _Functor* target() noexcept;


      template<typename _Functor> const _Functor* target() const noexcept;


    private:
      typedef _Res (*_Invoker_type)(const _Any_data&, _ArgTypes...);
      _Invoker_type _M_invoker;
  };


  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 {
   _M_invoker = __x._M_invoker;
   _M_manager = __x._M_manager;
   __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 }
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor, typename>
      function<_Res(_ArgTypes...)>::
      function(_Functor __f)
      : _Function_base()
      {
 typedef _Function_handler<_Signature_type, _Functor> _My_handler;

 if (_My_handler::_M_not_empty_function(__f))
   {
     _My_handler::_M_init_functor(_M_functor, std::move(__f));
     _M_invoker = &_My_handler::_M_invoke;
     _M_manager = &_My_handler::_M_manager;
   }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 __throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
    }


  template<typename _Res, typename... _ArgTypes>
    const type_info&
    function<_Res(_ArgTypes...)>::
    target_type() const noexcept
    {
      if (_M_manager)
 {
   _Any_data __typeinfo_result;
   _M_manager(__typeinfo_result, _M_functor, __get_type_info);
   return *__typeinfo_result._M_access<const type_info*>();
 }
      else
 return typeid(void);
    }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      _Functor*
      function<_Res(_ArgTypes...)>::
      target() noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     if (_M_manager(__ptr, _M_functor, __get_functor_ptr)
  && !is_const<_Functor>::value)
       return 0;
     else
       return __ptr._M_access<_Functor*>();
   }
 else
   return 0;
      }

  template<typename _Res, typename... _ArgTypes>
    template<typename _Functor>
      const _Functor*
      function<_Res(_ArgTypes...)>::
      target() const noexcept
      {
 if (typeid(_Functor) == target_type() && _M_manager)
   {
     _Any_data __ptr;
     _M_manager(__ptr, _M_functor, __get_functor_ptr);
     return __ptr._M_access<const _Functor*>();
   }
 else
   return 0;
      }
# 2503 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator==(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return !static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator==(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return !static_cast<bool>(__f); }
# 2521 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
  template<typename _Res, typename... _Args>
    inline bool
    operator!=(const function<_Res(_Args...)>& __f, nullptr_t) noexcept
    { return static_cast<bool>(__f); }


  template<typename _Res, typename... _Args>
    inline bool
    operator!=(nullptr_t, const function<_Res(_Args...)>& __f) noexcept
    { return static_cast<bool>(__f); }
# 2539 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/functional" 3
  template<typename _Res, typename... _Args>
    inline void
    swap(function<_Res(_Args...)>& __x, function<_Res(_Args...)>& __y)
    { __x.swap(__y); }


}
# 10 "../Quadris/Engine.h" 2
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/unordered_map" 1
# 32 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/unordered_map"
       
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/unordered_map" 3
# 43 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/unordered_map" 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/alloc_traits.h" 1 3
# 32 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/alloc_traits.h" 3
       
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/alloc_traits.h" 3



# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 1 3
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Alloc, typename _Tp>
    class __alloctr_rebind_helper
    {
      template<typename _Alloc2, typename _Tp2>
 static constexpr true_type
 _S_chk(typename _Alloc2::template rebind<_Tp2>::other*);

      template<typename, typename>
 static constexpr false_type
 _S_chk(...);

    public:
      using __type = decltype(_S_chk<_Alloc, _Tp>(nullptr));
    };

  template<typename _Alloc, typename _Tp,
    bool = __alloctr_rebind_helper<_Alloc, _Tp>::__type::value>
    struct __alloctr_rebind;

  template<typename _Alloc, typename _Tp>
    struct __alloctr_rebind<_Alloc, _Tp, true>
    {
      typedef typename _Alloc::template rebind<_Tp>::other __type;
    };

  template<template<typename, typename...> class _Alloc, typename _Tp,
    typename _Up, typename... _Args>
    struct __alloctr_rebind<_Alloc<_Up, _Args...>, _Tp, false>
    {
      typedef _Alloc<_Tp, _Args...> __type;
    };





  template<typename _Alloc>
    struct allocator_traits
    {

      typedef _Alloc allocator_type;

      typedef typename _Alloc::value_type value_type;
# 95 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
private: template<typename _Tp> static typename _Tp::pointer _S_pointer_helper(_Tp*); static value_type* _S_pointer_helper(...); typedef decltype(_S_pointer_helper((_Alloc*)0)) __pointer; public:






      typedef __pointer pointer;

private: template<typename _Tp> static typename _Tp::const_pointer _S_const_pointer_helper(_Tp*); static typename pointer_traits<pointer>::template rebind<const value_type> _S_const_pointer_helper(...); typedef decltype(_S_const_pointer_helper((_Alloc*)0)) __const_pointer; public:
# 113 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
      typedef __const_pointer const_pointer;

private: template<typename _Tp> static typename _Tp::void_pointer _S_void_pointer_helper(_Tp*); static typename pointer_traits<pointer>::template rebind<void> _S_void_pointer_helper(...); typedef decltype(_S_void_pointer_helper((_Alloc*)0)) __void_pointer; public:
# 124 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
      typedef __void_pointer void_pointer;

private: template<typename _Tp> static typename _Tp::const_void_pointer _S_const_void_pointer_helper(_Tp*); static typename pointer_traits<pointer>::template rebind<const void> _S_const_void_pointer_helper(...); typedef decltype(_S_const_void_pointer_helper((_Alloc*)0)) __const_void_pointer; public:
# 135 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
      typedef __const_void_pointer const_void_pointer;

private: template<typename _Tp> static typename _Tp::difference_type _S_difference_type_helper(_Tp*); static typename pointer_traits<pointer>::difference_type _S_difference_type_helper(...); typedef decltype(_S_difference_type_helper((_Alloc*)0)) __difference_type; public:
# 146 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
      typedef __difference_type difference_type;

private: template<typename _Tp> static typename _Tp::size_type _S_size_type_helper(_Tp*); static typename make_unsigned<difference_type>::type _S_size_type_helper(...); typedef decltype(_S_size_type_helper((_Alloc*)0)) __size_type; public:
# 157 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
      typedef __size_type size_type;

private: template<typename _Tp> static typename _Tp::propagate_on_container_copy_assignment _S_propagate_on_container_copy_assignment_helper(_Tp*); static false_type _S_propagate_on_container_copy_assignment_helper(...); typedef decltype(_S_propagate_on_container_copy_assignment_helper((_Alloc*)0)) __propagate_on_container_copy_assignment; public:
# 168 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
      typedef __propagate_on_container_copy_assignment
 propagate_on_container_copy_assignment;

private: template<typename _Tp> static typename _Tp::propagate_on_container_move_assignment _S_propagate_on_container_move_assignment_helper(_Tp*); static false_type _S_propagate_on_container_move_assignment_helper(...); typedef decltype(_S_propagate_on_container_move_assignment_helper((_Alloc*)0)) __propagate_on_container_move_assignment; public:
# 180 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
      typedef __propagate_on_container_move_assignment
 propagate_on_container_move_assignment;

private: template<typename _Tp> static typename _Tp::propagate_on_container_swap _S_propagate_on_container_swap_helper(_Tp*); static false_type _S_propagate_on_container_swap_helper(...); typedef decltype(_S_propagate_on_container_swap_helper((_Alloc*)0)) __propagate_on_container_swap; public:
# 192 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
      typedef __propagate_on_container_swap propagate_on_container_swap;



      template<typename _Tp>
 using rebind_alloc = typename __alloctr_rebind<_Alloc, _Tp>::__type;
      template<typename _Tp>
 using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;

    private:
      template<typename _Alloc2>
 struct __allocate_helper
 {
   template<typename _Alloc3,
     typename = decltype(std::declval<_Alloc3*>()->allocate(
    std::declval<size_type>(),
    std::declval<const_void_pointer>()))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Alloc2>
 using __has_allocate = typename __allocate_helper<_Alloc2>::type;

      template<typename _Alloc2,
        typename = _Require<__has_allocate<_Alloc2>>>
 static pointer
 _S_allocate(_Alloc2& __a, size_type __n, const_void_pointer __hint)
 { return __a.allocate(__n, __hint); }

      template<typename _Alloc2, typename _UnusedHint,
        typename = _Require<__not_<__has_allocate<_Alloc2>>>>
 static pointer
 _S_allocate(_Alloc2& __a, size_type __n, _UnusedHint)
 { return __a.allocate(__n); }

      template<typename _Tp, typename... _Args>
 struct __construct_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->construct(
    std::declval<_Tp*>(), std::declval<_Args>()...))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp, typename... _Args>
 using __has_construct
   = typename __construct_helper<_Tp, _Args...>::type;

      template<typename _Tp, typename... _Args>
 static _Require<__has_construct<_Tp, _Args...>>
 _S_construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 { __a.construct(__p, std::forward<_Args>(__args)...); }

      template<typename _Tp, typename... _Args>
 static
 _Require<__and_<__not_<__has_construct<_Tp, _Args...>>,
          is_constructible<_Tp, _Args...>>>
 _S_construct(_Alloc&, _Tp* __p, _Args&&... __args)
 { ::new((void*)__p) _Tp(std::forward<_Args>(__args)...); }

      template<typename _Tp>
 struct __destroy_helper
 {
   template<typename _Alloc2,
     typename = decltype(std::declval<_Alloc2*>()->destroy(
    std::declval<_Tp*>()))>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc>(0));
 };

      template<typename _Tp>
 using __has_destroy = typename __destroy_helper<_Tp>::type;

      template<typename _Tp>
 static _Require<__has_destroy<_Tp>>
 _S_destroy(_Alloc& __a, _Tp* __p)
 { __a.destroy(__p); }

      template<typename _Tp>
 static _Require<__not_<__has_destroy<_Tp>>>
 _S_destroy(_Alloc&, _Tp* __p)
 { __p->~_Tp(); }

      template<typename _Alloc2>
 struct __maxsize_helper
 {
   template<typename _Alloc3,
     typename = decltype(std::declval<_Alloc3*>()->max_size())>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc2>(0));
 };

      template<typename _Alloc2>
 using __has_max_size = typename __maxsize_helper<_Alloc2>::type;

      template<typename _Alloc2,
        typename = _Require<__has_max_size<_Alloc2>>>
 static size_type
 _S_max_size(_Alloc2& __a, int)
 { return __a.max_size(); }

      template<typename _Alloc2,
        typename = _Require<__not_<__has_max_size<_Alloc2>>>>
 static size_type
 _S_max_size(_Alloc2&, ...)
 { return __gnu_cxx::__numeric_traits<size_type>::__max; }

      template<typename _Alloc2>
 struct __select_helper
 {
   template<typename _Alloc3, typename
     = decltype(std::declval<_Alloc3*>()
  ->select_on_container_copy_construction())>
     static true_type __test(int);

   template<typename>
     static false_type __test(...);

   using type = decltype(__test<_Alloc2>(0));
 };

      template<typename _Alloc2>
 using __has_soccc = typename __select_helper<_Alloc2>::type;

      template<typename _Alloc2,
        typename = _Require<__has_soccc<_Alloc2>>>
 static _Alloc2
 _S_select(_Alloc2& __a, int)
 { return __a.select_on_container_copy_construction(); }

      template<typename _Alloc2,
        typename = _Require<__not_<__has_soccc<_Alloc2>>>>
 static _Alloc2
 _S_select(_Alloc2& __a, ...)
 { return __a; }

    public:
# 355 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n)
      { return __a.allocate(__n); }
# 370 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
      static pointer
      allocate(_Alloc& __a, size_type __n, const_void_pointer __hint)
      { return _S_allocate(__a, __n, __hint); }
# 382 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
      static void deallocate(_Alloc& __a, pointer __p, size_type __n)
      { __a.deallocate(__p, __n); }
# 396 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
      template<typename _Tp, typename... _Args>
 static auto construct(_Alloc& __a, _Tp* __p, _Args&&... __args)
 -> decltype(_S_construct(__a, __p, std::forward<_Args>(__args)...))
 { _S_construct(__a, __p, std::forward<_Args>(__args)...); }
# 409 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
      template <class _Tp>
 static void destroy(_Alloc& __a, _Tp* __p)
 { _S_destroy(__a, __p); }
# 421 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
      static size_type max_size(const _Alloc& __a) noexcept
      { return _S_max_size(__a, 0); }
# 432 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/alloc_traits.h" 3
      static _Alloc
      select_on_container_copy_construction(const _Alloc& __rhs)
      { return _S_select(__rhs, 0); }
    };

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc& __one, const _Alloc& __two, true_type)
    { __one = __two; }

  template<typename _Alloc>
    inline void
    __do_alloc_on_copy(_Alloc&, const _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_copy(_Alloc& __one, const _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_copy_assignment __pocca;
      __do_alloc_on_copy(__one, __two, __pocca());
    }

  template<typename _Alloc>
    inline _Alloc __alloc_on_copy(const _Alloc& __a)
    {
      typedef allocator_traits<_Alloc> __traits;
      return __traits::select_on_container_copy_construction(__a);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc& __one, _Alloc& __two, true_type)
    { __one = std::move(__two); }

  template<typename _Alloc>
    inline void __do_alloc_on_move(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_move(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_move_assignment __pocma;
      __do_alloc_on_move(__one, __two, __pocma());
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc& __one, _Alloc& __two, true_type)
    {
      using std::swap;
      swap(__one, __two);
    }

  template<typename _Alloc>
    inline void __do_alloc_on_swap(_Alloc&, _Alloc&, false_type)
    { }

  template<typename _Alloc>
    inline void __alloc_on_swap(_Alloc& __one, _Alloc& __two)
    {
      typedef allocator_traits<_Alloc> __traits;
      typedef typename __traits::propagate_on_container_swap __pocs;
      __do_alloc_on_swap(__one, __two, __pocs());
    }

  template<typename _Alloc>
    class __is_copy_insertable_impl
    {
      typedef allocator_traits<_Alloc> _Traits;

      template<typename _Up, typename
        = decltype(_Traits::construct(std::declval<_Alloc&>(),
          std::declval<_Up*>(),
          std::declval<const _Up&>()))>
 static true_type
 _M_select(int);

      template<typename _Up>
 static false_type
 _M_select(...);

    public:
      typedef decltype(_M_select<typename _Alloc::value_type>(0)) type;
    };


  template<typename _Alloc>
    struct __is_copy_insertable
    : __is_copy_insertable_impl<_Alloc>::type
    { };


  template<typename _Tp>
    struct __is_copy_insertable<allocator<_Tp>>
    : is_copy_constructible<_Tp>
    { };


}
# 37 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/alloc_traits.h" 2 3




namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{



  template<typename _Alloc>
    struct __allocator_always_compares_equal : std::false_type { };

  template<typename _Tp>
    struct __allocator_always_compares_equal<std::allocator<_Tp>>
    : std::true_type { };

  template<typename, typename> struct array_allocator;

  template<typename _Tp, typename _Array>
    struct __allocator_always_compares_equal<array_allocator<_Tp, _Array>>
    : std::true_type { };

  template<typename> struct bitmap_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<bitmap_allocator<_Tp>>
    : std::true_type { };

  template<typename> struct malloc_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<malloc_allocator<_Tp>>
    : std::true_type { };

  template<typename> struct mt_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<mt_allocator<_Tp>>
    : std::true_type { };

  template<typename> struct new_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<new_allocator<_Tp>>
    : std::true_type { };

  template<typename> struct pool_allocator;

  template<typename _Tp>
    struct __allocator_always_compares_equal<pool_allocator<_Tp>>
    : std::true_type { };






template<typename _Alloc>
  struct __alloc_traits

  : std::allocator_traits<_Alloc>

  {
    typedef _Alloc allocator_type;

    typedef std::allocator_traits<_Alloc> _Base_type;
    typedef typename _Base_type::value_type value_type;
    typedef typename _Base_type::pointer pointer;
    typedef typename _Base_type::const_pointer const_pointer;
    typedef typename _Base_type::size_type size_type;
    typedef typename _Base_type::difference_type difference_type;

    typedef value_type& reference;
    typedef const value_type& const_reference;
    using _Base_type::allocate;
    using _Base_type::deallocate;
    using _Base_type::construct;
    using _Base_type::destroy;
    using _Base_type::max_size;

  private:
    template<typename _Ptr>
      using __is_custom_pointer
 = std::__and_<std::is_same<pointer, _Ptr>,
        std::__not_<std::is_pointer<_Ptr>>>;

  public:

    template<typename _Ptr, typename... _Args>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      construct(_Alloc& __a, _Ptr __p, _Args&&... __args)
      {
 _Base_type::construct(__a, std::addressof(*__p),
         std::forward<_Args>(__args)...);
      }


    template<typename _Ptr>
      static typename std::enable_if<__is_custom_pointer<_Ptr>::value>::type
      destroy(_Alloc& __a, _Ptr __p)
      { _Base_type::destroy(__a, std::addressof(*__p)); }

    static _Alloc _S_select_on_copy(const _Alloc& __a)
    { return _Base_type::select_on_container_copy_construction(__a); }

    static void _S_on_swap(_Alloc& __a, _Alloc& __b)
    { std::__alloc_on_swap(__a, __b); }

    static constexpr bool _S_propagate_on_copy_assign()
    { return _Base_type::propagate_on_container_copy_assignment::value; }

    static constexpr bool _S_propagate_on_move_assign()
    { return _Base_type::propagate_on_container_move_assignment::value; }

    static constexpr bool _S_propagate_on_swap()
    { return _Base_type::propagate_on_container_swap::value; }

    static constexpr bool _S_always_equal()
    { return __allocator_always_compares_equal<_Alloc>::value; }

    static constexpr bool _S_nothrow_move()
    { return _S_propagate_on_move_assign() || _S_always_equal(); }

    static constexpr bool _S_nothrow_swap()
    {
      using std::swap;
      return !_S_propagate_on_swap()
        || noexcept(swap(std::declval<_Alloc&>(), std::declval<_Alloc&>()));
    }

    template<typename _Tp>
      struct rebind
      { typedef typename _Base_type::template rebind_alloc<_Tp> other; };
# 210 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/alloc_traits.h" 3
  };


}
# 44 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/unordered_map" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/aligned_buffer.h" 1 3
# 32 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/aligned_buffer.h" 3
       
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/aligned_buffer.h" 3







namespace __gnu_cxx
{
  template<typename _Tp>
    struct __aligned_buffer
    : std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>
    {
      typename
 std::aligned_storage<sizeof(_Tp), std::alignment_of<_Tp>::value>::type
 _M_storage;

      void*
      _M_addr() noexcept
      {
        return static_cast<void*>(&_M_storage);
      }

      const void*
      _M_addr() const noexcept
      {
        return static_cast<const void*>(&_M_storage);
      }

      _Tp*
      _M_ptr() noexcept
      { return static_cast<_Tp*>(_M_addr()); }

      const _Tp*
      _M_ptr() const noexcept
      { return static_cast<const _Tp*>(_M_addr()); }
    };

}
# 45 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/unordered_map" 2 3


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/hashtable.h" 1 3
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/hashtable.h" 3
       
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/hashtable.h" 3

# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/hashtable_policy.h" 1 3
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/hashtable_policy.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable;



namespace __detail
{







  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
    struct _Hashtable_base;



  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::input_iterator_tag)
    { return 0; }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last,
    std::forward_iterator_tag)
    { return std::distance(__first, __last); }

  template<class _Iterator>
    inline typename std::iterator_traits<_Iterator>::difference_type
    __distance_fw(_Iterator __first, _Iterator __last)
    {
      typedef typename std::iterator_traits<_Iterator>::iterator_category _Tag;
      return __distance_fw(__first, __last, _Tag());
    }


  template <typename _Key, typename _Hash>
    struct __is_noexcept_hash : std::integral_constant<bool,
 noexcept(declval<const _Hash&>()(declval<const _Key&>()))>
    { };

  struct _Identity
  {
    template<typename _Tp>
      _Tp&&
      operator()(_Tp&& __x) const
      { return std::forward<_Tp>(__x); }
  };

  struct _Select1st
  {
    template<typename _Tp>
      auto
      operator()(_Tp&& __x) const
      -> decltype(std::get<0>(std::forward<_Tp>(__x)))
      { return std::get<0>(std::forward<_Tp>(__x)); }
  };

  template<typename _NodeAlloc>
    struct _Hashtable_alloc;



  template<typename _NodeAlloc>
    struct _ReuseOrAllocNode
    {
    private:
      using __node_alloc_type = _NodeAlloc;
      using __hashtable_alloc = _Hashtable_alloc<__node_alloc_type>;
      using __value_alloc_type = typename __hashtable_alloc::__value_alloc_type;
      using __value_alloc_traits =
 typename __hashtable_alloc::__value_alloc_traits;
      using __node_alloc_traits =
 typename __hashtable_alloc::__node_alloc_traits;
      using __node_type = typename __hashtable_alloc::__node_type;

    public:
      _ReuseOrAllocNode(__node_type* __nodes, __hashtable_alloc& __h)
 : _M_nodes(__nodes), _M_h(__h) { }
      _ReuseOrAllocNode(const _ReuseOrAllocNode&) = delete;

      ~_ReuseOrAllocNode()
      { _M_h._M_deallocate_nodes(_M_nodes); }

      template<typename _Arg>
 __node_type*
 operator()(_Arg&& __arg) const
 {
   if (_M_nodes)
     {
       __node_type* __node = _M_nodes;
       _M_nodes = _M_nodes->_M_next();
       __node->_M_nxt = nullptr;
       __value_alloc_type __a(_M_h._M_node_allocator());
       __value_alloc_traits::destroy(__a, __node->_M_valptr());
       try
  {
    __value_alloc_traits::construct(__a, __node->_M_valptr(),
        std::forward<_Arg>(__arg));
  }
       catch(...)
  {
    __node->~__node_type();
    __node_alloc_traits::deallocate(_M_h._M_node_allocator(),
        __node, 1);
    throw;
  }
       return __node;
     }
   return _M_h._M_allocate_node(std::forward<_Arg>(__arg));
 }

    private:
      mutable __node_type* _M_nodes;
      __hashtable_alloc& _M_h;
    };



  template<typename _NodeAlloc>
    struct _AllocNode
    {
    private:
      using __hashtable_alloc = _Hashtable_alloc<_NodeAlloc>;
      using __node_type = typename __hashtable_alloc::__node_type;

    public:
      _AllocNode(__hashtable_alloc& __h)
 : _M_h(__h) { }

      template<typename _Arg>
 __node_type*
 operator()(_Arg&& __arg) const
 { return _M_h._M_allocate_node(std::forward<_Arg>(__arg)); }

    private:
      __hashtable_alloc& _M_h;
    };
# 211 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/hashtable_policy.h" 3
  template<bool _Cache_hash_code, bool _Constant_iterators, bool _Unique_keys>
    struct _Hashtable_traits
    {
      template<bool _Cond>
 using __bool_constant = integral_constant<bool, _Cond>;

      using __hash_cached = __bool_constant<_Cache_hash_code>;
      using __constant_iterators = __bool_constant<_Constant_iterators>;
      using __unique_keys = __bool_constant<_Unique_keys>;
    };
# 230 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/hashtable_policy.h" 3
  struct _Hash_node_base
  {
    _Hash_node_base* _M_nxt;

    _Hash_node_base() noexcept : _M_nxt() { }

    _Hash_node_base(_Hash_node_base* __next) noexcept : _M_nxt(__next) { }
  };






  template<typename _Value>
    struct _Hash_node_value_base : _Hash_node_base
    {
      typedef _Value value_type;

      __gnu_cxx::__aligned_buffer<_Value> _M_storage;

      _Value*
      _M_valptr() noexcept
      { return _M_storage._M_ptr(); }

      const _Value*
      _M_valptr() const noexcept
      { return _M_storage._M_ptr(); }

      _Value&
      _M_v() noexcept
      { return *_M_valptr(); }

      const _Value&
      _M_v() const noexcept
      { return *_M_valptr(); }
    };




  template<typename _Value, bool _Cache_hash_code>
    struct _Hash_node;






  template<typename _Value>
    struct _Hash_node<_Value, true> : _Hash_node_value_base<_Value>
    {
      std::size_t _M_hash_code;

      _Hash_node*
      _M_next() const noexcept
      { return static_cast<_Hash_node*>(this->_M_nxt); }
    };






  template<typename _Value>
    struct _Hash_node<_Value, false> : _Hash_node_value_base<_Value>
    {
      _Hash_node*
      _M_next() const noexcept
      { return static_cast<_Hash_node*>(this->_M_nxt); }
    };


  template<typename _Value, bool _Cache_hash_code>
    struct _Node_iterator_base
    {
      using __node_type = _Hash_node<_Value, _Cache_hash_code>;

      __node_type* _M_cur;

      _Node_iterator_base(__node_type* __p) noexcept
      : _M_cur(__p) { }

      void
      _M_incr() noexcept
      { _M_cur = _M_cur->_M_next(); }
    };

  template<typename _Value, bool _Cache_hash_code>
    inline bool
    operator==(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
        const _Node_iterator_base<_Value, _Cache_hash_code >& __y)
    noexcept
    { return __x._M_cur == __y._M_cur; }

  template<typename _Value, bool _Cache_hash_code>
    inline bool
    operator!=(const _Node_iterator_base<_Value, _Cache_hash_code>& __x,
        const _Node_iterator_base<_Value, _Cache_hash_code>& __y)
    noexcept
    { return __x._M_cur != __y._M_cur; }


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      using pointer = typename std::conditional<__constant_iterators,
      const _Value*, _Value*>::type;

      using reference = typename std::conditional<__constant_iterators,
        const _Value&, _Value&>::type;

      _Node_iterator() noexcept
      : __base_type(0) { }

      explicit
      _Node_iterator(__node_type* __p) noexcept
      : __base_type(__p) { }

      reference
      operator*() const noexcept
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const noexcept
      { return this->_M_cur->_M_valptr(); }

      _Node_iterator&
      operator++() noexcept
      {
 this->_M_incr();
 return *this;
      }

      _Node_iterator
      operator++(int) noexcept
      {
 _Node_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Value, bool __constant_iterators, bool __cache>
    struct _Node_const_iterator
    : public _Node_iterator_base<_Value, __cache>
    {
    private:
      using __base_type = _Node_iterator_base<_Value, __cache>;
      using __node_type = typename __base_type::__node_type;

    public:
      typedef _Value value_type;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      typedef const _Value* pointer;
      typedef const _Value& reference;

      _Node_const_iterator() noexcept
      : __base_type(0) { }

      explicit
      _Node_const_iterator(__node_type* __p) noexcept
      : __base_type(__p) { }

      _Node_const_iterator(const _Node_iterator<_Value, __constant_iterators,
      __cache>& __x) noexcept
      : __base_type(__x._M_cur) { }

      reference
      operator*() const noexcept
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const noexcept
      { return this->_M_cur->_M_valptr(); }

      _Node_const_iterator&
      operator++() noexcept
      {
 this->_M_incr();
 return *this;
      }

      _Node_const_iterator
      operator++(int) noexcept
      {
 _Node_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };






  struct _Mod_range_hashing
  {
    typedef std::size_t first_argument_type;
    typedef std::size_t second_argument_type;
    typedef std::size_t result_type;

    result_type
    operator()(first_argument_type __num,
        second_argument_type __den) const noexcept
    { return __num % __den; }
  };






  struct _Default_ranged_hash { };



  struct _Prime_rehash_policy
  {
    _Prime_rehash_policy(float __z = 1.0)
    : _M_max_load_factor(__z), _M_next_resize(0) { }

    float
    max_load_factor() const noexcept
    { return _M_max_load_factor; }


    std::size_t
    _M_next_bkt(std::size_t __n) const;


    std::size_t
    _M_bkt_for_elements(std::size_t __n) const
    { return __builtin_ceil(__n / (long double)_M_max_load_factor); }





    std::pair<bool, std::size_t>
    _M_need_rehash(std::size_t __n_bkt, std::size_t __n_elt,
     std::size_t __n_ins) const;

    typedef std::size_t _State;

    _State
    _M_state() const
    { return _M_next_resize; }

    void
    _M_reset() noexcept
    { _M_next_resize = 0; }

    void
    _M_reset(_State __state)
    { _M_next_resize = __state; }

    enum { _S_n_primes = sizeof(unsigned long) != 8 ? 256 : 256 + 48 };

    static const std::size_t _S_growth_factor = 2;

    float _M_max_load_factor;
    mutable std::size_t _M_next_resize;
  };
# 527 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Map_base { };


  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
    {
      using mapped_type = typename std::tuple_element<1, _Pair>::type;
    };


  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
    {
    private:
      using __hashtable_base = __detail::_Hashtable_base<_Key, _Pair,
        _Select1st,
       _Equal, _H1, _H2, _Hash,
         _Traits>;

      using __hashtable = _Hashtable<_Key, _Pair, _Alloc,
         _Select1st, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      using __hash_code = typename __hashtable_base::__hash_code;
      using __node_type = typename __hashtable_base::__node_type;

    public:
      using key_type = typename __hashtable_base::key_type;
      using iterator = typename __hashtable_base::iterator;
      using mapped_type = typename std::tuple_element<1, _Pair>::type;

      mapped_type&
      operator[](const key_type& __k);

      mapped_type&
      operator[](key_type&& __k);



      mapped_type&
      at(const key_type& __k);

      const mapped_type&
      at(const key_type& __k) const;
    };

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    typename _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
         ::mapped_type&
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    operator[](const key_type& __k)
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 {
   __p = __h->_M_allocate_node(std::piecewise_construct,
          std::tuple<const key_type&>(__k),
          std::tuple<>());
   return __h->_M_insert_unique_node(__n, __code, __p)->second;
 }

      return __p->_M_v().second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    typename _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
         ::mapped_type&
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    operator[](key_type&& __k)
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 {
   __p = __h->_M_allocate_node(std::piecewise_construct,
          std::forward_as_tuple(std::move(__k)),
          std::tuple<>());
   return __h->_M_insert_unique_node(__n, __code, __p)->second;
 }

      return __p->_M_v().second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    typename _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
         ::mapped_type&
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    at(const key_type& __k)
    {
      __hashtable* __h = static_cast<__hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 __throw_out_of_range(("_Map_base::at"));
      return __p->_M_v().second;
    }

  template<typename _Key, typename _Pair, typename _Alloc, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    const typename _Map_base<_Key, _Pair, _Alloc, _Select1st,
        _Equal, _H1, _H2, _Hash, _RehashPolicy,
        _Traits, true>::mapped_type&
    _Map_base<_Key, _Pair, _Alloc, _Select1st, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    at(const key_type& __k) const
    {
      const __hashtable* __h = static_cast<const __hashtable*>(this);
      __hash_code __code = __h->_M_hash_code(__k);
      std::size_t __n = __h->_M_bucket_index(__k, __code);
      __node_type* __p = __h->_M_find_node(__n, __k, __code);

      if (!__p)
 __throw_out_of_range(("_Map_base::at"));
      return __p->_M_v().second;
    }






  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert_base
    {
    protected:
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __hashtable_base = _Hashtable_base<_Key, _Value, _ExtractKey,
            _Equal, _H1, _H2, _Hash,
            _Traits>;

      using value_type = typename __hashtable_base::value_type;
      using iterator = typename __hashtable_base::iterator;
      using const_iterator = typename __hashtable_base::const_iterator;
      using size_type = typename __hashtable_base::size_type;

      using __unique_keys = typename __hashtable_base::__unique_keys;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;
      using __node_type = _Hash_node<_Value, _Traits::__hash_cached::value>;
      using __node_alloc_type =
 typename __alloctr_rebind<_Alloc, __node_type>::__type;
      using __node_gen_type = _AllocNode<__node_alloc_type>;

      __hashtable&
      _M_conjure_hashtable()
      { return *(static_cast<__hashtable*>(this)); }

      template<typename _InputIterator, typename _NodeGetter>
 void
 _M_insert_range(_InputIterator __first, _InputIterator __last,
   const _NodeGetter&);

    public:
      __ireturn_type
      insert(const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__v, __node_gen, __unique_keys());
      }

      iterator
      insert(const_iterator __hint, const value_type& __v)
      {
 __hashtable& __h = _M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, __v, __node_gen, __unique_keys());
      }

      void
      insert(initializer_list<value_type> __l)
      { this->insert(__l.begin(), __l.end()); }

      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 {
   __hashtable& __h = _M_conjure_hashtable();
   __node_gen_type __node_gen(__h);
   return _M_insert_range(__first, __last, __node_gen);
 }
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    template<typename _InputIterator, typename _NodeGetter>
      void
      _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
      _RehashPolicy, _Traits>::
      _M_insert_range(_InputIterator __first, _InputIterator __last,
        const _NodeGetter& __node_gen)
      {
 using __rehash_type = typename __hashtable::__rehash_type;
 using __rehash_state = typename __hashtable::__rehash_state;
 using pair_type = std::pair<bool, std::size_t>;

 size_type __n_elt = __detail::__distance_fw(__first, __last);

 __hashtable& __h = _M_conjure_hashtable();
 __rehash_type& __rehash = __h._M_rehash_policy;
 const __rehash_state& __saved_state = __rehash._M_state();
 pair_type __do_rehash = __rehash._M_need_rehash(__h._M_bucket_count,
       __h._M_element_count,
       __n_elt);

 if (__do_rehash.first)
   __h._M_rehash(__do_rehash.second, __saved_state);

 for (; __first != __last; ++__first)
   __h._M_insert(*__first, __node_gen, __unique_keys());
      }






  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Constant_iterators = _Traits::__constant_iterators::value,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Insert;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, true, true>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
     _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits>;
      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;
      using __node_gen_type = typename __base_type::__node_gen_type;

      using __base_type::insert;

      std::pair<iterator, bool>
      insert(value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(std::move(__v), __node_gen, __unique_keys());
      }

      iterator
      insert(const_iterator __hint, value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, std::move(__v), __node_gen,
        __unique_keys());
      }
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, true, false>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
     _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits>;
      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;
      using __node_gen_type = typename __base_type::__node_gen_type;

      using __base_type::insert;

      iterator
      insert(value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(std::move(__v), __node_gen, __unique_keys());
      }

      iterator
      insert(const_iterator __hint, value_type&& __v)
      {
 __hashtable& __h = this->_M_conjure_hashtable();
 __node_gen_type __node_gen(__h);
 return __h._M_insert(__hint, std::move(__v), __node_gen,
        __unique_keys());
      }
    };


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits, bool _Unique_keys>
    struct _Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal, _H1, _H2, _Hash,
     _RehashPolicy, _Traits, false, _Unique_keys>
    : public _Insert_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
      _H1, _H2, _Hash, _RehashPolicy, _Traits>
    {
      using __base_type = _Insert_base<_Key, _Value, _Alloc, _ExtractKey,
           _Equal, _H1, _H2, _Hash,
           _RehashPolicy, _Traits>;
      using value_type = typename __base_type::value_type;
      using iterator = typename __base_type::iterator;
      using const_iterator = typename __base_type::const_iterator;

      using __unique_keys = typename __base_type::__unique_keys;
      using __hashtable = typename __base_type::__hashtable;
      using __ireturn_type = typename __base_type::__ireturn_type;

      using __base_type::insert;

      template<typename _Pair>
 using __is_cons = std::is_constructible<value_type, _Pair&&>;

      template<typename _Pair>
 using _IFcons = std::enable_if<__is_cons<_Pair>::value>;

      template<typename _Pair>
 using _IFconsp = typename _IFcons<_Pair>::type;

      template<typename _Pair, typename = _IFconsp<_Pair>>
 __ireturn_type
 insert(_Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__unique_keys(), std::forward<_Pair>(__v));
 }

      template<typename _Pair, typename = _IFconsp<_Pair>>
 iterator
 insert(const_iterator __hint, _Pair&& __v)
 {
   __hashtable& __h = this->_M_conjure_hashtable();
   return __h._M_emplace(__hint, __unique_keys(),
    std::forward<_Pair>(__v));
 }
   };







  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Rehash_base;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
    struct _Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _Prime_rehash_policy, _Traits>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _Prime_rehash_policy, _Traits>;

      float
      max_load_factor() const noexcept
      {
 const __hashtable* __this = static_cast<const __hashtable*>(this);
 return __this->__rehash_policy().max_load_factor();
      }

      void
      max_load_factor(float __z)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->__rehash_policy(_Prime_rehash_policy(__z));
      }

      void
      reserve(std::size_t __n)
      {
 __hashtable* __this = static_cast<__hashtable*>(this);
 __this->rehash(__builtin_ceil(__n / max_load_factor()));
      }
    };







  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Hashtable_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, true>
    : private _Tp
    {
      _Hashtable_ebo_helper() = default;

      template<typename _OtherTp>
 _Hashtable_ebo_helper(_OtherTp&& __tp)
   : _Tp(std::forward<_OtherTp>(__tp))
 { }

      static const _Tp&
      _S_cget(const _Hashtable_ebo_helper& __eboh)
      { return static_cast<const _Tp&>(__eboh); }

      static _Tp&
      _S_get(_Hashtable_ebo_helper& __eboh)
      { return static_cast<_Tp&>(__eboh); }
    };


  template<int _Nm, typename _Tp>
    struct _Hashtable_ebo_helper<_Nm, _Tp, false>
    {
      _Hashtable_ebo_helper() = default;

      template<typename _OtherTp>
 _Hashtable_ebo_helper(_OtherTp&& __tp)
   : _M_tp(std::forward<_OtherTp>(__tp))
 { }

      static const _Tp&
      _S_cget(const _Hashtable_ebo_helper& __eboh)
      { return __eboh._M_tp; }

      static _Tp&
      _S_get(_Hashtable_ebo_helper& __eboh)
      { return __eboh._M_tp; }

    private:
      _Tp _M_tp;
    };







  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __cache_hash_code>
    struct _Local_iterator_base;
# 1054 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __cache_hash_code>
    struct _Hash_code_base;



  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, false>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _Hash>
    {
    private:
      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_hash = _Hashtable_ebo_helper<1, _Hash>;

    protected:
      typedef void* __hash_code;
      typedef _Hash_node<_Value, false> __node_type;


      _Hash_code_base() = default;

      _Hash_code_base(const _ExtractKey& __ex, const _H1&, const _H2&,
        const _Hash& __h)
      : __ebo_extract_key(__ex), __ebo_hash(__h) { }

      __hash_code
      _M_hash_code(const _Key& __key) const
      { return 0; }

      std::size_t
      _M_bucket_index(const _Key& __k, __hash_code, std::size_t __n) const
      { return _M_ranged_hash()(__k, __n); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __n) const
 noexcept( noexcept(declval<const _Hash&>()(declval<const _Key&>(),
         (std::size_t)0)) )
      { return _M_ranged_hash()(_M_extract()(__p->_M_v()), __n); }

      void
      _M_store_code(__node_type*, __hash_code) const
      { }

      void
      _M_copy_code(__node_type*, const __node_type*) const
      { }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract(), __x._M_extract());
 std::swap(_M_ranged_hash(), __x._M_ranged_hash());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }

      _ExtractKey&
      _M_extract() { return __ebo_extract_key::_S_get(*this); }

      const _Hash&
      _M_ranged_hash() const { return __ebo_hash::_S_cget(*this); }

      _Hash&
      _M_ranged_hash() { return __ebo_hash::_S_get(*this); }
    };







  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash, true>;




  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, false>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _H1>,
      private _Hashtable_ebo_helper<2, _H2>
    {
    private:
      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;


      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, false>;

    public:
      typedef _H1 hasher;

      hasher
      hash_function() const
      { return _M_h1(); }

    protected:
      typedef std::size_t __hash_code;
      typedef _Hash_node<_Value, false> __node_type;


      _Hash_code_base() = default;

      _Hash_code_base(const _ExtractKey& __ex,
        const _H1& __h1, const _H2& __h2,
        const _Default_ranged_hash&)
      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }

      __hash_code
      _M_hash_code(const _Key& __k) const
      { return _M_h1()(__k); }

      std::size_t
      _M_bucket_index(const _Key&, __hash_code __c, std::size_t __n) const
      { return _M_h2()(__c, __n); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __n) const
 noexcept( noexcept(declval<const _H1&>()(declval<const _Key&>()))
    && noexcept(declval<const _H2&>()((__hash_code)0,
          (std::size_t)0)) )
      { return _M_h2()(_M_h1()(_M_extract()(__p->_M_v())), __n); }

      void
      _M_store_code(__node_type*, __hash_code) const
      { }

      void
      _M_copy_code(__node_type*, const __node_type*) const
      { }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract(), __x._M_extract());
 std::swap(_M_h1(), __x._M_h1());
 std::swap(_M_h2(), __x._M_h2());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }

      _ExtractKey&
      _M_extract() { return __ebo_extract_key::_S_get(*this); }

      const _H1&
      _M_h1() const { return __ebo_h1::_S_cget(*this); }

      _H1&
      _M_h1() { return __ebo_h1::_S_get(*this); }

      const _H2&
      _M_h2() const { return __ebo_h2::_S_cget(*this); }

      _H2&
      _M_h2() { return __ebo_h2::_S_get(*this); }
    };




  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2>
    struct _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, true>
    : private _Hashtable_ebo_helper<0, _ExtractKey>,
      private _Hashtable_ebo_helper<1, _H1>,
      private _Hashtable_ebo_helper<2, _H2>
    {
    private:

      friend struct _Local_iterator_base<_Key, _Value, _ExtractKey, _H1, _H2,
      _Default_ranged_hash, true>;

      using __ebo_extract_key = _Hashtable_ebo_helper<0, _ExtractKey>;
      using __ebo_h1 = _Hashtable_ebo_helper<1, _H1>;
      using __ebo_h2 = _Hashtable_ebo_helper<2, _H2>;

    public:
      typedef _H1 hasher;

      hasher
      hash_function() const
      { return _M_h1(); }

    protected:
      typedef std::size_t __hash_code;
      typedef _Hash_node<_Value, true> __node_type;

      _Hash_code_base(const _ExtractKey& __ex,
        const _H1& __h1, const _H2& __h2,
        const _Default_ranged_hash&)
      : __ebo_extract_key(__ex), __ebo_h1(__h1), __ebo_h2(__h2) { }

      __hash_code
      _M_hash_code(const _Key& __k) const
      { return _M_h1()(__k); }

      std::size_t
      _M_bucket_index(const _Key&, __hash_code __c,
        std::size_t __n) const
      { return _M_h2()(__c, __n); }

      std::size_t
      _M_bucket_index(const __node_type* __p, std::size_t __n) const
 noexcept( noexcept(declval<const _H2&>()((__hash_code)0,
       (std::size_t)0)) )
      { return _M_h2()(__p->_M_hash_code, __n); }

      void
      _M_store_code(__node_type* __n, __hash_code __c) const
      { __n->_M_hash_code = __c; }

      void
      _M_copy_code(__node_type* __to, const __node_type* __from) const
      { __to->_M_hash_code = __from->_M_hash_code; }

      void
      _M_swap(_Hash_code_base& __x)
      {
 std::swap(_M_extract(), __x._M_extract());
 std::swap(_M_h1(), __x._M_h1());
 std::swap(_M_h2(), __x._M_h2());
      }

      const _ExtractKey&
      _M_extract() const { return __ebo_extract_key::_S_cget(*this); }

      _ExtractKey&
      _M_extract() { return __ebo_extract_key::_S_get(*this); }

      const _H1&
      _M_h1() const { return __ebo_h1::_S_cget(*this); }

      _H1&
      _M_h1() { return __ebo_h1::_S_get(*this); }

      const _H2&
      _M_h2() const { return __ebo_h2::_S_cget(*this); }

      _H2&
      _M_h2() { return __ebo_h2::_S_get(*this); }
    };





  template <typename _Key, typename _Value, typename _ExtractKey,
     typename _Equal, typename _HashCodeType,
     bool __cache_hash_code>
  struct _Equal_helper;


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Equal, typename _HashCodeType>
  struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, true>
  {
    static bool
    _S_equals(const _Equal& __eq, const _ExtractKey& __extract,
       const _Key& __k, _HashCodeType __c, _Hash_node<_Value, true>* __n)
    { return __c == __n->_M_hash_code && __eq(__k, __extract(__n->_M_v())); }
  };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _Equal, typename _HashCodeType>
  struct _Equal_helper<_Key, _Value, _ExtractKey, _Equal, _HashCodeType, false>
  {
    static bool
    _S_equals(const _Equal& __eq, const _ExtractKey& __extract,
       const _Key& __k, _HashCodeType, _Hash_node<_Value, false>* __n)
    { return __eq(__k, __extract(__n->_M_v())); }
  };



  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _H1, _H2, _Hash, true>
    : private _Hashtable_ebo_helper<0, _H2>
    {
    protected:
      using __base_type = _Hashtable_ebo_helper<0, _H2>;
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, true>;

      _Local_iterator_base() = default;
      _Local_iterator_base(const __hash_code_base& __base,
      _Hash_node<_Value, true>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : __base_type(__base._M_h2()),
 _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count) { }

      void
      _M_incr()
      {
 _M_cur = _M_cur->_M_next();
 if (_M_cur)
   {
     std::size_t __bkt
       = __base_type::_S_get(*this)(_M_cur->_M_hash_code,
        _M_bucket_count);
     if (__bkt != _M_bucket)
       _M_cur = nullptr;
   }
      }

      _Hash_node<_Value, true>* _M_cur;
      std::size_t _M_bucket;
      std::size_t _M_bucket_count;

    public:
      const void*
      _M_curr() const { return _M_cur; }

      std::size_t
      _M_get_bucket() const { return _M_bucket; }
    };





  template<typename _Tp, bool _IsEmpty = std::is_empty<_Tp>::value>
    struct _Hash_code_storage
    {
      __gnu_cxx::__aligned_buffer<_Tp> _M_storage;

      _Tp*
      _M_h() { return _M_storage._M_ptr(); }

      const _Tp*
      _M_h() const { return _M_storage._M_ptr(); }
    };


  template<typename _Tp>
    struct _Hash_code_storage<_Tp, true>
    {
      static_assert( std::is_empty<_Tp>::value, "Type must be empty" );



      _Tp*
      _M_h() { return reinterpret_cast<_Tp*>(this); }

      const _Tp*
      _M_h() const { return reinterpret_cast<const _Tp*>(this); }
    };

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    using __hash_code_for_local_iter
      = _Hash_code_storage<_Hash_code_base<_Key, _Value, _ExtractKey,
        _H1, _H2, _Hash, false>>;


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash>
    struct _Local_iterator_base<_Key, _Value, _ExtractKey,
    _H1, _H2, _Hash, false>
    : __hash_code_for_local_iter<_Key, _Value, _ExtractKey, _H1, _H2, _Hash>
    {
    protected:
      using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, false>;

      _Local_iterator_base() : _M_bucket_count(-1) { }

      _Local_iterator_base(const __hash_code_base& __base,
      _Hash_node<_Value, false>* __p,
      std::size_t __bkt, std::size_t __bkt_count)
      : _M_cur(__p), _M_bucket(__bkt), _M_bucket_count(__bkt_count)
      { _M_init(__base); }

      ~_Local_iterator_base()
      {
 if (_M_bucket_count != -1)
   _M_destroy();
      }

      _Local_iterator_base(const _Local_iterator_base& __iter)
      : _M_cur(__iter._M_cur), _M_bucket(__iter._M_bucket),
        _M_bucket_count(__iter._M_bucket_count)
      {
 if (_M_bucket_count != -1)
   _M_init(*__iter._M_h());
      }

      _Local_iterator_base&
      operator=(const _Local_iterator_base& __iter)
      {
 if (_M_bucket_count != -1)
   _M_destroy();
 _M_cur = __iter._M_cur;
 _M_bucket = __iter._M_bucket;
 _M_bucket_count = __iter._M_bucket_count;
 if (_M_bucket_count != -1)
   _M_init(*__iter._M_h());
 return *this;
      }

      void
      _M_incr()
      {
 _M_cur = _M_cur->_M_next();
 if (_M_cur)
   {
     std::size_t __bkt = this->_M_h()->_M_bucket_index(_M_cur,
             _M_bucket_count);
     if (__bkt != _M_bucket)
       _M_cur = nullptr;
   }
      }

      _Hash_node<_Value, false>* _M_cur;
      std::size_t _M_bucket;
      std::size_t _M_bucket_count;

      void
      _M_init(const __hash_code_base& __base)
      { ::new(this->_M_h()) __hash_code_base(__base); }

      void
      _M_destroy() { this->_M_h()->~__hash_code_base(); }

    public:
      const void*
      _M_curr() const { return _M_cur; }

      std::size_t
      _M_get_bucket() const { return _M_bucket; }
    };

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash, bool __cache>
    inline bool
    operator==(const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __x,
        const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __y)
    { return __x._M_curr() == __y._M_curr(); }

  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash, bool __cache>
    inline bool
    operator!=(const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __x,
        const _Local_iterator_base<_Key, _Value, _ExtractKey,
       _H1, _H2, _Hash, __cache>& __y)
    { return __x._M_curr() != __y._M_curr(); }


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __constant_iterators, bool __cache>
    struct _Local_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _H1, _H2, _Hash, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;
    public:
      typedef _Value value_type;
      typedef typename std::conditional<__constant_iterators,
     const _Value*, _Value*>::type
             pointer;
      typedef typename std::conditional<__constant_iterators,
     const _Value&, _Value&>::type
             reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_iterator() = default;

      _Local_iterator(const __hash_code_base& __base,
        _Hash_node<_Value, __cache>* __p,
        std::size_t __bkt, std::size_t __bkt_count)
 : __base_type(__base, __p, __bkt, __bkt_count)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const
      { return this->_M_cur->_M_valptr(); }

      _Local_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_iterator
      operator++(int)
      {
 _Local_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };


  template<typename _Key, typename _Value, typename _ExtractKey,
    typename _H1, typename _H2, typename _Hash,
    bool __constant_iterators, bool __cache>
    struct _Local_const_iterator
    : public _Local_iterator_base<_Key, _Value, _ExtractKey,
      _H1, _H2, _Hash, __cache>
    {
    private:
      using __base_type = _Local_iterator_base<_Key, _Value, _ExtractKey,
            _H1, _H2, _Hash, __cache>;
      using __hash_code_base = typename __base_type::__hash_code_base;

    public:
      typedef _Value value_type;
      typedef const _Value* pointer;
      typedef const _Value& reference;
      typedef std::ptrdiff_t difference_type;
      typedef std::forward_iterator_tag iterator_category;

      _Local_const_iterator() = default;

      _Local_const_iterator(const __hash_code_base& __base,
       _Hash_node<_Value, __cache>* __p,
       std::size_t __bkt, std::size_t __bkt_count)
 : __base_type(__base, __p, __bkt, __bkt_count)
      { }

      _Local_const_iterator(const _Local_iterator<_Key, _Value, _ExtractKey,
        _H1, _H2, _Hash,
        __constant_iterators,
        __cache>& __x)
 : __base_type(__x)
      { }

      reference
      operator*() const
      { return this->_M_cur->_M_v(); }

      pointer
      operator->() const
      { return this->_M_cur->_M_valptr(); }

      _Local_const_iterator&
      operator++()
      {
 this->_M_incr();
 return *this;
      }

      _Local_const_iterator
      operator++(int)
      {
 _Local_const_iterator __tmp(*this);
 this->_M_incr();
 return __tmp;
      }
    };
# 1643 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _Traits>
  struct _Hashtable_base
  : public _Hash_code_base<_Key, _Value, _ExtractKey, _H1, _H2, _Hash,
      _Traits::__hash_cached::value>,
    private _Hashtable_ebo_helper<0, _Equal>
  {
  public:
    typedef _Key key_type;
    typedef _Value value_type;
    typedef _Equal key_equal;
    typedef std::size_t size_type;
    typedef std::ptrdiff_t difference_type;

    using __traits_type = _Traits;
    using __hash_cached = typename __traits_type::__hash_cached;
    using __constant_iterators = typename __traits_type::__constant_iterators;
    using __unique_keys = typename __traits_type::__unique_keys;

    using __hash_code_base = _Hash_code_base<_Key, _Value, _ExtractKey,
          _H1, _H2, _Hash,
          __hash_cached::value>;

    using __hash_code = typename __hash_code_base::__hash_code;
    using __node_type = typename __hash_code_base::__node_type;

    using iterator = __detail::_Node_iterator<value_type,
           __constant_iterators::value,
           __hash_cached::value>;

    using const_iterator = __detail::_Node_const_iterator<value_type,
         __constant_iterators::value,
         __hash_cached::value>;

    using local_iterator = __detail::_Local_iterator<key_type, value_type,
        _ExtractKey, _H1, _H2, _Hash,
        __constant_iterators::value,
           __hash_cached::value>;

    using const_local_iterator = __detail::_Local_const_iterator<key_type,
         value_type,
     _ExtractKey, _H1, _H2, _Hash,
     __constant_iterators::value,
     __hash_cached::value>;

    using __ireturn_type = typename std::conditional<__unique_keys::value,
           std::pair<iterator, bool>,
           iterator>::type;
  private:
    using _EqualEBO = _Hashtable_ebo_helper<0, _Equal>;
    using _EqualHelper = _Equal_helper<_Key, _Value, _ExtractKey, _Equal,
     __hash_code, __hash_cached::value>;

  protected:
    _Hashtable_base(const _ExtractKey& __ex, const _H1& __h1, const _H2& __h2,
      const _Hash& __hash, const _Equal& __eq)
    : __hash_code_base(__ex, __h1, __h2, __hash), _EqualEBO(__eq)
    { }

    bool
    _M_equals(const _Key& __k, __hash_code __c, __node_type* __n) const
    {
      return _EqualHelper::_S_equals(_M_eq(), this->_M_extract(),
         __k, __c, __n);
    }

    void
    _M_swap(_Hashtable_base& __x)
    {
      __hash_code_base::_M_swap(__x);
      std::swap(_M_eq(), __x._M_eq());
    }

    const _Equal&
    _M_eq() const { return _EqualEBO::_S_cget(*this); }

    _Equal&
    _M_eq() { return _EqualEBO::_S_get(*this); }
  };






  struct _Equality_base
  {
  protected:
    template<typename _Uiterator>
      static bool
      _S_is_permutation(_Uiterator, _Uiterator, _Uiterator);
  };


  template<typename _Uiterator>
    bool
    _Equality_base::
    _S_is_permutation(_Uiterator __first1, _Uiterator __last1,
        _Uiterator __first2)
    {
      for (; __first1 != __last1; ++__first1, ++__first2)
 if (!(*__first1 == *__first2))
   break;

      if (__first1 == __last1)
 return true;

      _Uiterator __last2 = __first2;
      std::advance(__last2, std::distance(__first1, __last1));

      for (_Uiterator __it1 = __first1; __it1 != __last1; ++__it1)
 {
   _Uiterator __tmp = __first1;
   while (__tmp != __it1 && !bool(*__tmp == *__it1))
     ++__tmp;


   if (__tmp != __it1)
     continue;

   std::ptrdiff_t __n2 = 0;
   for (__tmp = __first2; __tmp != __last2; ++__tmp)
     if (*__tmp == *__it1)
       ++__n2;

   if (!__n2)
     return false;

   std::ptrdiff_t __n1 = 0;
   for (__tmp = __it1; __tmp != __last1; ++__tmp)
     if (*__tmp == *__it1)
       ++__n1;

   if (__n1 != __n2)
     return false;
 }
      return true;
    }
# 1791 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/hashtable_policy.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits,
    bool _Unique_keys = _Traits::__unique_keys::value>
    struct _Equality;


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, true>::
    _M_equal(const __hashtable& __other) const
    {
      const __hashtable* __this = static_cast<const __hashtable*>(this);

      if (__this->size() != __other.size())
 return false;

      for (auto __itx = __this->begin(); __itx != __this->end(); ++__itx)
 {
   const auto __ity = __other.find(_ExtractKey()(*__itx));
   if (__ity == __other.end() || !bool(*__ity == *__itx))
     return false;
 }
      return true;
    }


  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    struct _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>
    : public _Equality_base
    {
      using __hashtable = _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
         _H1, _H2, _Hash, _RehashPolicy, _Traits>;

      bool
      _M_equal(const __hashtable&) const;
    };

  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    bool
    _Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
       _H1, _H2, _Hash, _RehashPolicy, _Traits, false>::
    _M_equal(const __hashtable& __other) const
    {
      const __hashtable* __this = static_cast<const __hashtable*>(this);

      if (__this->size() != __other.size())
 return false;

      for (auto __itx = __this->begin(); __itx != __this->end();)
 {
   const auto __xrange = __this->equal_range(_ExtractKey()(*__itx));
   const auto __yrange = __other.equal_range(_ExtractKey()(*__itx));

   if (std::distance(__xrange.first, __xrange.second)
       != std::distance(__yrange.first, __yrange.second))
     return false;

   if (!_S_is_permutation(__xrange.first, __xrange.second,
     __yrange.first))
     return false;

   __itx = __xrange.second;
 }
      return true;
    }





  template<typename _NodeAlloc>
    struct _Hashtable_alloc : private _Hashtable_ebo_helper<0, _NodeAlloc>
    {
    private:
      using __ebo_node_alloc = _Hashtable_ebo_helper<0, _NodeAlloc>;
    public:
      using __node_type = typename _NodeAlloc::value_type;
      using __node_alloc_type = _NodeAlloc;

      using __node_alloc_traits = __gnu_cxx::__alloc_traits<__node_alloc_type>;

      using __value_type = typename __node_type::value_type;
      using __value_alloc_type =
 typename __alloctr_rebind<__node_alloc_type, __value_type>::__type;
      using __value_alloc_traits = std::allocator_traits<__value_alloc_type>;

      using __node_base = __detail::_Hash_node_base;
      using __bucket_type = __node_base*;
      using __bucket_alloc_type =
 typename __alloctr_rebind<__node_alloc_type, __bucket_type>::__type;
      using __bucket_alloc_traits = std::allocator_traits<__bucket_alloc_type>;

      _Hashtable_alloc(const _Hashtable_alloc&) = default;
      _Hashtable_alloc(_Hashtable_alloc&&) = default;

      template<typename _Alloc>
 _Hashtable_alloc(_Alloc&& __a)
   : __ebo_node_alloc(std::forward<_Alloc>(__a))
 { }

      __node_alloc_type&
      _M_node_allocator()
      { return __ebo_node_alloc::_S_get(*this); }

      const __node_alloc_type&
      _M_node_allocator() const
      { return __ebo_node_alloc::_S_cget(*this); }

      template<typename... _Args>
 __node_type*
 _M_allocate_node(_Args&&... __args);

      void
      _M_deallocate_node(__node_type* __n);


      void
      _M_deallocate_nodes(__node_type* __n);

      __bucket_type*
      _M_allocate_buckets(std::size_t __n);

      void
      _M_deallocate_buckets(__bucket_type*, std::size_t __n);
    };



  template<typename _NodeAlloc>
    template<typename... _Args>
      typename _Hashtable_alloc<_NodeAlloc>::__node_type*
      _Hashtable_alloc<_NodeAlloc>::_M_allocate_node(_Args&&... __args)
      {
 auto __nptr = __node_alloc_traits::allocate(_M_node_allocator(), 1);
 __node_type* __n = std::__addressof(*__nptr);
 try
   {
     __value_alloc_type __a(_M_node_allocator());
     ::new ((void*)__n) __node_type;
     __value_alloc_traits::construct(__a, __n->_M_valptr(),
         std::forward<_Args>(__args)...);
     return __n;
   }
 catch(...)
   {
     __node_alloc_traits::deallocate(_M_node_allocator(), __nptr, 1);
     throw;
   }
      }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_node(__node_type* __n)
    {
      typedef typename __node_alloc_traits::pointer _Ptr;
      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__n);
      __value_alloc_type __a(_M_node_allocator());
      __value_alloc_traits::destroy(__a, __n->_M_valptr());
      __n->~__node_type();
      __node_alloc_traits::deallocate(_M_node_allocator(), __ptr, 1);
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_nodes(__node_type* __n)
    {
      while (__n)
 {
   __node_type* __tmp = __n;
   __n = __n->_M_next();
   _M_deallocate_node(__tmp);
 }
    }

  template<typename _NodeAlloc>
    typename _Hashtable_alloc<_NodeAlloc>::__bucket_type*
    _Hashtable_alloc<_NodeAlloc>::_M_allocate_buckets(std::size_t __n)
    {
      __bucket_alloc_type __alloc(_M_node_allocator());

      auto __ptr = __bucket_alloc_traits::allocate(__alloc, __n);
      __bucket_type* __p = std::__addressof(*__ptr);
      __builtin_memset(__p, 0, __n * sizeof(__bucket_type));
      return __p;
    }

  template<typename _NodeAlloc>
    void
    _Hashtable_alloc<_NodeAlloc>::_M_deallocate_buckets(__bucket_type* __bkts,
       std::size_t __n)
    {
      typedef typename __bucket_alloc_traits::pointer _Ptr;
      auto __ptr = std::pointer_traits<_Ptr>::pointer_to(*__bkts);
      __bucket_alloc_type __alloc(_M_node_allocator());
      __bucket_alloc_traits::deallocate(__alloc, __ptr, __n);
    }



}
}
# 36 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/hashtable.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{


  template<typename _Tp, typename _Hash>
    using __cache_default
      = __not_<__and_<
         __is_fast_hash<_Hash>,

         __detail::__is_noexcept_hash<_Tp, _Hash>>>;
# 166 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/hashtable.h" 3
  template<typename _Key, typename _Value, typename _Alloc,
    typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash,
    typename _RehashPolicy, typename _Traits>
    class _Hashtable
    : public __detail::_Hashtable_base<_Key, _Value, _ExtractKey, _Equal,
           _H1, _H2, _Hash, _Traits>,
      public __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Insert<_Key, _Value, _Alloc, _ExtractKey, _Equal,
          _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Rehash_base<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      public __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy, _Traits>,
      private __detail::_Hashtable_alloc<
 typename __alloctr_rebind<_Alloc,
   __detail::_Hash_node<_Value,
          _Traits::__hash_cached::value> >::__type>
    {
      using __traits_type = _Traits;
      using __hash_cached = typename __traits_type::__hash_cached;
      using __node_type = __detail::_Hash_node<_Value, __hash_cached::value>;
      using __node_alloc_type =
 typename __alloctr_rebind<_Alloc, __node_type>::__type;

      using __hashtable_alloc = __detail::_Hashtable_alloc<__node_alloc_type>;

      using __value_alloc_traits =
 typename __hashtable_alloc::__value_alloc_traits;
      using __node_alloc_traits =
 typename __hashtable_alloc::__node_alloc_traits;
      using __node_base = typename __hashtable_alloc::__node_base;
      using __bucket_type = typename __hashtable_alloc::__bucket_type;

    public:
      typedef _Key key_type;
      typedef _Value value_type;
      typedef _Alloc allocator_type;
      typedef _Equal key_equal;



      typedef typename __value_alloc_traits::pointer pointer;
      typedef typename __value_alloc_traits::const_pointer const_pointer;
      typedef value_type& reference;
      typedef const value_type& const_reference;

    private:
      using __rehash_type = _RehashPolicy;
      using __rehash_state = typename __rehash_type::_State;

      using __constant_iterators = typename __traits_type::__constant_iterators;
      using __unique_keys = typename __traits_type::__unique_keys;

      using __key_extract = typename std::conditional<
          __constant_iterators::value,
                 __detail::_Identity,
          __detail::_Select1st>::type;

      using __hashtable_base = __detail::
          _Hashtable_base<_Key, _Value, _ExtractKey,
           _Equal, _H1, _H2, _Hash, _Traits>;

      using __hash_code_base = typename __hashtable_base::__hash_code_base;
      using __hash_code = typename __hashtable_base::__hash_code;
      using __ireturn_type = typename __hashtable_base::__ireturn_type;

      using __map_base = __detail::_Map_base<_Key, _Value, _Alloc, _ExtractKey,
          _Equal, _H1, _H2, _Hash,
          _RehashPolicy, _Traits>;

      using __rehash_base = __detail::_Rehash_base<_Key, _Value, _Alloc,
         _ExtractKey, _Equal,
         _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __eq_base = __detail::_Equality<_Key, _Value, _Alloc, _ExtractKey,
         _Equal, _H1, _H2, _Hash,
         _RehashPolicy, _Traits>;

      using __reuse_or_alloc_node_type =
 __detail::_ReuseOrAllocNode<__node_alloc_type>;


      template<typename _Cond>
 using __if_hash_cached = __or_<__not_<__hash_cached>, _Cond>;

      template<typename _Cond>
 using __if_hash_not_cached = __or_<__hash_cached, _Cond>;





      struct __hash_code_base_access : __hash_code_base
      { using __hash_code_base::_M_bucket_index; };



      static_assert(noexcept(declval<const __hash_code_base_access&>()
        ._M_bucket_index((const __node_type*)nullptr,
           (std::size_t)0)),
      "Cache the hash code or qualify your functors involved"
      " in hash code and bucket index computation with noexcept");






      static_assert(__if_hash_cached<is_default_constructible<_H2>>::value,
      "Functor used to map hash code to bucket index"
      " must be default constructible");

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa,
        bool _Unique_keysa>
 friend struct __detail::_Map_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa>
 friend struct __detail::_Insert_base;

      template<typename _Keya, typename _Valuea, typename _Alloca,
        typename _ExtractKeya, typename _Equala,
        typename _H1a, typename _H2a, typename _Hasha,
        typename _RehashPolicya, typename _Traitsa,
        bool _Constant_iteratorsa, bool _Unique_keysa>
 friend struct __detail::_Insert;

    public:
      using size_type = typename __hashtable_base::size_type;
      using difference_type = typename __hashtable_base::difference_type;

      using iterator = typename __hashtable_base::iterator;
      using const_iterator = typename __hashtable_base::const_iterator;

      using local_iterator = typename __hashtable_base::local_iterator;
      using const_local_iterator = typename __hashtable_base::
       const_local_iterator;

    private:
      __bucket_type* _M_buckets;
      size_type _M_bucket_count;
      __node_base _M_before_begin;
      size_type _M_element_count;
      _RehashPolicy _M_rehash_policy;







      __bucket_type _M_single_bucket;

      bool
      _M_uses_single_bucket(__bucket_type* __bkts) const
      { return __builtin_expect(_M_buckets == &_M_single_bucket, false); }

      bool
      _M_uses_single_bucket() const
      { return _M_uses_single_bucket(_M_buckets); }

      __hashtable_alloc&
      _M_base_alloc() { return *this; }

      __bucket_type*
      _M_allocate_buckets(size_type __n)
      {
 if (__builtin_expect(__n == 1, false))
   {
     _M_single_bucket = nullptr;
     return &_M_single_bucket;
   }

 return __hashtable_alloc::_M_allocate_buckets(__n);
      }

      void
      _M_deallocate_buckets(__bucket_type* __bkts, size_type __n)
      {
 if (_M_uses_single_bucket(__bkts))
   return;

 __hashtable_alloc::_M_deallocate_buckets(__bkts, __n);
      }

      void
      _M_deallocate_buckets()
      { _M_deallocate_buckets(_M_buckets, _M_bucket_count); }



      __node_type*
      _M_bucket_begin(size_type __bkt) const;

      __node_type*
      _M_begin() const
      { return static_cast<__node_type*>(_M_before_begin._M_nxt); }

      template<typename _NodeGenerator>
 void
 _M_assign(const _Hashtable&, const _NodeGenerator&);

      void
      _M_move_assign(_Hashtable&&, std::true_type);

      void
      _M_move_assign(_Hashtable&&, std::false_type);

      void
      _M_reset() noexcept;

    public:

      _Hashtable(size_type __bucket_hint,
   const _H1&, const _H2&, const _Hash&,
   const _Equal&, const _ExtractKey&,
   const allocator_type&);

      template<typename _InputIterator>
 _Hashtable(_InputIterator __first, _InputIterator __last,
     size_type __bucket_hint,
     const _H1&, const _H2&, const _Hash&,
     const _Equal&, const _ExtractKey&,
     const allocator_type&);

      _Hashtable(const _Hashtable&);

      _Hashtable(_Hashtable&&) noexcept;

      _Hashtable(const _Hashtable&, const allocator_type&);

      _Hashtable(_Hashtable&&, const allocator_type&);


      explicit
      _Hashtable(const allocator_type& __a)
      : _Hashtable(10, _H1(), _H2(), _Hash(), key_equal(),
     __key_extract(), __a)
      { }

      explicit
      _Hashtable(size_type __n = 10,
   const _H1& __hf = _H1(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
      : _Hashtable(__n, __hf, _H2(), _Hash(), __eql,
     __key_extract(), __a)
      { }

      template<typename _InputIterator>
 _Hashtable(_InputIterator __f, _InputIterator __l,
     size_type __n = 0,
     const _H1& __hf = _H1(),
     const key_equal& __eql = key_equal(),
     const allocator_type& __a = allocator_type())
 : _Hashtable(__f, __l, __n, __hf, _H2(), _Hash(), __eql,
       __key_extract(), __a)
 { }

      _Hashtable(initializer_list<value_type> __l,
   size_type __n = 0,
   const _H1& __hf = _H1(),
   const key_equal& __eql = key_equal(),
   const allocator_type& __a = allocator_type())
      : _Hashtable(__l.begin(), __l.end(), __n, __hf, _H2(), _Hash(), __eql,
     __key_extract(), __a)
      { }

      _Hashtable&
      operator=(const _Hashtable& __ht);

      _Hashtable&
      operator=(_Hashtable&& __ht)
      noexcept(__node_alloc_traits::_S_nothrow_move())
      {
        constexpr bool __move_storage =
          __node_alloc_traits::_S_propagate_on_move_assign()
          || __node_alloc_traits::_S_always_equal();
        _M_move_assign(std::move(__ht),
                       integral_constant<bool, __move_storage>());
 return *this;
      }

      _Hashtable&
      operator=(initializer_list<value_type> __l)
      {
 __reuse_or_alloc_node_type __roan(_M_begin(), *this);
 _M_before_begin._M_nxt = nullptr;
 clear();
 this->_M_insert_range(__l.begin(), __l.end(), __roan);
 return *this;
      }

      ~_Hashtable() noexcept;

      void
      swap(_Hashtable&)
      noexcept(__node_alloc_traits::_S_nothrow_swap());


      iterator
      begin() noexcept
      { return iterator(_M_begin()); }

      const_iterator
      begin() const noexcept
      { return const_iterator(_M_begin()); }

      iterator
      end() noexcept
      { return iterator(nullptr); }

      const_iterator
      end() const noexcept
      { return const_iterator(nullptr); }

      const_iterator
      cbegin() const noexcept
      { return const_iterator(_M_begin()); }

      const_iterator
      cend() const noexcept
      { return const_iterator(nullptr); }

      size_type
      size() const noexcept
      { return _M_element_count; }

      bool
      empty() const noexcept
      { return size() == 0; }

      allocator_type
      get_allocator() const noexcept
      { return allocator_type(this->_M_node_allocator()); }

      size_type
      max_size() const noexcept
      { return __node_alloc_traits::max_size(this->_M_node_allocator()); }


      key_equal
      key_eq() const
      { return this->_M_eq(); }




      size_type
      bucket_count() const noexcept
      { return _M_bucket_count; }

      size_type
      max_bucket_count() const noexcept
      { return max_size(); }

      size_type
      bucket_size(size_type __n) const
      { return std::distance(begin(__n), end(__n)); }

      size_type
      bucket(const key_type& __k) const
      { return _M_bucket_index(__k, this->_M_hash_code(__k)); }

      local_iterator
      begin(size_type __n)
      {
 return local_iterator(*this, _M_bucket_begin(__n),
         __n, _M_bucket_count);
      }

      local_iterator
      end(size_type __n)
      { return local_iterator(*this, nullptr, __n, _M_bucket_count); }

      const_local_iterator
      begin(size_type __n) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__n),
        __n, _M_bucket_count);
      }

      const_local_iterator
      end(size_type __n) const
      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }


      const_local_iterator
      cbegin(size_type __n) const
      {
 return const_local_iterator(*this, _M_bucket_begin(__n),
        __n, _M_bucket_count);
      }

      const_local_iterator
      cend(size_type __n) const
      { return const_local_iterator(*this, nullptr, __n, _M_bucket_count); }

      float
      load_factor() const noexcept
      {
 return static_cast<float>(size()) / static_cast<float>(bucket_count());
      }






      const _RehashPolicy&
      __rehash_policy() const
      { return _M_rehash_policy; }

      void
      __rehash_policy(const _RehashPolicy&);


      iterator
      find(const key_type& __k);

      const_iterator
      find(const key_type& __k) const;

      size_type
      count(const key_type& __k) const;

      std::pair<iterator, iterator>
      equal_range(const key_type& __k);

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __k) const;

    protected:

      size_type
      _M_bucket_index(__node_type* __n) const noexcept
      { return __hash_code_base::_M_bucket_index(__n, _M_bucket_count); }

      size_type
      _M_bucket_index(const key_type& __k, __hash_code __c) const
      { return __hash_code_base::_M_bucket_index(__k, __c, _M_bucket_count); }



      __node_base*
      _M_find_before_node(size_type, const key_type&, __hash_code) const;

      __node_type*
      _M_find_node(size_type __bkt, const key_type& __key,
     __hash_code __c) const
      {
 __node_base* __before_n = _M_find_before_node(__bkt, __key, __c);
 if (__before_n)
   return static_cast<__node_type*>(__before_n->_M_nxt);
 return nullptr;
      }


      void
      _M_insert_bucket_begin(size_type, __node_type*);


      void
      _M_remove_bucket_begin(size_type __bkt, __node_type* __next_n,
        size_type __next_bkt);


      __node_base*
      _M_get_previous_node(size_type __bkt, __node_base* __n);




      iterator
      _M_insert_unique_node(size_type __bkt, __hash_code __code,
       __node_type* __n);



      iterator
      _M_insert_multi_node(__node_type* __hint,
      __hash_code __code, __node_type* __n);

      template<typename... _Args>
 std::pair<iterator, bool>
 _M_emplace(std::true_type, _Args&&... __args);

      template<typename... _Args>
 iterator
 _M_emplace(std::false_type __uk, _Args&&... __args)
 { return _M_emplace(cend(), __uk, std::forward<_Args>(__args)...); }


      template<typename... _Args>
 iterator
 _M_emplace(const_iterator, std::true_type __uk, _Args&&... __args)
 { return _M_emplace(__uk, std::forward<_Args>(__args)...).first; }

      template<typename... _Args>
 iterator
 _M_emplace(const_iterator, std::false_type, _Args&&... __args);

      template<typename _Arg, typename _NodeGenerator>
 std::pair<iterator, bool>
 _M_insert(_Arg&&, const _NodeGenerator&, std::true_type);

      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(_Arg&& __arg, const _NodeGenerator& __node_gen,
    std::false_type __uk)
 {
   return _M_insert(cend(), std::forward<_Arg>(__arg), __node_gen,
      __uk);
 }


      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(const_iterator, _Arg&& __arg, const _NodeGenerator& __node_gen,
    std::true_type __uk)
 {
   return
     _M_insert(std::forward<_Arg>(__arg), __node_gen, __uk).first;
 }


      template<typename _Arg, typename _NodeGenerator>
 iterator
 _M_insert(const_iterator, _Arg&&, const _NodeGenerator&, std::false_type);

      size_type
      _M_erase(std::true_type, const key_type&);

      size_type
      _M_erase(std::false_type, const key_type&);

      iterator
      _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n);

    public:

      template<typename... _Args>
 __ireturn_type
 emplace(_Args&&... __args)
 { return _M_emplace(__unique_keys(), std::forward<_Args>(__args)...); }

      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __hint, _Args&&... __args)
 {
   return _M_emplace(__hint, __unique_keys(),
       std::forward<_Args>(__args)...);
 }




      iterator
      erase(const_iterator);


      iterator
      erase(iterator __it)
      { return erase(const_iterator(__it)); }

      size_type
      erase(const key_type& __k)
      { return _M_erase(__unique_keys(), __k); }

      iterator
      erase(const_iterator, const_iterator);

      void
      clear() noexcept;


      void rehash(size_type __n);




    private:

      void _M_rehash_aux(size_type __n, std::true_type);


      void _M_rehash_aux(size_type __n, std::false_type);



      void _M_rehash(size_type __n, const __rehash_state& __state);
    };



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
   _Equal, _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::__node_type*
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_bucket_begin(size_type __bkt) const
    {
      __node_base* __n = _M_buckets[__bkt];
      return __n ? static_cast<__node_type*>(__n->_M_nxt) : nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(size_type __bucket_hint,
        const _H1& __h1, const _H2& __h2, const _Hash& __h,
        const _Equal& __eq, const _ExtractKey& __exk,
        const allocator_type& __a)
    : __hashtable_base(__exk, __h1, __h2, __h, __eq),
      __map_base(),
      __rehash_base(),
      __hashtable_alloc(__node_alloc_type(__a)),
      _M_element_count(0),
      _M_rehash_policy()
    {
      _M_bucket_count = _M_rehash_policy._M_next_bkt(__bucket_hint);
      _M_buckets = _M_allocate_buckets(_M_bucket_count);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _InputIterator>
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _Hashtable(_InputIterator __f, _InputIterator __l,
   size_type __bucket_hint,
   const _H1& __h1, const _H2& __h2, const _Hash& __h,
   const _Equal& __eq, const _ExtractKey& __exk,
   const allocator_type& __a)
      : __hashtable_base(__exk, __h1, __h2, __h, __eq),
 __map_base(),
 __rehash_base(),
 __hashtable_alloc(__node_alloc_type(__a)),
 _M_element_count(0),
 _M_rehash_policy()
      {
 auto __nb_elems = __detail::__distance_fw(__f, __l);
 _M_bucket_count =
   _M_rehash_policy._M_next_bkt(
     std::max(_M_rehash_policy._M_bkt_for_elements(__nb_elems),
       __bucket_hint));

 _M_buckets = _M_allocate_buckets(_M_bucket_count);
 try
   {
     for (; __f != __l; ++__f)
       this->insert(*__f);
   }
 catch(...)
   {
     clear();
     _M_deallocate_buckets();
     throw;
   }
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>&
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::operator=(
  const _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy, _Traits>& __ht)
      {
 if (&__ht == this)
   return *this;

 if (__node_alloc_traits::_S_propagate_on_copy_assign())
   {
     auto& __this_alloc = this->_M_node_allocator();
     auto& __that_alloc = __ht._M_node_allocator();
     if (!__node_alloc_traits::_S_always_equal()
  && __this_alloc != __that_alloc)
       {

  this->_M_deallocate_nodes(_M_begin());
  _M_before_begin._M_nxt = nullptr;
  _M_deallocate_buckets();
  _M_buckets = nullptr;
  std::__alloc_on_copy(__this_alloc, __that_alloc);
  __hashtable_base::operator=(__ht);
  _M_bucket_count = __ht._M_bucket_count;
  _M_element_count = __ht._M_element_count;
  _M_rehash_policy = __ht._M_rehash_policy;
  try
    {
      _M_assign(__ht,
         [this](const __node_type* __n)
         { return this->_M_allocate_node(__n->_M_v()); });
    }
  catch(...)
    {


      _M_reset();
      throw;
    }
  return *this;
       }
     std::__alloc_on_copy(__this_alloc, __that_alloc);
   }


 __bucket_type* __former_buckets = nullptr;
 std::size_t __former_bucket_count = _M_bucket_count;
 const __rehash_state& __former_state = _M_rehash_policy._M_state();

 if (_M_bucket_count != __ht._M_bucket_count)
   {
     __former_buckets = _M_buckets;
     _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);
     _M_bucket_count = __ht._M_bucket_count;
   }
 else
   __builtin_memset(_M_buckets, 0,
      _M_bucket_count * sizeof(__bucket_type));

 try
   {
     __hashtable_base::operator=(__ht);
     _M_element_count = __ht._M_element_count;
     _M_rehash_policy = __ht._M_rehash_policy;
     __reuse_or_alloc_node_type __roan(_M_begin(), *this);
     _M_before_begin._M_nxt = nullptr;
     _M_assign(__ht,
        [&__roan](const __node_type* __n)
        { return __roan(__n->_M_v()); });
     if (__former_buckets)
       _M_deallocate_buckets(__former_buckets, __former_bucket_count);
   }
 catch(...)
   {
     if (__former_buckets)
       {

  _M_deallocate_buckets();
  _M_rehash_policy._M_reset(__former_state);
  _M_buckets = __former_buckets;
  _M_bucket_count = __former_bucket_count;
       }
     __builtin_memset(_M_buckets, 0,
        _M_bucket_count * sizeof(__bucket_type));
     throw;
   }
 return *this;
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _NodeGenerator>
      void
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_assign(const _Hashtable& __ht, const _NodeGenerator& __node_gen)
      {
 __bucket_type* __buckets = nullptr;
 if (!_M_buckets)
   _M_buckets = __buckets = _M_allocate_buckets(_M_bucket_count);

 try
   {
     if (!__ht._M_before_begin._M_nxt)
       return;



     __node_type* __ht_n = __ht._M_begin();
     __node_type* __this_n = __node_gen(__ht_n);
     this->_M_copy_code(__this_n, __ht_n);
     _M_before_begin._M_nxt = __this_n;
     _M_buckets[_M_bucket_index(__this_n)] = &_M_before_begin;


     __node_base* __prev_n = __this_n;
     for (__ht_n = __ht_n->_M_next(); __ht_n; __ht_n = __ht_n->_M_next())
       {
  __this_n = __node_gen(__ht_n);
  __prev_n->_M_nxt = __this_n;
  this->_M_copy_code(__this_n, __ht_n);
  size_type __bkt = _M_bucket_index(__this_n);
  if (!_M_buckets[__bkt])
    _M_buckets[__bkt] = __prev_n;
  __prev_n = __this_n;
       }
   }
 catch(...)
   {
     clear();
     if (__buckets)
       _M_deallocate_buckets();
     throw;
   }
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_reset() noexcept
    {
      _M_rehash_policy._M_reset();
      _M_bucket_count = 1;
      _M_single_bucket = nullptr;
      _M_buckets = &_M_single_bucket;
      _M_before_begin._M_nxt = nullptr;
      _M_element_count = 0;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_move_assign(_Hashtable&& __ht, std::true_type)
    {
      this->_M_deallocate_nodes(_M_begin());
      _M_deallocate_buckets();
      __hashtable_base::operator=(std::move(__ht));
      _M_rehash_policy = __ht._M_rehash_policy;
      if (!__ht._M_uses_single_bucket())
 _M_buckets = __ht._M_buckets;
      else
 {
   _M_buckets = &_M_single_bucket;
   _M_single_bucket = __ht._M_single_bucket;
 }
      _M_bucket_count = __ht._M_bucket_count;
      _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;
      _M_element_count = __ht._M_element_count;
      std::__alloc_on_move(this->_M_node_allocator(), __ht._M_node_allocator());



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;
      __ht._M_reset();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_move_assign(_Hashtable&& __ht, std::false_type)
    {
      if (__ht._M_node_allocator() == this->_M_node_allocator())
 _M_move_assign(std::move(__ht), std::true_type());
      else
 {

   __bucket_type* __former_buckets = nullptr;
   size_type __former_bucket_count = _M_bucket_count;
   const __rehash_state& __former_state = _M_rehash_policy._M_state();

   if (_M_bucket_count != __ht._M_bucket_count)
     {
       __former_buckets = _M_buckets;
       _M_buckets = _M_allocate_buckets(__ht._M_bucket_count);
       _M_bucket_count = __ht._M_bucket_count;
     }
   else
     __builtin_memset(_M_buckets, 0,
        _M_bucket_count * sizeof(__bucket_type));

   try
     {
       __hashtable_base::operator=(std::move(__ht));
       _M_element_count = __ht._M_element_count;
       _M_rehash_policy = __ht._M_rehash_policy;
       __reuse_or_alloc_node_type __roan(_M_begin(), *this);
       _M_before_begin._M_nxt = nullptr;
       _M_assign(__ht,
   [&__roan](__node_type* __n)
   { return __roan(std::move_if_noexcept(__n->_M_v())); });
       __ht.clear();
     }
   catch(...)
     {
       if (__former_buckets)
  {
    _M_deallocate_buckets();
    _M_rehash_policy._M_reset(__former_state);
    _M_buckets = __former_buckets;
    _M_bucket_count = __former_bucket_count;
  }
       __builtin_memset(_M_buckets, 0,
          _M_bucket_count * sizeof(__bucket_type));
       throw;
     }
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(
 __node_alloc_traits::_S_select_on_copy(__ht._M_node_allocator())),
      _M_buckets(),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      _M_assign(__ht,
  [this](const __node_type* __n)
  { return this->_M_allocate_node(__n->_M_v()); });
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht) noexcept
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(std::move(__ht._M_base_alloc())),
      _M_buckets(__ht._M_buckets),
      _M_bucket_count(__ht._M_bucket_count),
      _M_before_begin(__ht._M_before_begin._M_nxt),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {

      if (__ht._M_uses_single_bucket())
 {
   _M_buckets = &_M_single_bucket;
   _M_single_bucket = __ht._M_single_bucket;
 }



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;

      __ht._M_reset();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(const _Hashtable& __ht, const allocator_type& __a)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(__node_alloc_type(__a)),
      _M_buckets(),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      _M_assign(__ht,
  [this](const __node_type* __n)
  { return this->_M_allocate_node(__n->_M_v()); });
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _Hashtable(_Hashtable&& __ht, const allocator_type& __a)
    : __hashtable_base(__ht),
      __map_base(__ht),
      __rehash_base(__ht),
      __hashtable_alloc(__node_alloc_type(__a)),
      _M_buckets(),
      _M_bucket_count(__ht._M_bucket_count),
      _M_element_count(__ht._M_element_count),
      _M_rehash_policy(__ht._M_rehash_policy)
    {
      if (__ht._M_node_allocator() == this->_M_node_allocator())
 {
   if (__ht._M_uses_single_bucket())
     {
       _M_buckets = &_M_single_bucket;
       _M_single_bucket = __ht._M_single_bucket;
     }
   else
     _M_buckets = __ht._M_buckets;

   _M_before_begin._M_nxt = __ht._M_before_begin._M_nxt;


   if (_M_begin())
     _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;
   __ht._M_reset();
 }
      else
 {
   _M_assign(__ht,
      [this](__node_type* __n)
      {
        return this->_M_allocate_node(
     std::move_if_noexcept(__n->_M_v()));
      });
   __ht.clear();
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    ~_Hashtable() noexcept
    {
      clear();
      if (_M_buckets)
 _M_deallocate_buckets();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    swap(_Hashtable& __x)
    noexcept(__node_alloc_traits::_S_nothrow_swap())
    {



      this->_M_swap(__x);

      std::__alloc_on_swap(this->_M_node_allocator(), __x._M_node_allocator());
      std::swap(_M_rehash_policy, __x._M_rehash_policy);


      if (this->_M_uses_single_bucket())
 {
   if (!__x._M_uses_single_bucket())
     {
       _M_buckets = __x._M_buckets;
       __x._M_buckets = &__x._M_single_bucket;
     }
 }
      else if (__x._M_uses_single_bucket())
 {
   __x._M_buckets = _M_buckets;
   _M_buckets = &_M_single_bucket;
 }
      else
 std::swap(_M_buckets, __x._M_buckets);

      std::swap(_M_bucket_count, __x._M_bucket_count);
      std::swap(_M_before_begin._M_nxt, __x._M_before_begin._M_nxt);
      std::swap(_M_element_count, __x._M_element_count);
      std::swap(_M_single_bucket, __x._M_single_bucket);



      if (_M_begin())
 _M_buckets[_M_bucket_index(_M_begin())] = &_M_before_begin;

      if (__x._M_begin())
 __x._M_buckets[__x._M_bucket_index(__x._M_begin())]
   = &__x._M_before_begin;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    __rehash_policy(const _RehashPolicy& __pol)
    {
      auto __do_rehash =
 __pol._M_need_rehash(_M_bucket_count, _M_element_count, 0);
      if (__do_rehash.first)
 _M_rehash(__do_rehash.second, _M_rehash_policy._M_state());
      _M_rehash_policy = __pol;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::iterator
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    find(const key_type& __k)
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);
      return __p ? iterator(__p) : end();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::const_iterator
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    find(const key_type& __k) const
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);
      return __p ? const_iterator(__p) : end();
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::size_type
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    count(const key_type& __k) const
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_bucket_begin(__n);
      if (!__p)
 return 0;

      std::size_t __result = 0;
      for (;; __p = __p->_M_next())
 {
   if (this->_M_equals(__k, __code, __p))
     ++__result;
   else if (__result)



     break;
   if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)
     break;
 }
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    std::pair<typename _Hashtable<_Key, _Value, _Alloc,
      _ExtractKey, _Equal, _H1,
      _H2, _Hash, _RehashPolicy,
      _Traits>::iterator,
       typename _Hashtable<_Key, _Value, _Alloc,
      _ExtractKey, _Equal, _H1,
      _H2, _Hash, _RehashPolicy,
      _Traits>::iterator>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k)
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);

      if (__p)
 {
   __node_type* __p1 = __p->_M_next();
   while (__p1 && _M_bucket_index(__p1) == __n
   && this->_M_equals(__k, __code, __p1))
     __p1 = __p1->_M_next();

   return std::make_pair(iterator(__p), iterator(__p1));
 }
      else
 return std::make_pair(end(), end());
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    std::pair<typename _Hashtable<_Key, _Value, _Alloc,
      _ExtractKey, _Equal, _H1,
      _H2, _Hash, _RehashPolicy,
      _Traits>::const_iterator,
       typename _Hashtable<_Key, _Value, _Alloc,
      _ExtractKey, _Equal, _H1,
      _H2, _Hash, _RehashPolicy,
      _Traits>::const_iterator>
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    equal_range(const key_type& __k) const
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __n = _M_bucket_index(__k, __code);
      __node_type* __p = _M_find_node(__n, __k, __code);

      if (__p)
 {
   __node_type* __p1 = __p->_M_next();
   while (__p1 && _M_bucket_index(__p1) == __n
   && this->_M_equals(__k, __code, __p1))
     __p1 = __p1->_M_next();

   return std::make_pair(const_iterator(__p), const_iterator(__p1));
 }
      else
 return std::make_pair(end(), end());
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
   _Equal, _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::__node_base*
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_find_before_node(size_type __n, const key_type& __k,
   __hash_code __code) const
    {
      __node_base* __prev_p = _M_buckets[__n];
      if (!__prev_p)
 return nullptr;

      for (__node_type* __p = static_cast<__node_type*>(__prev_p->_M_nxt);;
    __p = __p->_M_next())
 {
   if (this->_M_equals(__k, __code, __p))
     return __prev_p;

   if (!__p->_M_nxt || _M_bucket_index(__p->_M_next()) != __n)
     break;
   __prev_p = __p;
 }
      return nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_bucket_begin(size_type __bkt, __node_type* __node)
    {
      if (_M_buckets[__bkt])
 {


   __node->_M_nxt = _M_buckets[__bkt]->_M_nxt;
   _M_buckets[__bkt]->_M_nxt = __node;
 }
      else
 {



   __node->_M_nxt = _M_before_begin._M_nxt;
   _M_before_begin._M_nxt = __node;
   if (__node->_M_nxt)


     _M_buckets[_M_bucket_index(__node->_M_next())] = __node;
   _M_buckets[__bkt] = &_M_before_begin;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_remove_bucket_begin(size_type __bkt, __node_type* __next,
      size_type __next_bkt)
    {
      if (!__next || __next_bkt != __bkt)
 {


   if (__next)
     _M_buckets[__next_bkt] = _M_buckets[__bkt];


   if (&_M_before_begin == _M_buckets[__bkt])
     _M_before_begin._M_nxt = __next;
   _M_buckets[__bkt] = nullptr;
 }
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey,
   _Equal, _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::__node_base*
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_get_previous_node(size_type __bkt, __node_base* __n)
    {
      __node_base* __prev_n = _M_buckets[__bkt];
      while (__prev_n->_M_nxt != __n)
 __prev_n = __prev_n->_M_nxt;
      return __prev_n;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename... _Args>
      std::pair<typename _Hashtable<_Key, _Value, _Alloc,
        _ExtractKey, _Equal, _H1,
        _H2, _Hash, _RehashPolicy,
        _Traits>::iterator, bool>
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_emplace(std::true_type, _Args&&... __args)
      {

 __node_type* __node = this->_M_allocate_node(std::forward<_Args>(__args)...);
 const key_type& __k = this->_M_extract()(__node->_M_v());
 __hash_code __code;
 try
   {
     __code = this->_M_hash_code(__k);
   }
 catch(...)
   {
     this->_M_deallocate_node(__node);
     throw;
   }

 size_type __bkt = _M_bucket_index(__k, __code);
 if (__node_type* __p = _M_find_node(__bkt, __k, __code))
   {

     this->_M_deallocate_node(__node);
     return std::make_pair(iterator(__p), false);
   }


 return std::make_pair(_M_insert_unique_node(__bkt, __code, __node),
         true);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename... _Args>
      typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy,
     _Traits>::iterator
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_emplace(const_iterator __hint, std::false_type, _Args&&... __args)
      {

 __node_type* __node =
   this->_M_allocate_node(std::forward<_Args>(__args)...);

 __hash_code __code;
 try
   {
     __code = this->_M_hash_code(this->_M_extract()(__node->_M_v()));
   }
 catch(...)
   {
     this->_M_deallocate_node(__node);
     throw;
   }

 return _M_insert_multi_node(__hint._M_cur, __code, __node);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::iterator
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_unique_node(size_type __bkt, __hash_code __code,
     __node_type* __node)
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);

      try
 {
   if (__do_rehash.first)
     {
       _M_rehash(__do_rehash.second, __saved_state);
       __bkt = _M_bucket_index(this->_M_extract()(__node->_M_v()), __code);
     }

   this->_M_store_code(__node, __code);


   _M_insert_bucket_begin(__bkt, __node);
   ++_M_element_count;
   return iterator(__node);
 }
      catch(...)
 {
   this->_M_deallocate_node(__node);
   throw;
 }
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::iterator
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_insert_multi_node(__node_type* __hint, __hash_code __code,
    __node_type* __node)
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::pair<bool, std::size_t> __do_rehash
 = _M_rehash_policy._M_need_rehash(_M_bucket_count, _M_element_count, 1);

      try
 {
   if (__do_rehash.first)
     _M_rehash(__do_rehash.second, __saved_state);

   this->_M_store_code(__node, __code);
   const key_type& __k = this->_M_extract()(__node->_M_v());
   size_type __bkt = _M_bucket_index(__k, __code);



   __node_base* __prev
     = __builtin_expect(__hint != nullptr, false)
       && this->_M_equals(__k, __code, __hint)
  ? __hint
  : _M_find_before_node(__bkt, __k, __code);
   if (__prev)
     {

       __node->_M_nxt = __prev->_M_nxt;
       __prev->_M_nxt = __node;
       if (__builtin_expect(__prev == __hint, false))


        if (__node->_M_nxt
            && !this->_M_equals(__k, __code, __node->_M_next()))
          {
            size_type __next_bkt = _M_bucket_index(__node->_M_next());
            if (__next_bkt != __bkt)
              _M_buckets[__next_bkt] = __node;
          }
     }
   else




     _M_insert_bucket_begin(__bkt, __node);
   ++_M_element_count;
   return iterator(__node);
 }
      catch(...)
 {
   this->_M_deallocate_node(__node);
   throw;
 }
    }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Arg, typename _NodeGenerator>
      std::pair<typename _Hashtable<_Key, _Value, _Alloc,
        _ExtractKey, _Equal, _H1,
        _H2, _Hash, _RehashPolicy,
        _Traits>::iterator, bool>
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_insert(_Arg&& __v, const _NodeGenerator& __node_gen, std::true_type)
      {
 const key_type& __k = this->_M_extract()(__v);
 __hash_code __code = this->_M_hash_code(__k);
 size_type __bkt = _M_bucket_index(__k, __code);

 __node_type* __n = _M_find_node(__bkt, __k, __code);
 if (__n)
   return std::make_pair(iterator(__n), false);

 __n = __node_gen(std::forward<_Arg>(__v));
 return std::make_pair(_M_insert_unique_node(__bkt, __code, __n), true);
      }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    template<typename _Arg, typename _NodeGenerator>
      typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
     _H1, _H2, _Hash, _RehashPolicy,
     _Traits>::iterator
      _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy, _Traits>::
      _M_insert(const_iterator __hint, _Arg&& __v,
  const _NodeGenerator& __node_gen,
  std::false_type)
      {


 __hash_code __code = this->_M_hash_code(this->_M_extract()(__v));


 __node_type* __node = __node_gen(std::forward<_Arg>(__v));

 return _M_insert_multi_node(__hint._M_cur, __code, __node);
      }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::iterator
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    erase(const_iterator __it)
    {
      __node_type* __n = __it._M_cur;
      std::size_t __bkt = _M_bucket_index(__n);




      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
      return _M_erase(__bkt, __prev_n, __n);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::iterator
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(size_type __bkt, __node_base* __prev_n, __node_type* __n)
    {
      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n->_M_next(),
    __n->_M_nxt ? _M_bucket_index(__n->_M_next()) : 0);
      else if (__n->_M_nxt)
 {
   size_type __next_bkt = _M_bucket_index(__n->_M_next());
   if (__next_bkt != __bkt)
     _M_buckets[__next_bkt] = __prev_n;
 }

      __prev_n->_M_nxt = __n->_M_nxt;
      iterator __result(__n->_M_next());
      this->_M_deallocate_node(__n);
      --_M_element_count;

      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::size_type
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(std::true_type, const key_type& __k)
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);


      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
 return 0;


      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
      _M_erase(__bkt, __prev_n, __n);
      return 1;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::size_type
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_erase(std::false_type, const key_type& __k)
    {
      __hash_code __code = this->_M_hash_code(__k);
      std::size_t __bkt = _M_bucket_index(__k, __code);


      __node_base* __prev_n = _M_find_before_node(__bkt, __k, __code);
      if (!__prev_n)
 return 0;







      __node_type* __n = static_cast<__node_type*>(__prev_n->_M_nxt);
      __node_type* __n_last = __n;
      std::size_t __n_last_bkt = __bkt;
      do
 {
   __n_last = __n_last->_M_next();
   if (!__n_last)
     break;
   __n_last_bkt = _M_bucket_index(__n_last);
 }
      while (__n_last_bkt == __bkt && this->_M_equals(__k, __code, __n_last));


      size_type __result = 0;
      do
 {
   __node_type* __p = __n->_M_next();
   this->_M_deallocate_node(__n);
   __n = __p;
   ++__result;
   --_M_element_count;
 }
      while (__n != __n_last);

      if (__prev_n == _M_buckets[__bkt])
 _M_remove_bucket_begin(__bkt, __n_last, __n_last_bkt);
      else if (__n_last && __n_last_bkt != __bkt)
 _M_buckets[__n_last_bkt] = __prev_n;
      __prev_n->_M_nxt = __n_last;
      return __result;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    typename _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
   _H1, _H2, _Hash, _RehashPolicy,
   _Traits>::iterator
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    erase(const_iterator __first, const_iterator __last)
    {
      __node_type* __n = __first._M_cur;
      __node_type* __last_n = __last._M_cur;
      if (__n == __last_n)
 return iterator(__n);

      std::size_t __bkt = _M_bucket_index(__n);

      __node_base* __prev_n = _M_get_previous_node(__bkt, __n);
      bool __is_bucket_begin = __n == _M_bucket_begin(__bkt);
      std::size_t __n_bkt = __bkt;
      for (;;)
 {
   do
     {
       __node_type* __tmp = __n;
       __n = __n->_M_next();
       this->_M_deallocate_node(__tmp);
       --_M_element_count;
       if (!__n)
  break;
       __n_bkt = _M_bucket_index(__n);
     }
   while (__n != __last_n && __n_bkt == __bkt);
   if (__is_bucket_begin)
     _M_remove_bucket_begin(__bkt, __n, __n_bkt);
   if (__n == __last_n)
     break;
   __is_bucket_begin = true;
   __bkt = __n_bkt;
 }

      if (__n && (__n_bkt != __bkt || __is_bucket_begin))
 _M_buckets[__n_bkt] = __prev_n;
      __prev_n->_M_nxt = __n;
      return iterator(__n);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    clear() noexcept
    {
      this->_M_deallocate_nodes(_M_begin());
      __builtin_memset(_M_buckets, 0, _M_bucket_count * sizeof(__bucket_type));
      _M_element_count = 0;
      _M_before_begin._M_nxt = nullptr;
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    rehash(size_type __n)
    {
      const __rehash_state& __saved_state = _M_rehash_policy._M_state();
      std::size_t __buckets
 = std::max(_M_rehash_policy._M_bkt_for_elements(_M_element_count + 1),
     __n);
      __buckets = _M_rehash_policy._M_next_bkt(__buckets);

      if (__buckets != _M_bucket_count)
 _M_rehash(__buckets, __saved_state);
      else

 _M_rehash_policy._M_reset(__saved_state);
    }

  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash(size_type __n, const __rehash_state& __state)
    {
      try
 {
   _M_rehash_aux(__n, __unique_keys());
 }
      catch(...)
 {


   _M_rehash_policy._M_reset(__state);
   throw;
 }
    }


  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash_aux(size_type __n, std::true_type)
    {
      __bucket_type* __new_buckets = _M_allocate_buckets(__n);
      __node_type* __p = _M_begin();
      _M_before_begin._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      while (__p)
 {
   __node_type* __next = __p->_M_next();
   std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);
   if (!__new_buckets[__bkt])
     {
       __p->_M_nxt = _M_before_begin._M_nxt;
       _M_before_begin._M_nxt = __p;
       __new_buckets[__bkt] = &_M_before_begin;
       if (__p->_M_nxt)
  __new_buckets[__bbegin_bkt] = __p;
       __bbegin_bkt = __bkt;
     }
   else
     {
       __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
       __new_buckets[__bkt]->_M_nxt = __p;
     }
   __p = __next;
 }

      _M_deallocate_buckets();
      _M_bucket_count = __n;
      _M_buckets = __new_buckets;
    }



  template<typename _Key, typename _Value,
    typename _Alloc, typename _ExtractKey, typename _Equal,
    typename _H1, typename _H2, typename _Hash, typename _RehashPolicy,
    typename _Traits>
    void
    _Hashtable<_Key, _Value, _Alloc, _ExtractKey, _Equal,
        _H1, _H2, _Hash, _RehashPolicy, _Traits>::
    _M_rehash_aux(size_type __n, std::false_type)
    {
      __bucket_type* __new_buckets = _M_allocate_buckets(__n);

      __node_type* __p = _M_begin();
      _M_before_begin._M_nxt = nullptr;
      std::size_t __bbegin_bkt = 0;
      std::size_t __prev_bkt = 0;
      __node_type* __prev_p = nullptr;
      bool __check_bucket = false;

      while (__p)
 {
   __node_type* __next = __p->_M_next();
   std::size_t __bkt = __hash_code_base::_M_bucket_index(__p, __n);

   if (__prev_p && __prev_bkt == __bkt)
     {



       __p->_M_nxt = __prev_p->_M_nxt;
       __prev_p->_M_nxt = __p;






       __check_bucket = true;
     }
   else
     {
       if (__check_bucket)
  {


    if (__prev_p->_M_nxt)
      {
        std::size_t __next_bkt
   = __hash_code_base::_M_bucket_index(__prev_p->_M_next(),
           __n);
        if (__next_bkt != __prev_bkt)
   __new_buckets[__next_bkt] = __prev_p;
      }
    __check_bucket = false;
  }

       if (!__new_buckets[__bkt])
  {
    __p->_M_nxt = _M_before_begin._M_nxt;
    _M_before_begin._M_nxt = __p;
    __new_buckets[__bkt] = &_M_before_begin;
    if (__p->_M_nxt)
      __new_buckets[__bbegin_bkt] = __p;
    __bbegin_bkt = __bkt;
  }
       else
  {
    __p->_M_nxt = __new_buckets[__bkt]->_M_nxt;
    __new_buckets[__bkt]->_M_nxt = __p;
  }
     }
   __prev_p = __p;
   __prev_bkt = __bkt;
   __p = __next;
 }

      if (__check_bucket && __prev_p->_M_nxt)
 {
   std::size_t __next_bkt
     = __hash_code_base::_M_bucket_index(__prev_p->_M_next(), __n);
   if (__next_bkt != __prev_bkt)
     __new_buckets[__next_bkt] = __prev_p;
 }

      _M_deallocate_buckets();
      _M_bucket_count = __n;
      _M_buckets = __new_buckets;
    }


}
# 48 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/unordered_map" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 1 3
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<bool _Cache>
    using __umap_traits = __detail::_Hashtable_traits<_Cache, false, true>;

  template<typename _Key,
    typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = std::equal_to<_Key>,
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    typename _Tr = __umap_traits<__cache_default<_Key, _Hash>::value>>
    using __umap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
                                        _Alloc, __detail::_Select1st,
            _Pred, _Hash,
            __detail::_Mod_range_hashing,
            __detail::_Default_ranged_hash,
            __detail::_Prime_rehash_policy, _Tr>;


  template<bool _Cache>
    using __ummap_traits = __detail::_Hashtable_traits<_Cache, false, false>;

  template<typename _Key,
    typename _Tp,
    typename _Hash = hash<_Key>,
    typename _Pred = std::equal_to<_Key>,
    typename _Alloc = std::allocator<std::pair<const _Key, _Tp> >,
    typename _Tr = __ummap_traits<__cache_default<_Key, _Hash>::value>>
    using __ummap_hashtable = _Hashtable<_Key, std::pair<const _Key, _Tp>,
      _Alloc, __detail::_Select1st,
      _Pred, _Hash,
      __detail::_Mod_range_hashing,
      __detail::_Default_ranged_hash,
      __detail::_Prime_rehash_policy, _Tr>;
# 94 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
  template<class _Key, class _Tp,
    class _Hash = hash<_Key>,
    class _Pred = std::equal_to<_Key>,
    class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class unordered_map
    {
      typedef __umap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::mapped_type mapped_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename _Hashtable::pointer pointer;
      typedef typename _Hashtable::const_pointer const_pointer;
      typedef typename _Hashtable::reference reference;
      typedef typename _Hashtable::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;
# 138 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      explicit
      unordered_map(size_type __n = 10,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 159 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      template<typename _InputIterator>
 unordered_map(_InputIterator __f, _InputIterator __l,
        size_type __n = 0,
        const hasher& __hf = hasher(),
        const key_equal& __eql = key_equal(),
        const allocator_type& __a = allocator_type())
 : _M_h(__f, __l, __n, __hf, __eql, __a)
 { }


      unordered_map(const unordered_map&) = default;


      unordered_map(unordered_map&&) = default;





      explicit
      unordered_map(const allocator_type& __a)
 : _M_h(__a)
      { }






      unordered_map(const unordered_map& __umap,
      const allocator_type& __a)
 : _M_h(__umap._M_h, __a)
      { }






      unordered_map(unordered_map&& __umap,
      const allocator_type& __a)
 : _M_h(std::move(__umap._M_h), __a)
      { }
# 214 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      unordered_map(initializer_list<value_type> __l,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
 : _M_h(__l, __n, __hf, __eql, __a)
      { }


      unordered_map&
      operator=(const unordered_map&) = default;


      unordered_map&
      operator=(unordered_map&&) = default;
# 241 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      unordered_map&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }







      iterator
      begin() noexcept
      { return _M_h.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }

      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }






      iterator
      end() noexcept
      { return _M_h.end(); }






      const_iterator
      end() const noexcept
      { return _M_h.end(); }

      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 338 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      template<typename... _Args>
 std::pair<iterator, bool>
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 368 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
# 391 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      std::pair<iterator, bool>
      insert(const value_type& __x)
      { return _M_h.insert(__x); }

      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
 std::pair<iterator, bool>
 insert(_Pair&& __x)
        { return _M_h.insert(std::forward<_Pair>(__x)); }
# 425 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }

      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
 iterator
 insert(const_iterator __hint, _Pair&& __x)
 { return _M_h.insert(__hint, std::forward<_Pair>(__x)); }
# 446 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 458 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }
# 476 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __it)
      { return _M_h.erase(__it); }
# 498 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 516 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
# 539 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      void
      swap(unordered_map& __x)
      noexcept( noexcept(_M_h.swap(__x._M_h)) )
      { _M_h.swap(__x._M_h); }





      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 572 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }
# 590 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }
# 603 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }
# 625 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      mapped_type&
      operator[](const key_type& __k)
      { return _M_h[__k]; }

      mapped_type&
      operator[](key_type&& __k)
      { return _M_h[std::move(__k)]; }
# 642 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      mapped_type&
      at(const key_type& __k)
      { return _M_h.at(__k); }

      const mapped_type&
      at(const key_type& __k) const
      { return _M_h.at(__k); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }







      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }
# 698 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 713 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }
# 724 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 761 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 772 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
      operator==(const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&,
   const unordered_map<_Key1, _Tp1, _Hash1, _Pred1, _Alloc1>&);
    };
# 806 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
  template<class _Key, class _Tp,
    class _Hash = hash<_Key>,
    class _Pred = std::equal_to<_Key>,
    class _Alloc = std::allocator<std::pair<const _Key, _Tp> > >
    class unordered_multimap
    {
      typedef __ummap_hashtable<_Key, _Tp, _Hash, _Pred, _Alloc> _Hashtable;
      _Hashtable _M_h;

    public:



      typedef typename _Hashtable::key_type key_type;
      typedef typename _Hashtable::value_type value_type;
      typedef typename _Hashtable::mapped_type mapped_type;
      typedef typename _Hashtable::hasher hasher;
      typedef typename _Hashtable::key_equal key_equal;
      typedef typename _Hashtable::allocator_type allocator_type;




      typedef typename _Hashtable::pointer pointer;
      typedef typename _Hashtable::const_pointer const_pointer;
      typedef typename _Hashtable::reference reference;
      typedef typename _Hashtable::const_reference const_reference;
      typedef typename _Hashtable::iterator iterator;
      typedef typename _Hashtable::const_iterator const_iterator;
      typedef typename _Hashtable::local_iterator local_iterator;
      typedef typename _Hashtable::const_local_iterator const_local_iterator;
      typedef typename _Hashtable::size_type size_type;
      typedef typename _Hashtable::difference_type difference_type;
# 850 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      explicit
      unordered_multimap(size_type __n = 10,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
      : _M_h(__n, __hf, __eql, __a)
      { }
# 871 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      template<typename _InputIterator>
 unordered_multimap(_InputIterator __f, _InputIterator __l,
      size_type __n = 0,
      const hasher& __hf = hasher(),
      const key_equal& __eql = key_equal(),
      const allocator_type& __a = allocator_type())
 : _M_h(__f, __l, __n, __hf, __eql, __a)
 { }


      unordered_multimap(const unordered_multimap&) = default;


      unordered_multimap(unordered_multimap&&) = default;





      explicit
      unordered_multimap(const allocator_type& __a)
 : _M_h(__a)
      { }






      unordered_multimap(const unordered_multimap& __ummap,
    const allocator_type& __a)
 : _M_h(__ummap._M_h, __a)
      { }






      unordered_multimap(unordered_multimap&& __ummap,
    const allocator_type& __a)
 : _M_h(std::move(__ummap._M_h), __a)
      { }
# 926 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      unordered_multimap(initializer_list<value_type> __l,
    size_type __n = 0,
    const hasher& __hf = hasher(),
    const key_equal& __eql = key_equal(),
    const allocator_type& __a = allocator_type())
 : _M_h(__l, __n, __hf, __eql, __a)
      { }


      unordered_multimap&
      operator=(const unordered_multimap&) = default;


      unordered_multimap&
      operator=(unordered_multimap&&) = default;
# 953 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      unordered_multimap&
      operator=(initializer_list<value_type> __l)
      {
 _M_h = __l;
 return *this;
      }



      allocator_type
      get_allocator() const noexcept
      { return _M_h.get_allocator(); }




      bool
      empty() const noexcept
      { return _M_h.empty(); }


      size_type
      size() const noexcept
      { return _M_h.size(); }


      size_type
      max_size() const noexcept
      { return _M_h.max_size(); }







      iterator
      begin() noexcept
      { return _M_h.begin(); }






      const_iterator
      begin() const noexcept
      { return _M_h.begin(); }

      const_iterator
      cbegin() const noexcept
      { return _M_h.begin(); }






      iterator
      end() noexcept
      { return _M_h.end(); }






      const_iterator
      end() const noexcept
      { return _M_h.end(); }

      const_iterator
      cend() const noexcept
      { return _M_h.end(); }
# 1046 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace(_Args&&... __args)
 { return _M_h.emplace(std::forward<_Args>(__args)...); }
# 1072 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      template<typename... _Args>
 iterator
 emplace_hint(const_iterator __pos, _Args&&... __args)
 { return _M_h.emplace_hint(__pos, std::forward<_Args>(__args)...); }
# 1087 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      iterator
      insert(const value_type& __x)
      { return _M_h.insert(__x); }

      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
 iterator
 insert(_Pair&& __x)
        { return _M_h.insert(std::forward<_Pair>(__x)); }
# 1119 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      iterator
      insert(const_iterator __hint, const value_type& __x)
      { return _M_h.insert(__hint, __x); }

      template<typename _Pair, typename = typename
        std::enable_if<std::is_constructible<value_type,
          _Pair&&>::value>::type>
 iterator
 insert(const_iterator __hint, _Pair&& __x)
        { return _M_h.insert(__hint, std::forward<_Pair>(__x)); }
# 1140 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      template<typename _InputIterator>
 void
 insert(_InputIterator __first, _InputIterator __last)
 { _M_h.insert(__first, __last); }
# 1153 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      void
      insert(initializer_list<value_type> __l)
      { _M_h.insert(__l); }
# 1171 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __position)
      { return _M_h.erase(__position); }


      iterator
      erase(iterator __it)
      { return _M_h.erase(__it); }
# 1192 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      size_type
      erase(const key_type& __x)
      { return _M_h.erase(__x); }
# 1211 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      iterator
      erase(const_iterator __first, const_iterator __last)
      { return _M_h.erase(__first, __last); }







      void
      clear() noexcept
      { _M_h.clear(); }
# 1235 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      void
      swap(unordered_multimap& __x)
      noexcept( noexcept(_M_h.swap(__x._M_h)) )
      { _M_h.swap(__x._M_h); }





      hasher
      hash_function() const
      { return _M_h.hash_function(); }



      key_equal
      key_eq() const
      { return _M_h.key_eq(); }
# 1268 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      iterator
      find(const key_type& __x)
      { return _M_h.find(__x); }

      const_iterator
      find(const key_type& __x) const
      { return _M_h.find(__x); }







      size_type
      count(const key_type& __x) const
      { return _M_h.count(__x); }
# 1293 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      std::pair<iterator, iterator>
      equal_range(const key_type& __x)
      { return _M_h.equal_range(__x); }

      std::pair<const_iterator, const_iterator>
      equal_range(const key_type& __x) const
      { return _M_h.equal_range(__x); }





      size_type
      bucket_count() const noexcept
      { return _M_h.bucket_count(); }


      size_type
      max_bucket_count() const noexcept
      { return _M_h.max_bucket_count(); }






      size_type
      bucket_size(size_type __n) const
      { return _M_h.bucket_size(__n); }






      size_type
      bucket(const key_type& __key) const
      { return _M_h.bucket(__key); }







      local_iterator
      begin(size_type __n)
      { return _M_h.begin(__n); }
# 1349 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      const_local_iterator
      begin(size_type __n) const
      { return _M_h.begin(__n); }

      const_local_iterator
      cbegin(size_type __n) const
      { return _M_h.cbegin(__n); }
# 1364 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      local_iterator
      end(size_type __n)
      { return _M_h.end(__n); }
# 1375 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      const_local_iterator
      end(size_type __n) const
      { return _M_h.end(__n); }

      const_local_iterator
      cend(size_type __n) const
      { return _M_h.cend(__n); }





      float
      load_factor() const noexcept
      { return _M_h.load_factor(); }



      float
      max_load_factor() const noexcept
      { return _M_h.max_load_factor(); }





      void
      max_load_factor(float __z)
      { _M_h.max_load_factor(__z); }
# 1412 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      void
      rehash(size_type __n)
      { _M_h.rehash(__n); }
# 1423 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unordered_map.h" 3
      void
      reserve(size_type __n)
      { _M_h.reserve(__n); }

      template<typename _Key1, typename _Tp1, typename _Hash1, typename _Pred1,
        typename _Alloc1>
        friend bool
 operator==(const unordered_multimap<_Key1, _Tp1,
         _Hash1, _Pred1, _Alloc1>&,
     const unordered_multimap<_Key1, _Tp1,
         _Hash1, _Pred1, _Alloc1>&);
    };

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline void
    swap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
  unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { __x.swap(__y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return __x._M_h._M_equal(__y._M_h); }

  template<class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>
    inline bool
    operator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,
        const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)
    { return !(__x == __y); }


}
# 49 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/unordered_map" 2 3
# 11 "../Quadris/Engine.h" 2
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cstdarg" 1
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cstdarg"
       
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cstdarg" 3
# 52 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/cstdarg" 3
namespace std
{
  using ::va_list;
}
# 12 "../Quadris/Engine.h" 2
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/chrono" 1
# 32 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/chrono"
       
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/chrono" 3





# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ratio" 1 3
# 32 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ratio" 3
       
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ratio" 3
# 43 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ratio" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 55 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ratio" 3
  template<intmax_t _Pn>
    struct __static_sign
    : integral_constant<intmax_t, (_Pn < 0) ? -1 : 1>
    { };

  template<intmax_t _Pn>
    struct __static_abs
    : integral_constant<intmax_t, _Pn * __static_sign<_Pn>::value>
    { };

  template<intmax_t _Pn, intmax_t _Qn>
    struct __static_gcd
    : __static_gcd<_Qn, (_Pn % _Qn)>
    { };

  template<intmax_t _Pn>
    struct __static_gcd<_Pn, 0>
    : integral_constant<intmax_t, __static_abs<_Pn>::value>
    { };

  template<intmax_t _Qn>
    struct __static_gcd<0, _Qn>
    : integral_constant<intmax_t, __static_abs<_Qn>::value>
    { };







  template<intmax_t _Pn, intmax_t _Qn>
    struct __safe_multiply
    {
    private:
      static const uintmax_t __c = uintmax_t(1) << (sizeof(intmax_t) * 4);

      static const uintmax_t __a0 = __static_abs<_Pn>::value % __c;
      static const uintmax_t __a1 = __static_abs<_Pn>::value / __c;
      static const uintmax_t __b0 = __static_abs<_Qn>::value % __c;
      static const uintmax_t __b1 = __static_abs<_Qn>::value / __c;

      static_assert(__a1 == 0 || __b1 == 0,
      "overflow in multiplication");
      static_assert(__a0 * __b1 + __b0 * __a1 < (__c >> 1),
      "overflow in multiplication");
      static_assert(__b0 * __a0 <= 9223372036854775807LL,
      "overflow in multiplication");
      static_assert((__a0 * __b1 + __b0 * __a1) * __c
      <= 9223372036854775807LL - __b0 * __a0,
      "overflow in multiplication");

    public:
      static const intmax_t value = _Pn * _Qn;
    };



  template<uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2>
    struct __big_less
    : integral_constant<bool, (__hi1 < __hi2
          || (__hi1 == __hi2 && __lo1 < __lo2))>
    { };

  template<uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2>
    struct __big_add
    {
      static constexpr uintmax_t __lo = __lo1 + __lo2;
      static constexpr uintmax_t __hi = (__hi1 + __hi2 +
      (__lo1 + __lo2 < __lo1));
    };


  template<uintmax_t __hi1, uintmax_t __lo1, uintmax_t __hi2, uintmax_t __lo2>
    struct __big_sub
    {
      static_assert(!__big_less<__hi1, __lo1, __hi2, __lo2>::value,
      "Internal library error");
      static constexpr uintmax_t __lo = __lo1 - __lo2;
      static constexpr uintmax_t __hi = (__hi1 - __hi2 -
      (__lo1 < __lo2));
    };


  template<uintmax_t __x, uintmax_t __y>
    struct __big_mul
    {
    private:
      static constexpr uintmax_t __c = uintmax_t(1) << (sizeof(intmax_t) * 4);
      static constexpr uintmax_t __x0 = __x % __c;
      static constexpr uintmax_t __x1 = __x / __c;
      static constexpr uintmax_t __y0 = __y % __c;
      static constexpr uintmax_t __y1 = __y / __c;
      static constexpr uintmax_t __x0y0 = __x0 * __y0;
      static constexpr uintmax_t __x0y1 = __x0 * __y1;
      static constexpr uintmax_t __x1y0 = __x1 * __y0;
      static constexpr uintmax_t __x1y1 = __x1 * __y1;
      static constexpr uintmax_t __mix = __x0y1 + __x1y0;
      static constexpr uintmax_t __mix_lo = __mix * __c;
      static constexpr uintmax_t __mix_hi
      = __mix / __c + ((__mix < __x0y1) ? __c : 0);
      typedef __big_add<__mix_hi, __mix_lo, __x1y1, __x0y0> _Res;
    public:
      static constexpr uintmax_t __hi = _Res::__hi;
      static constexpr uintmax_t __lo = _Res::__lo;
    };



  template<uintmax_t __n1, uintmax_t __n0, uintmax_t __d>
    struct __big_div_impl
    {
    private:
      static_assert(__d >= (uintmax_t(1) << (sizeof(intmax_t) * 8 - 1)),
      "Internal library error");
      static_assert(__n1 < __d, "Internal library error");
      static constexpr uintmax_t __c = uintmax_t(1) << (sizeof(intmax_t) * 4);
      static constexpr uintmax_t __d1 = __d / __c;
      static constexpr uintmax_t __d0 = __d % __c;

      static constexpr uintmax_t __q1x = __n1 / __d1;
      static constexpr uintmax_t __r1x = __n1 % __d1;
      static constexpr uintmax_t __m = __q1x * __d0;
      static constexpr uintmax_t __r1y = __r1x * __c + __n0 / __c;
      static constexpr uintmax_t __r1z = __r1y + __d;
      static constexpr uintmax_t __r1
      = ((__r1y < __m) ? ((__r1z >= __d) && (__r1z < __m))
  ? (__r1z + __d) : __r1z : __r1y) - __m;
      static constexpr uintmax_t __q1
      = __q1x - ((__r1y < __m)
   ? ((__r1z >= __d) && (__r1z < __m)) ? 2 : 1 : 0);
      static constexpr uintmax_t __q0x = __r1 / __d1;
      static constexpr uintmax_t __r0x = __r1 % __d1;
      static constexpr uintmax_t __n = __q0x * __d0;
      static constexpr uintmax_t __r0y = __r0x * __c + __n0 % __c;
      static constexpr uintmax_t __r0z = __r0y + __d;
      static constexpr uintmax_t __r0
      = ((__r0y < __n) ? ((__r0z >= __d) && (__r0z < __n))
  ? (__r0z + __d) : __r0z : __r0y) - __n;
      static constexpr uintmax_t __q0
      = __q0x - ((__r0y < __n) ? ((__r0z >= __d)
      && (__r0z < __n)) ? 2 : 1 : 0);

    public:
      static constexpr uintmax_t __quot = __q1 * __c + __q0;
      static constexpr uintmax_t __rem = __r0;

    private:
      typedef __big_mul<__quot, __d> _Prod;
      typedef __big_add<_Prod::__hi, _Prod::__lo, 0, __rem> _Sum;
      static_assert(_Sum::__hi == __n1 && _Sum::__lo == __n0,
      "Internal library error");
  };

  template<uintmax_t __n1, uintmax_t __n0, uintmax_t __d>
    struct __big_div
    {
    private:
      static_assert(__d != 0, "Internal library error");
      static_assert(sizeof (uintmax_t) == sizeof (unsigned long long),
      "This library calls __builtin_clzll on uintmax_t, which "
      "is unsafe on your platform. Please complain to "
      "http://gcc.gnu.org/bugzilla/");
      static constexpr int __shift = __builtin_clzll(__d);
      static constexpr int __coshift_ = sizeof(uintmax_t) * 8 - __shift;
      static constexpr int __coshift = (__shift != 0) ? __coshift_ : 0;
      static constexpr uintmax_t __c1 = uintmax_t(1) << __shift;
      static constexpr uintmax_t __c2 = uintmax_t(1) << __coshift;
      static constexpr uintmax_t __new_d = __d * __c1;
      static constexpr uintmax_t __new_n0 = __n0 * __c1;
      static constexpr uintmax_t __n1_shifted = (__n1 % __d) * __c1;
      static constexpr uintmax_t __n0_top = (__shift != 0) ? (__n0 / __c2) : 0;
      static constexpr uintmax_t __new_n1 = __n1_shifted + __n0_top;
      typedef __big_div_impl<__new_n1, __new_n0, __new_d> _Res;

    public:
      static constexpr uintmax_t __quot_hi = __n1 / __d;
      static constexpr uintmax_t __quot_lo = _Res::__quot;
      static constexpr uintmax_t __rem = _Res::__rem / __c1;

    private:
      typedef __big_mul<__quot_lo, __d> _P0;
      typedef __big_mul<__quot_hi, __d> _P1;
      typedef __big_add<_P0::__hi, _P0::__lo, _P1::__lo, __rem> _Sum;

      static_assert(_P1::__hi == 0, "Internal library error");
      static_assert(_Sum::__hi >= _P0::__hi, "Internal library error");

      static_assert(_Sum::__hi == __n1 && _Sum::__lo == __n0,
      "Internal library error");
      static_assert(__rem < __d, "Internal library error");
    };
# 262 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ratio" 3
  template<intmax_t _Num, intmax_t _Den = 1>
    struct ratio
    {
      static_assert(_Den != 0, "denominator cannot be zero");
      static_assert(_Num >= -9223372036854775807LL && _Den >= -9223372036854775807LL,
      "out of range");


      static constexpr intmax_t num =
        _Num * __static_sign<_Den>::value / __static_gcd<_Num, _Den>::value;

      static constexpr intmax_t den =
        __static_abs<_Den>::value / __static_gcd<_Num, _Den>::value;

      typedef ratio<num, den> type;
    };

  template<intmax_t _Num, intmax_t _Den>
    constexpr intmax_t ratio<_Num, _Den>::num;

  template<intmax_t _Num, intmax_t _Den>
    constexpr intmax_t ratio<_Num, _Den>::den;

  template<typename _R1, typename _R2>
    struct __ratio_multiply
    {
    private:
      static const intmax_t __gcd1 =
        __static_gcd<_R1::num, _R2::den>::value;
      static const intmax_t __gcd2 =
        __static_gcd<_R2::num, _R1::den>::value;

    public:
      typedef ratio<
        __safe_multiply<(_R1::num / __gcd1),
                        (_R2::num / __gcd2)>::value,
        __safe_multiply<(_R1::den / __gcd2),
                        (_R2::den / __gcd1)>::value> type;

      static constexpr intmax_t num = type::num;
      static constexpr intmax_t den = type::den;
    };

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_multiply<_R1, _R2>::num;

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_multiply<_R1, _R2>::den;


  template<typename _R1, typename _R2>
    using ratio_multiply = typename __ratio_multiply<_R1, _R2>::type;

  template<typename _R1, typename _R2>
    struct __ratio_divide
    {
      static_assert(_R2::num != 0, "division by 0");

      typedef typename __ratio_multiply<
        _R1,
        ratio<_R2::den, _R2::num>>::type type;

      static constexpr intmax_t num = type::num;
      static constexpr intmax_t den = type::den;
    };

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_divide<_R1, _R2>::num;

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_divide<_R1, _R2>::den;


  template<typename _R1, typename _R2>
    using ratio_divide = typename __ratio_divide<_R1, _R2>::type;


  template<typename _R1, typename _R2>
    struct ratio_equal
    : integral_constant<bool, _R1::num == _R2::num && _R1::den == _R2::den>
    { };


  template<typename _R1, typename _R2>
    struct ratio_not_equal
    : integral_constant<bool, !ratio_equal<_R1, _R2>::value>
    { };


  template<typename _R1, typename _R2,
           typename _Left = __big_mul<_R1::num,_R2::den>,
           typename _Right = __big_mul<_R2::num,_R1::den> >
    struct __ratio_less_impl_1
    : integral_constant<bool, __big_less<_Left::__hi, _Left::__lo,
           _Right::__hi, _Right::__lo>::value>
    { };

  template<typename _R1, typename _R2,
    bool = (_R1::num == 0 || _R2::num == 0
     || (__static_sign<_R1::num>::value
         != __static_sign<_R2::num>::value)),
    bool = (__static_sign<_R1::num>::value == -1
     && __static_sign<_R2::num>::value == -1)>
    struct __ratio_less_impl
    : __ratio_less_impl_1<_R1, _R2>::type
    { };

  template<typename _R1, typename _R2>
    struct __ratio_less_impl<_R1, _R2, true, false>
    : integral_constant<bool, _R1::num < _R2::num>
    { };

  template<typename _R1, typename _R2>
    struct __ratio_less_impl<_R1, _R2, false, true>
    : __ratio_less_impl_1<ratio<-_R2::num, _R2::den>,
           ratio<-_R1::num, _R1::den> >::type
    { };


  template<typename _R1, typename _R2>
    struct ratio_less
    : __ratio_less_impl<_R1, _R2>::type
    { };


  template<typename _R1, typename _R2>
    struct ratio_less_equal
    : integral_constant<bool, !ratio_less<_R2, _R1>::value>
    { };


  template<typename _R1, typename _R2>
    struct ratio_greater
    : integral_constant<bool, ratio_less<_R2, _R1>::value>
    { };


  template<typename _R1, typename _R2>
    struct ratio_greater_equal
    : integral_constant<bool, !ratio_less<_R1, _R2>::value>
    { };

  template<typename _R1, typename _R2,
      bool = (_R1::num >= 0),
      bool = (_R2::num >= 0),
      bool = ratio_less<ratio<__static_abs<_R1::num>::value, _R1::den>,
        ratio<__static_abs<_R2::num>::value, _R2::den> >::value>
    struct __ratio_add_impl
    {
    private:
      typedef typename __ratio_add_impl<
        ratio<-_R1::num, _R1::den>,
        ratio<-_R2::num, _R2::den> >::type __t;
    public:
      typedef ratio<-__t::num, __t::den> type;
    };


  template<typename _R1, typename _R2, bool __b>
    struct __ratio_add_impl<_R1, _R2, true, true, __b>
    {
    private:
      static constexpr uintmax_t __g = __static_gcd<_R1::den, _R2::den>::value;
      static constexpr uintmax_t __d2 = _R2::den / __g;
      typedef __big_mul<_R1::den, __d2> __d;
      typedef __big_mul<_R1::num, _R2::den / __g> __x;
      typedef __big_mul<_R2::num, _R1::den / __g> __y;
      typedef __big_add<__x::__hi, __x::__lo, __y::__hi, __y::__lo> __n;
      static_assert(__n::__hi >= __x::__hi, "Internal library error");
      typedef __big_div<__n::__hi, __n::__lo, __g> __ng;
      static constexpr uintmax_t __g2 = __static_gcd<__ng::__rem, __g>::value;
      typedef __big_div<__n::__hi, __n::__lo, __g2> __n_final;
      static_assert(__n_final::__rem == 0, "Internal library error");
      static_assert(__n_final::__quot_hi == 0 &&
        __n_final::__quot_lo <= 9223372036854775807LL, "overflow in addition");
      typedef __big_mul<_R1::den / __g2, __d2> __d_final;
      static_assert(__d_final::__hi == 0 &&
        __d_final::__lo <= 9223372036854775807LL, "overflow in addition");
    public:
      typedef ratio<__n_final::__quot_lo, __d_final::__lo> type;
    };

  template<typename _R1, typename _R2>
    struct __ratio_add_impl<_R1, _R2, false, true, true>
    : __ratio_add_impl<_R2, _R1>
    { };


  template<typename _R1, typename _R2>
    struct __ratio_add_impl<_R1, _R2, true, false, false>
    {
    private:
      static constexpr uintmax_t __g = __static_gcd<_R1::den, _R2::den>::value;
      static constexpr uintmax_t __d2 = _R2::den / __g;
      typedef __big_mul<_R1::den, __d2> __d;
      typedef __big_mul<_R1::num, _R2::den / __g> __x;
      typedef __big_mul<-_R2::num, _R1::den / __g> __y;
      typedef __big_sub<__x::__hi, __x::__lo, __y::__hi, __y::__lo> __n;
      typedef __big_div<__n::__hi, __n::__lo, __g> __ng;
      static constexpr uintmax_t __g2 = __static_gcd<__ng::__rem, __g>::value;
      typedef __big_div<__n::__hi, __n::__lo, __g2> __n_final;
      static_assert(__n_final::__rem == 0, "Internal library error");
      static_assert(__n_final::__quot_hi == 0 &&
        __n_final::__quot_lo <= 9223372036854775807LL, "overflow in addition");
      typedef __big_mul<_R1::den / __g2, __d2> __d_final;
      static_assert(__d_final::__hi == 0 &&
        __d_final::__lo <= 9223372036854775807LL, "overflow in addition");
    public:
      typedef ratio<__n_final::__quot_lo, __d_final::__lo> type;
    };

  template<typename _R1, typename _R2>
    struct __ratio_add
    {
      typedef typename __ratio_add_impl<_R1, _R2>::type type;
      static constexpr intmax_t num = type::num;
      static constexpr intmax_t den = type::den;
    };

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_add<_R1, _R2>::num;

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_add<_R1, _R2>::den;


  template<typename _R1, typename _R2>
    using ratio_add = typename __ratio_add<_R1, _R2>::type;

  template<typename _R1, typename _R2>
    struct __ratio_subtract
    {
      typedef typename __ratio_add<
        _R1,
        ratio<-_R2::num, _R2::den>>::type type;

      static constexpr intmax_t num = type::num;
      static constexpr intmax_t den = type::den;
    };

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_subtract<_R1, _R2>::num;

  template<typename _R1, typename _R2>
    constexpr intmax_t __ratio_subtract<_R1, _R2>::den;


  template<typename _R1, typename _R2>
    using ratio_subtract = typename __ratio_subtract<_R1, _R2>::type;


  typedef ratio<1, 1000000000000000000> atto;
  typedef ratio<1, 1000000000000000> femto;
  typedef ratio<1, 1000000000000> pico;
  typedef ratio<1, 1000000000> nano;
  typedef ratio<1, 1000000> micro;
  typedef ratio<1, 1000> milli;
  typedef ratio<1, 100> centi;
  typedef ratio<1, 10> deci;
  typedef ratio< 10, 1> deca;
  typedef ratio< 100, 1> hecto;
  typedef ratio< 1000, 1> kilo;
  typedef ratio< 1000000, 1> mega;
  typedef ratio< 1000000000, 1> giga;
  typedef ratio< 1000000000000, 1> tera;
  typedef ratio< 1000000000000000, 1> peta;
  typedef ratio< 1000000000000000000, 1> exa;



}
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/chrono" 2 3


# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ctime" 1 3
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ctime" 3
       
# 40 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ctime" 3
# 58 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ctime" 3
namespace std
{
  using ::clock_t;
  using ::time_t;
  using ::tm;

  using ::clock;
  using ::difftime;
  using ::mktime;
  using ::time;
  using ::asctime;
  using ::ctime;
  using ::gmtime;
  using ::localtime;
  using ::strftime;
}
# 42 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/chrono" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/parse_numbers.h" 1 3
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/parse_numbers.h" 3
       
# 34 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/parse_numbers.h" 3
# 43 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/chrono" 2 3



namespace std __attribute__ ((__visibility__ ("default")))
{
# 59 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/chrono" 3
  namespace chrono
  {
 

    template<typename _Rep, typename _Period = ratio<1>>
      struct duration;

    template<typename _Clock, typename _Dur = typename _Clock::duration>
      struct time_point;

 
  }





  template<typename _CT, typename _Period1, typename _Period2>
    struct __duration_common_type_wrapper
    {
    private:
      typedef __static_gcd<_Period1::num, _Period2::num> __gcd_num;
      typedef __static_gcd<_Period1::den, _Period2::den> __gcd_den;
      typedef typename _CT::type __cr;
      typedef ratio<__gcd_num::value,
        (_Period1::den / __gcd_den::value) * _Period2::den> __r;
    public:
      typedef __success_type<chrono::duration<__cr, __r>> type;
    };

  template<typename _Period1, typename _Period2>
    struct __duration_common_type_wrapper<__failure_type, _Period1, _Period2>
    { typedef __failure_type type; };

  template<typename _Rep1, typename _Period1, typename _Rep2, typename _Period2>
    struct common_type<chrono::duration<_Rep1, _Period1>,
             chrono::duration<_Rep2, _Period2>>
    : public __duration_common_type_wrapper<typename __member_type_wrapper<
             common_type<_Rep1, _Rep2>>::type, _Period1, _Period2>::type
    { };



  template<typename _CT, typename _Clock>
    struct __timepoint_common_type_wrapper
    {
      typedef __success_type<chrono::time_point<_Clock, typename _CT::type>>
        type;
    };

  template<typename _Clock>
    struct __timepoint_common_type_wrapper<__failure_type, _Clock>
    { typedef __failure_type type; };

  template<typename _Clock, typename _Duration1, typename _Duration2>
    struct common_type<chrono::time_point<_Clock, _Duration1>,
             chrono::time_point<_Clock, _Duration2>>
    : public __timepoint_common_type_wrapper<typename __member_type_wrapper<
             common_type<_Duration1, _Duration2>>::type, _Clock>::type
    { };



  namespace chrono
  {
 


    template<typename _ToDur, typename _CF, typename _CR,
      bool _NumIsOne = false, bool _DenIsOne = false>
      struct __duration_cast_impl
      {
 template<typename _Rep, typename _Period>
   static constexpr _ToDur
   __cast(const duration<_Rep, _Period>& __d)
   {
     typedef typename _ToDur::rep __to_rep;
     return _ToDur(static_cast<__to_rep>(static_cast<_CR>(__d.count())
       * static_cast<_CR>(_CF::num)
       / static_cast<_CR>(_CF::den)));
   }
      };

    template<typename _ToDur, typename _CF, typename _CR>
      struct __duration_cast_impl<_ToDur, _CF, _CR, true, true>
      {
 template<typename _Rep, typename _Period>
   static constexpr _ToDur
   __cast(const duration<_Rep, _Period>& __d)
   {
     typedef typename _ToDur::rep __to_rep;
     return _ToDur(static_cast<__to_rep>(__d.count()));
   }
      };

    template<typename _ToDur, typename _CF, typename _CR>
      struct __duration_cast_impl<_ToDur, _CF, _CR, true, false>
      {
 template<typename _Rep, typename _Period>
   static constexpr _ToDur
   __cast(const duration<_Rep, _Period>& __d)
   {
     typedef typename _ToDur::rep __to_rep;
     return _ToDur(static_cast<__to_rep>(
       static_cast<_CR>(__d.count()) / static_cast<_CR>(_CF::den)));
   }
      };

    template<typename _ToDur, typename _CF, typename _CR>
      struct __duration_cast_impl<_ToDur, _CF, _CR, false, true>
      {
 template<typename _Rep, typename _Period>
   static constexpr _ToDur
   __cast(const duration<_Rep, _Period>& __d)
   {
     typedef typename _ToDur::rep __to_rep;
     return _ToDur(static_cast<__to_rep>(
       static_cast<_CR>(__d.count()) * static_cast<_CR>(_CF::num)));
   }
      };

    template<typename _Tp>
      struct __is_duration
      : std::false_type
      { };

    template<typename _Rep, typename _Period>
      struct __is_duration<duration<_Rep, _Period>>
      : std::true_type
      { };


    template<typename _ToDur, typename _Rep, typename _Period>
      constexpr typename enable_if<__is_duration<_ToDur>::value,
       _ToDur>::type
      duration_cast(const duration<_Rep, _Period>& __d)
      {
 typedef typename _ToDur::period __to_period;
 typedef typename _ToDur::rep __to_rep;
 typedef ratio_divide<_Period, __to_period> __cf;
 typedef typename common_type<__to_rep, _Rep, intmax_t>::type
          __cr;
 typedef __duration_cast_impl<_ToDur, __cf, __cr,
          __cf::num == 1, __cf::den == 1> __dc;
 return __dc::__cast(__d);
      }


    template<typename _Rep>
      struct treat_as_floating_point
      : is_floating_point<_Rep>
      { };


    template<typename _Rep>
      struct duration_values
      {
 static constexpr _Rep
 zero()
 { return _Rep(0); }

 static constexpr _Rep
 max()
 { return numeric_limits<_Rep>::max(); }

 static constexpr _Rep
 min()
 { return numeric_limits<_Rep>::lowest(); }
      };

    template<typename _Tp>
      struct __is_ratio
      : std::false_type
      { };

    template<intmax_t _Num, intmax_t _Den>
      struct __is_ratio<ratio<_Num, _Den>>
      : std::true_type
      { };


    template<typename _Rep, typename _Period>
      struct duration
      {
 typedef _Rep rep;
 typedef _Period period;

 static_assert(!__is_duration<_Rep>::value, "rep cannot be a duration");
 static_assert(__is_ratio<_Period>::value,
        "period must be a specialization of ratio");
 static_assert(_Period::num > 0, "period must be positive");


 constexpr duration() = default;




 duration(const duration&) = default;

 template<typename _Rep2, typename = typename
        enable_if<is_convertible<_Rep2, rep>::value
    && (treat_as_floating_point<rep>::value
        || !treat_as_floating_point<_Rep2>::value)>::type>
   constexpr explicit duration(const _Rep2& __rep)
   : __r(static_cast<rep>(__rep)) { }

 template<typename _Rep2, typename _Period2, typename = typename
        enable_if<treat_as_floating_point<rep>::value
    || (ratio_divide<_Period2, period>::den == 1
        && !treat_as_floating_point<_Rep2>::value)>::type>
   constexpr duration(const duration<_Rep2, _Period2>& __d)
   : __r(duration_cast<duration>(__d).count()) { }

 ~duration() = default;
 duration& operator=(const duration&) = default;


 constexpr rep
 count() const
 { return __r; }


 constexpr duration
 operator+() const
 { return *this; }

 constexpr duration
 operator-() const
 { return duration(-__r); }

 duration&
 operator++()
 {
   ++__r;
   return *this;
 }

 duration
 operator++(int)
 { return duration(__r++); }

 duration&
 operator--()
 {
   --__r;
   return *this;
 }

 duration
 operator--(int)
 { return duration(__r--); }

 duration&
 operator+=(const duration& __d)
 {
   __r += __d.count();
   return *this;
 }

 duration&
 operator-=(const duration& __d)
 {
   __r -= __d.count();
   return *this;
 }

 duration&
 operator*=(const rep& __rhs)
 {
   __r *= __rhs;
   return *this;
 }

 duration&
 operator/=(const rep& __rhs)
 {
   __r /= __rhs;
   return *this;
 }


 template<typename _Rep2 = rep>
   typename enable_if<!treat_as_floating_point<_Rep2>::value,
        duration&>::type
   operator%=(const rep& __rhs)
   {
     __r %= __rhs;
     return *this;
   }

 template<typename _Rep2 = rep>
   typename enable_if<!treat_as_floating_point<_Rep2>::value,
        duration&>::type
   operator%=(const duration& __d)
   {
     __r %= __d.count();
     return *this;
   }


 static constexpr duration
 zero()
 { return duration(duration_values<rep>::zero()); }

 static constexpr duration
 min()
 { return duration(duration_values<rep>::min()); }

 static constexpr duration
 max()
 { return duration(duration_values<rep>::max()); }

      private:
 rep __r;
      };

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr typename common_type<duration<_Rep1, _Period1>,
         duration<_Rep2, _Period2>>::type
      operator+(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __cd;
 return __cd(__cd(__lhs).count() + __cd(__rhs).count());
      }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr typename common_type<duration<_Rep1, _Period1>,
         duration<_Rep2, _Period2>>::type
      operator-(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __cd;
 return __cd(__cd(__lhs).count() - __cd(__rhs).count());
      }

    template<typename _Rep1, typename _Rep2, bool =
      is_convertible<_Rep2,
       typename common_type<_Rep1, _Rep2>::type>::value>
      struct __common_rep_type { };

    template<typename _Rep1, typename _Rep2>
      struct __common_rep_type<_Rep1, _Rep2, true>
      { typedef typename common_type<_Rep1, _Rep2>::type type; };

    template<typename _Rep1, typename _Period, typename _Rep2>
      constexpr
      duration<typename __common_rep_type<_Rep1, _Rep2>::type, _Period>
      operator*(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
      {
 typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
   __cd;
 return __cd(__cd(__d).count() * __s);
      }

    template<typename _Rep1, typename _Rep2, typename _Period>
      constexpr
      duration<typename __common_rep_type<_Rep2, _Rep1>::type, _Period>
      operator*(const _Rep1& __s, const duration<_Rep2, _Period>& __d)
      { return __d * __s; }

    template<typename _Rep1, typename _Period, typename _Rep2>
      constexpr duration<typename __common_rep_type<_Rep1, typename
 enable_if<!__is_duration<_Rep2>::value, _Rep2>::type>::type, _Period>
      operator/(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
      {
 typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
   __cd;
 return __cd(__cd(__d).count() / __s);
      }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr typename common_type<_Rep1, _Rep2>::type
      operator/(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __cd;
 return __cd(__lhs).count() / __cd(__rhs).count();
      }


    template<typename _Rep1, typename _Period, typename _Rep2>
      constexpr duration<typename __common_rep_type<_Rep1, typename
 enable_if<!__is_duration<_Rep2>::value, _Rep2>::type>::type, _Period>
      operator%(const duration<_Rep1, _Period>& __d, const _Rep2& __s)
      {
 typedef duration<typename common_type<_Rep1, _Rep2>::type, _Period>
   __cd;
 return __cd(__cd(__d).count() % __s);
      }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr typename common_type<duration<_Rep1, _Period1>,
         duration<_Rep2, _Period2>>::type
      operator%(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __cd;
 return __cd(__cd(__lhs).count() % __cd(__rhs).count());
      }


    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator==(const duration<_Rep1, _Period1>& __lhs,
   const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __ct;
 return __ct(__lhs).count() == __ct(__rhs).count();
      }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator<(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<__dur1,__dur2>::type __ct;
 return __ct(__lhs).count() < __ct(__rhs).count();
      }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator!=(const duration<_Rep1, _Period1>& __lhs,
   const duration<_Rep2, _Period2>& __rhs)
      { return !(__lhs == __rhs); }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator<=(const duration<_Rep1, _Period1>& __lhs,
   const duration<_Rep2, _Period2>& __rhs)
      { return !(__rhs < __lhs); }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator>(const duration<_Rep1, _Period1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      { return __rhs < __lhs; }

    template<typename _Rep1, typename _Period1,
      typename _Rep2, typename _Period2>
      constexpr bool
      operator>=(const duration<_Rep1, _Period1>& __lhs,
   const duration<_Rep2, _Period2>& __rhs)
      { return !(__lhs < __rhs); }


    typedef duration<int64_t, nano> nanoseconds;


    typedef duration<int64_t, micro> microseconds;


    typedef duration<int64_t, milli> milliseconds;


    typedef duration<int64_t> seconds;


    typedef duration<int64_t, ratio< 60>> minutes;


    typedef duration<int64_t, ratio<3600>> hours;


    template<typename _Clock, typename _Dur>
      struct time_point
      {
 typedef _Clock clock;
 typedef _Dur duration;
 typedef typename duration::rep rep;
 typedef typename duration::period period;

 constexpr time_point() : __d(duration::zero())
 { }

 constexpr explicit time_point(const duration& __dur)
 : __d(__dur)
 { }


 template<typename _Dur2>
   constexpr time_point(const time_point<clock, _Dur2>& __t)
   : __d(__t.time_since_epoch())
   { }


 constexpr duration
 time_since_epoch() const
 { return __d; }


 time_point&
 operator+=(const duration& __dur)
 {
   __d += __dur;
   return *this;
 }

 time_point&
 operator-=(const duration& __dur)
 {
   __d -= __dur;
   return *this;
 }


 static constexpr time_point
 min()
 { return time_point(duration::min()); }

 static constexpr time_point
 max()
 { return time_point(duration::max()); }

      private:
 duration __d;
      };


    template<typename _ToDur, typename _Clock, typename _Dur>
      constexpr typename enable_if<__is_duration<_ToDur>::value,
       time_point<_Clock, _ToDur>>::type
      time_point_cast(const time_point<_Clock, _Dur>& __t)
      {
 typedef time_point<_Clock, _ToDur> __time_point;
 return __time_point(duration_cast<_ToDur>(__t.time_since_epoch()));
      }

    template<typename _Clock, typename _Dur1,
      typename _Rep2, typename _Period2>
      constexpr time_point<_Clock,
 typename common_type<_Dur1, duration<_Rep2, _Period2>>::type>
      operator+(const time_point<_Clock, _Dur1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<_Dur1,__dur2>::type __ct;
 typedef time_point<_Clock, __ct> __time_point;
 return __time_point(__lhs.time_since_epoch() + __rhs);
      }

    template<typename _Rep1, typename _Period1,
      typename _Clock, typename _Dur2>
      constexpr time_point<_Clock,
 typename common_type<duration<_Rep1, _Period1>, _Dur2>::type>
      operator+(const duration<_Rep1, _Period1>& __lhs,
  const time_point<_Clock, _Dur2>& __rhs)
      {
 typedef duration<_Rep1, _Period1> __dur1;
 typedef typename common_type<__dur1,_Dur2>::type __ct;
 typedef time_point<_Clock, __ct> __time_point;
 return __time_point(__rhs.time_since_epoch() + __lhs);
      }

    template<typename _Clock, typename _Dur1,
      typename _Rep2, typename _Period2>
      constexpr time_point<_Clock,
 typename common_type<_Dur1, duration<_Rep2, _Period2>>::type>
      operator-(const time_point<_Clock, _Dur1>& __lhs,
  const duration<_Rep2, _Period2>& __rhs)
      {
 typedef duration<_Rep2, _Period2> __dur2;
 typedef typename common_type<_Dur1,__dur2>::type __ct;
 typedef time_point<_Clock, __ct> __time_point;
 return __time_point(__lhs.time_since_epoch() -__rhs);
      }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr typename common_type<_Dur1, _Dur2>::type
      operator-(const time_point<_Clock, _Dur1>& __lhs,
  const time_point<_Clock, _Dur2>& __rhs)
      { return __lhs.time_since_epoch() - __rhs.time_since_epoch(); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator==(const time_point<_Clock, _Dur1>& __lhs,
   const time_point<_Clock, _Dur2>& __rhs)
      { return __lhs.time_since_epoch() == __rhs.time_since_epoch(); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator!=(const time_point<_Clock, _Dur1>& __lhs,
   const time_point<_Clock, _Dur2>& __rhs)
      { return !(__lhs == __rhs); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator<(const time_point<_Clock, _Dur1>& __lhs,
  const time_point<_Clock, _Dur2>& __rhs)
      { return __lhs.time_since_epoch() < __rhs.time_since_epoch(); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator<=(const time_point<_Clock, _Dur1>& __lhs,
   const time_point<_Clock, _Dur2>& __rhs)
      { return !(__rhs < __lhs); }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator>(const time_point<_Clock, _Dur1>& __lhs,
  const time_point<_Clock, _Dur2>& __rhs)
      { return __rhs < __lhs; }

    template<typename _Clock, typename _Dur1, typename _Dur2>
      constexpr bool
      operator>=(const time_point<_Clock, _Dur1>& __lhs,
   const time_point<_Clock, _Dur2>& __rhs)
      { return !(__lhs < __rhs); }
# 709 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/chrono" 3
    inline namespace _V2 {






    struct system_clock
    {
      typedef chrono::nanoseconds duration;
      typedef duration::rep rep;
      typedef duration::period period;
      typedef chrono::time_point<system_clock, duration> time_point;

      static_assert(system_clock::duration::min()
      < system_clock::duration::zero(),
      "a clock's minimum duration cannot be less than its epoch");

      static constexpr bool is_steady = false;

      static time_point
      now() noexcept;


      static std::time_t
      to_time_t(const time_point& __t) noexcept
      {
 return std::time_t(duration_cast<chrono::seconds>
      (__t.time_since_epoch()).count());
      }

      static time_point
      from_time_t(std::time_t __t) noexcept
      {
 typedef chrono::time_point<system_clock, seconds> __from;
 return time_point_cast<system_clock::duration>
        (__from(chrono::seconds(__t)));
      }
    };







    struct steady_clock
    {
      typedef chrono::nanoseconds duration;
      typedef duration::rep rep;
      typedef duration::period period;
      typedef chrono::time_point<steady_clock, duration> time_point;

      static constexpr bool is_steady = true;

      static time_point
      now() noexcept;
    };
# 776 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/chrono" 3
    using high_resolution_clock = system_clock;

    }

 
  }
# 908 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/chrono" 3
}
# 13 "../Quadris/Engine.h" 2
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/thread" 1
# 32 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/thread"
       
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/thread" 3







# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/memory" 1 3
# 46 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/memory" 3
       
# 47 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/memory" 3
# 64 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/memory" 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_construct.h" 1 3
# 63 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_construct.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{







  template<typename _T1, typename... _Args>
    inline void
    _Construct(_T1* __p, _Args&&... __args)
    { ::new(static_cast<void*>(__p)) _T1(std::forward<_Args>(__args)...); }
# 90 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_construct.h" 3
  template<typename _Tp>
    inline void
    _Destroy(_Tp* __pointer)
    { __pointer->~_Tp(); }

  template<bool>
    struct _Destroy_aux
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator __first, _ForwardIterator __last)
 {
   for (; __first != __last; ++__first)
     std::_Destroy(std::__addressof(*__first));
 }
    };

  template<>
    struct _Destroy_aux<true>
    {
      template<typename _ForwardIterator>
        static void
        __destroy(_ForwardIterator, _ForwardIterator) { }
    };






  template<typename _ForwardIterator>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
                       _Value_type;
      std::_Destroy_aux<__has_trivial_destructor(_Value_type)>::
 __destroy(__first, __last);
    }







  template<typename _ForwardIterator, typename _Allocator>
    void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      _Allocator& __alloc)
    {
      typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
      for (; __first != __last; ++__first)
 __traits::destroy(__alloc, std::__addressof(*__first));
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    _Destroy(_ForwardIterator __first, _ForwardIterator __last,
      allocator<_Tp>&)
    {
      _Destroy(__first, __last);
    }


}
# 65 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/memory" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_uninitialized.h" 1 3
# 59 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_uninitialized.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{


  template<bool _TrivialValueTypes>
    struct __uninitialized_copy
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        {
   _ForwardIterator __cur = __result;
   try
     {
       for (; __first != __last; ++__first, ++__cur)
  std::_Construct(std::__addressof(*__cur), *__first);
       return __cur;
     }
   catch(...)
     {
       std::_Destroy(__result, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_copy<true>
    {
      template<typename _InputIterator, typename _ForwardIterator>
        static _ForwardIterator
        __uninit_copy(_InputIterator __first, _InputIterator __last,
        _ForwardIterator __result)
        { return std::copy(__first, __last, __result); }
    };
# 105 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy(_InputIterator __first, _InputIterator __last,
         _ForwardIterator __result)
    {
      typedef typename iterator_traits<_InputIterator>::value_type
 _ValueType1;
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType2;




      typedef typename iterator_traits<_InputIterator>::reference _RefType;
      const bool __assignable = is_assignable<_ValueType1, _RefType>::value;


      return std::__uninitialized_copy<__is_trivial(_ValueType1)
           && __is_trivial(_ValueType2)
           && __assignable>::
 __uninit_copy(__first, __last, __result);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill<true>
    {
      template<typename _ForwardIterator, typename _Tp>
        static void
        __uninit_fill(_ForwardIterator __first, _ForwardIterator __last,
        const _Tp& __x)
        { std::fill(__first, __last, __x); }
    };
# 170 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Tp>
    inline void
    uninitialized_fill(_ForwardIterator __first, _ForwardIterator __last,
         const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill(__first, __last, __x);
    }


  template<bool _TrivialValueType>
    struct __uninitialized_fill_n
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur), __x);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_fill_n<true>
    {
      template<typename _ForwardIterator, typename _Size, typename _Tp>
        static void
        __uninit_fill_n(_ForwardIterator __first, _Size __n,
   const _Tp& __x)
        { std::fill_n(__first, __n, __x); }
    };
# 230 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_uninitialized.h" 3
  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    uninitialized_fill_n(_ForwardIterator __first, _Size __n, const _Tp& __x)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;




      const bool __assignable = is_copy_assignable<_ValueType>::value;


      std::__uninitialized_fill_n<__is_trivial(_ValueType) && __assignable>::
 __uninit_fill_n(__first, __n, __x);
    }







  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __result;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __first != __last; ++__first, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur, __alloc);
   throw;
 }
    }

  template<typename _InputIterator, typename _ForwardIterator, typename _Tp>
    inline _ForwardIterator
    __uninitialized_copy_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, allocator<_Tp>&)
    { return std::uninitialized_copy(__first, __last, __result); }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_a(_InputIterator __first, _InputIterator __last,
      _ForwardIterator __result, _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a(std::make_move_iterator(__first),
      std::make_move_iterator(__last),
      __result, __alloc);
    }

  template<typename _InputIterator, typename _ForwardIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_if_noexcept_a(_InputIterator __first,
           _InputIterator __last,
           _ForwardIterator __result,
           _Allocator& __alloc)
    {
      return std::__uninitialized_copy_a
 (std::__make_move_if_noexcept_iterator(__first),
  std::__make_move_if_noexcept_iterator(__last), __result, __alloc);
    }

  template<typename _ForwardIterator, typename _Tp, typename _Allocator>
    void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp, typename _Tp2>
    inline void
    __uninitialized_fill_a(_ForwardIterator __first, _ForwardIterator __last,
      const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill(__first, __last, __x); }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Allocator>
    void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur), __x);
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp,
    typename _Tp2>
    inline void
    __uninitialized_fill_n_a(_ForwardIterator __first, _Size __n,
        const _Tp& __x, allocator<_Tp2>&)
    { std::uninitialized_fill_n(__first, __n, __x); }
# 366 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_uninitialized.h" 3
  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_copy_move(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_copy_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_move_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }





  template<typename _InputIterator1, typename _InputIterator2,
    typename _ForwardIterator, typename _Allocator>
    inline _ForwardIterator
    __uninitialized_move_copy(_InputIterator1 __first1,
         _InputIterator1 __last1,
         _InputIterator2 __first2,
         _InputIterator2 __last2,
         _ForwardIterator __result,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid = std::__uninitialized_move_a(__first1, __last1,
          __result,
          __alloc);
      try
 {
   return std::__uninitialized_copy_a(__first2, __last2, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _ForwardIterator, typename _Tp, typename _InputIterator,
    typename _Allocator>
    inline _ForwardIterator
    __uninitialized_fill_move(_ForwardIterator __result, _ForwardIterator __mid,
         const _Tp& __x, _InputIterator __first,
         _InputIterator __last, _Allocator& __alloc)
    {
      std::__uninitialized_fill_a(__result, __mid, __x, __alloc);
      try
 {
   return std::__uninitialized_move_a(__first, __last, __mid, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__result, __mid, __alloc);
   throw;
 }
    }




  template<typename _InputIterator, typename _ForwardIterator, typename _Tp,
    typename _Allocator>
    inline void
    __uninitialized_move_fill(_InputIterator __first1, _InputIterator __last1,
         _ForwardIterator __first2,
         _ForwardIterator __last2, const _Tp& __x,
         _Allocator& __alloc)
    {
      _ForwardIterator __mid2 = std::__uninitialized_move_a(__first1, __last1,
           __first2,
           __alloc);
      try
 {
   std::__uninitialized_fill_a(__mid2, __last2, __x, __alloc);
 }
      catch(...)
 {
   std::_Destroy(__first2, __mid2, __alloc);
   throw;
 }
    }





  template<bool _TrivialValueType>
    struct __uninitialized_default_1
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __cur != __last; ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_1<true>
    {
      template<typename _ForwardIterator>
        static void
        __uninit_default(_ForwardIterator __first, _ForwardIterator __last)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill(__first, __last, _ValueType());
 }
    };

  template<bool _TrivialValueType>
    struct __uninitialized_default_n_1
    {
      template<typename _ForwardIterator, typename _Size>
        static void
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   _ForwardIterator __cur = __first;
   try
     {
       for (; __n > 0; --__n, ++__cur)
  std::_Construct(std::__addressof(*__cur));
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_default_n_1<true>
    {
      template<typename _ForwardIterator, typename _Size>
        static void
        __uninit_default_n(_ForwardIterator __first, _Size __n)
        {
   typedef typename iterator_traits<_ForwardIterator>::value_type
     _ValueType;

   std::fill_n(__first, __n, _ValueType());
 }
    };




  template<typename _ForwardIterator>
    inline void
    __uninitialized_default(_ForwardIterator __first,
       _ForwardIterator __last)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_1<__is_trivial(_ValueType)
         && __assignable>::
 __uninit_default(__first, __last);
    }



  template<typename _ForwardIterator, typename _Size>
    inline void
    __uninitialized_default_n(_ForwardIterator __first, _Size __n)
    {
      typedef typename iterator_traits<_ForwardIterator>::value_type
 _ValueType;

      const bool __assignable = is_copy_assignable<_ValueType>::value;

      std::__uninitialized_default_n_1<__is_trivial(_ValueType)
           && __assignable>::
 __uninit_default_n(__first, __n);
    }





  template<typename _ForwardIterator, typename _Allocator>
    void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __cur != __last; ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Tp>
    inline void
    __uninitialized_default_a(_ForwardIterator __first,
         _ForwardIterator __last,
         allocator<_Tp>&)
    { std::__uninitialized_default(__first, __last); }





  template<typename _ForwardIterator, typename _Size, typename _Allocator>
    void
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    _Allocator& __alloc)
    {
      _ForwardIterator __cur = __first;
      try
 {
   typedef __gnu_cxx::__alloc_traits<_Allocator> __traits;
   for (; __n > 0; --__n, ++__cur)
     __traits::construct(__alloc, std::__addressof(*__cur));
 }
      catch(...)
 {
   std::_Destroy(__first, __cur, __alloc);
   throw;
 }
    }

  template<typename _ForwardIterator, typename _Size, typename _Tp>
    inline void
    __uninitialized_default_n_a(_ForwardIterator __first, _Size __n,
    allocator<_Tp>&)
    { std::__uninitialized_default_n(__first, __n); }


  template<typename _InputIterator, typename _Size,
    typename _ForwardIterator>
    _ForwardIterator
    __uninitialized_copy_n(_InputIterator __first, _Size __n,
      _ForwardIterator __result, input_iterator_tag)
    {
      _ForwardIterator __cur = __result;
      try
 {
   for (; __n > 0; --__n, ++__first, ++__cur)
     std::_Construct(std::__addressof(*__cur), *__first);
   return __cur;
 }
      catch(...)
 {
   std::_Destroy(__result, __cur);
   throw;
 }
    }

  template<typename _RandomAccessIterator, typename _Size,
    typename _ForwardIterator>
    inline _ForwardIterator
    __uninitialized_copy_n(_RandomAccessIterator __first, _Size __n,
      _ForwardIterator __result,
      random_access_iterator_tag)
    { return std::uninitialized_copy(__first, __first + __n, __result); }
# 671 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_uninitialized.h" 3
  template<typename _InputIterator, typename _Size, typename _ForwardIterator>
    inline _ForwardIterator
    uninitialized_copy_n(_InputIterator __first, _Size __n,
    _ForwardIterator __result)
    { return std::__uninitialized_copy_n(__first, __n, __result,
      std::__iterator_category(__first)); }



}
# 66 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/memory" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_tempbuf.h" 1 3
# 62 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_tempbuf.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 83 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    pair<_Tp*, ptrdiff_t>
    get_temporary_buffer(ptrdiff_t __len) noexcept
    {
      const ptrdiff_t __max =
 __gnu_cxx::__numeric_traits<ptrdiff_t>::__max / sizeof(_Tp);
      if (__len > __max)
 __len = __max;

      while (__len > 0)
 {
   _Tp* __tmp = static_cast<_Tp*>(::operator new(__len * sizeof(_Tp),
       std::nothrow));
   if (__tmp != 0)
     return std::pair<_Tp*, ptrdiff_t>(__tmp, __len);
   __len /= 2;
 }
      return std::pair<_Tp*, ptrdiff_t>(static_cast<_Tp*>(0), 0);
    }
# 110 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_tempbuf.h" 3
  template<typename _Tp>
    inline void
    return_temporary_buffer(_Tp* __p)
    { ::operator delete(__p, std::nothrow); }







  template<typename _ForwardIterator, typename _Tp>
    class _Temporary_buffer
    {

     

    public:
      typedef _Tp value_type;
      typedef value_type* pointer;
      typedef pointer iterator;
      typedef ptrdiff_t size_type;

    protected:
      size_type _M_original_len;
      size_type _M_len;
      pointer _M_buffer;

    public:

      size_type
      size() const
      { return _M_len; }


      size_type
      requested_size() const
      { return _M_original_len; }


      iterator
      begin()
      { return _M_buffer; }


      iterator
      end()
      { return _M_buffer + _M_len; }





      _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last);

      ~_Temporary_buffer()
      {
 std::_Destroy(_M_buffer, _M_buffer + _M_len);
 std::return_temporary_buffer(_M_buffer);
      }

    private:

      _Temporary_buffer(const _Temporary_buffer&);

      void
      operator=(const _Temporary_buffer&);
    };


  template<bool>
    struct __uninitialized_construct_buf_dispatch
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer __first, _Pointer __last,
       _ForwardIterator __seed)
        {
   if(__first == __last)
     return;

   _Pointer __cur = __first;
   try
     {
       std::_Construct(std::__addressof(*__first),
         std::move(*__seed));
       _Pointer __prev = __cur;
       ++__cur;
       for(; __cur != __last; ++__cur, ++__prev)
  std::_Construct(std::__addressof(*__cur),
    std::move(*__prev));
       *__seed = std::move(*__prev);
     }
   catch(...)
     {
       std::_Destroy(__first, __cur);
       throw;
     }
 }
    };

  template<>
    struct __uninitialized_construct_buf_dispatch<true>
    {
      template<typename _Pointer, typename _ForwardIterator>
        static void
        __ucr(_Pointer, _Pointer, _ForwardIterator) { }
    };
# 229 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_tempbuf.h" 3
  template<typename _Pointer, typename _ForwardIterator>
    inline void
    __uninitialized_construct_buf(_Pointer __first, _Pointer __last,
      _ForwardIterator __seed)
    {
      typedef typename std::iterator_traits<_Pointer>::value_type
 _ValueType;

      std::__uninitialized_construct_buf_dispatch<
        __has_trivial_constructor(_ValueType)>::
   __ucr(__first, __last, __seed);
    }

  template<typename _ForwardIterator, typename _Tp>
    _Temporary_buffer<_ForwardIterator, _Tp>::
    _Temporary_buffer(_ForwardIterator __first, _ForwardIterator __last)
    : _M_original_len(std::distance(__first, __last)),
      _M_len(0), _M_buffer(0)
    {
      try
 {
   std::pair<pointer, size_type> __p(std::get_temporary_buffer<
         value_type>(_M_original_len));
   _M_buffer = __p.first;
   _M_len = __p.second;
   if (_M_buffer)
     std::__uninitialized_construct_buf(_M_buffer, _M_buffer + _M_len,
            __first);
 }
      catch(...)
 {
   std::return_temporary_buffer(_M_buffer);
   _M_buffer = 0;
   _M_len = 0;
   throw;
 }
    }


}
# 67 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/memory" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_raw_storage_iter.h" 1 3
# 59 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/stl_raw_storage_iter.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{






  template <class _OutputIterator, class _Tp>
    class raw_storage_iterator
    : public iterator<output_iterator_tag, void, void, void, void>
    {
    protected:
      _OutputIterator _M_iter;

    public:
      explicit
      raw_storage_iterator(_OutputIterator __x)
      : _M_iter(__x) {}

      raw_storage_iterator&
      operator*() { return *this; }

      raw_storage_iterator&
      operator=(const _Tp& __element)
      {
 std::_Construct(std::__addressof(*_M_iter), __element);
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>&
      operator++()
      {
 ++_M_iter;
 return *this;
      }

      raw_storage_iterator<_OutputIterator, _Tp>
      operator++(int)
      {
 raw_storage_iterator<_OutputIterator, _Tp> __tmp = *this;
 ++_M_iter;
 return __tmp;
      }
    };


}
# 68 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/memory" 2 3






# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/concurrence.h" 1 3
# 32 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/concurrence.h" 3
       
# 33 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/concurrence.h" 3







namespace __gnu_cxx __attribute__ ((__visibility__ ("default")))
{







  enum _Lock_policy { _S_single, _S_mutex, _S_atomic };



  static const _Lock_policy __default_lock_policy =



  _S_atomic;
# 67 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/concurrence.h" 3
  class __concurrence_lock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_lock_error"; }
  };

  class __concurrence_unlock_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_unlock_error"; }
  };

  class __concurrence_broadcast_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_broadcast_error"; }
  };

  class __concurrence_wait_error : public std::exception
  {
  public:
    virtual char const*
    what() const throw()
    { return "__gnu_cxx::__concurrence_wait_error"; }
  };


  inline void
  __throw_concurrence_lock_error()
  { (throw (__concurrence_lock_error())); }

  inline void
  __throw_concurrence_unlock_error()
  { (throw (__concurrence_unlock_error())); }


  inline void
  __throw_concurrence_broadcast_error()
  { (throw (__concurrence_broadcast_error())); }

  inline void
  __throw_concurrence_wait_error()
  { (throw (__concurrence_wait_error())); }


  class __mutex
  {
  private:

    __gthread_mutex_t _M_mutex = {0};




    __mutex(const __mutex&);
    __mutex& operator=(const __mutex&);

  public:
    __mutex()
    {




    }
# 147 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/concurrence.h" 3
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_mutex_t* gthread_mutex(void)
      { return &_M_mutex; }
  };

  class __recursive_mutex
  {
  private:

    __gthread_recursive_mutex_t _M_mutex = {0x4000};




    __recursive_mutex(const __recursive_mutex&);
    __recursive_mutex& operator=(const __recursive_mutex&);

  public:
    __recursive_mutex()
    {




    }
# 202 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/concurrence.h" 3
    void lock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_lock(&_M_mutex) != 0)
     __throw_concurrence_lock_error();
 }

    }

    void unlock()
    {

      if (__gthread_active_p())
 {
   if (__gthread_recursive_mutex_unlock(&_M_mutex) != 0)
     __throw_concurrence_unlock_error();
 }

    }

    __gthread_recursive_mutex_t* gthread_recursive_mutex(void)
    { return &_M_mutex; }
  };




  class __scoped_lock
  {
  public:
    typedef __mutex __mutex_type;

  private:
    __mutex_type& _M_device;

    __scoped_lock(const __scoped_lock&);
    __scoped_lock& operator=(const __scoped_lock&);

  public:
    explicit __scoped_lock(__mutex_type& __name) : _M_device(__name)
    { _M_device.lock(); }

    ~__scoped_lock() throw()
    { _M_device.unlock(); }
  };


  class __cond
  {
  private:

    __gthread_cond_t _M_cond = {0};




    __cond(const __cond&);
    __cond& operator=(const __cond&);

  public:
    __cond()
    {




    }
# 280 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/ext/concurrence.h" 3
    void broadcast()
    {

      if (__gthread_active_p())
 {
   if (__gthread_cond_broadcast(&_M_cond) != 0)
     __throw_concurrence_broadcast_error();
 }

    }

    void wait(__mutex *mutex)
    {

      {
   if (__gthread_cond_wait(&_M_cond, mutex->gthread_mutex()) != 0)
     __throw_concurrence_wait_error();
      }

    }

    void wait_recursive(__recursive_mutex *mutex)
    {

      {
   if (__gthread_cond_wait_recursive(&_M_cond,
         mutex->gthread_recursive_mutex())
       != 0)
     __throw_concurrence_wait_error();
      }

    }
  };



}
# 75 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/memory" 2 3






# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unique_ptr.h" 1 3
# 39 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unique_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{








  template<typename> class auto_ptr;



  template<typename _Tp>
    struct default_delete
    {

      constexpr default_delete() noexcept = default;






      template<typename _Up, typename = typename
        enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }


      void
      operator()(_Tp* __ptr) const
      {
 static_assert(!is_void<_Tp>::value,
        "can't delete pointer to incomplete type");
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete __ptr;
      }
    };




  template<typename _Tp>
    struct default_delete<_Tp[]>
    {
    private:
      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;

    public:

      constexpr default_delete() noexcept = default;
# 109 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unique_ptr.h" 3
      template<typename _Up, typename = typename
        enable_if<!__is_derived_Tp<_Up>::value>::type>
        default_delete(const default_delete<_Up[]>&) noexcept { }


      void
      operator()(_Tp* __ptr) const
      {
 static_assert(sizeof(_Tp)>0,
        "can't delete pointer to incomplete type");
 delete [] __ptr;
      }

      template<typename _Up>
 typename enable_if<__is_derived_Tp<_Up>::value>::type
 operator()(_Up*) const = delete;
    };


  template <typename _Tp, typename _Dp = default_delete<_Tp> >
    class unique_ptr
    {

      class _Pointer
      {
 template<typename _Up>
   static typename _Up::pointer __test(typename _Up::pointer*);

 template<typename _Up>
   static _Tp* __test(...);

 typedef typename remove_reference<_Dp>::type _Del;

      public:
 typedef decltype(__test<_Del>(0)) type;
      };

      typedef std::tuple<typename _Pointer::type, _Dp> __tuple_type;
      __tuple_type _M_t;

    public:
      typedef typename _Pointer::type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;




      constexpr unique_ptr() noexcept
      : _M_t()
      { static_assert(!is_pointer<deleter_type>::value,
       "constructed with null function pointer deleter"); }







      explicit
      unique_ptr(pointer __p) noexcept
      : _M_t(__p, deleter_type())
      { static_assert(!is_pointer<deleter_type>::value,
       "constructed with null function pointer deleter"); }
# 181 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename conditional<is_reference<deleter_type>::value,
     deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
# 193 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!std::is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }




      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }







      template<typename _Up, typename _Ep, typename = _Require<
        is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
        __not_<is_array<_Up>>,
        typename conditional<is_reference<_Dp>::value,
        is_same<_Ep, _Dp>,
        is_convertible<_Ep, _Dp>>::type>>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }



      template<typename _Up, typename = _Require<
        is_convertible<_Up*, _Tp*>, is_same<_Dp, default_delete<_Tp>>>>
 unique_ptr(auto_ptr<_Up>&& __u) noexcept;



      ~unique_ptr() noexcept
      {
 auto& __ptr = std::get<0>(_M_t);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
# 248 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
# 263 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
 typename enable_if< __and_<
   is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>,
   __not_<is_array<_Up>>
   >::value,
   unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename add_lvalue_reference<element_type>::type
      operator*() const
      {
 ;
 return *get();
      }


      pointer
      operator->() const noexcept
      {
 ;
 return get();
      }


      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }


      deleter_type&
      get_deleter() noexcept
      { return std::get<1>(_M_t); }


      const deleter_type&
      get_deleter() const noexcept
      { return std::get<1>(_M_t); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 std::get<0>(_M_t) = pointer();
 return __p;
      }







      void
      reset(pointer __p = pointer()) noexcept
      {
 using std::swap;
 swap(std::get<0>(_M_t), __p);
 if (__p != pointer())
   get_deleter()(__p);
      }


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;
  };





  template<typename _Tp, typename _Dp>
    class unique_ptr<_Tp[], _Dp>
    {

      class _Pointer
      {
 template<typename _Up>
   static typename _Up::pointer __test(typename _Up::pointer*);

 template<typename _Up>
   static _Tp* __test(...);

 typedef typename remove_reference<_Dp>::type _Del;

      public:
 typedef decltype(__test<_Del>(0)) type;
      };

      typedef std::tuple<typename _Pointer::type, _Dp> __tuple_type;
      __tuple_type _M_t;

      template<typename _Up>
 using __remove_cv = typename remove_cv<_Up>::type;


      template<typename _Up>
 using __is_derived_Tp
   = __and_< is_base_of<_Tp, _Up>,
      __not_<is_same<__remove_cv<_Tp>, __remove_cv<_Up>>> >;

      template<typename _Up, typename _Ep,
        typename _Tp_pointer = typename _Pointer::type,
        typename _Up_pointer = typename unique_ptr<_Up, _Ep>::pointer>
 using __safe_conversion = __and_<
     is_convertible<_Up_pointer, _Tp_pointer>,
     is_array<_Up>,
     __or_<__not_<is_pointer<_Up_pointer>>,
    __not_<is_pointer<_Tp_pointer>>,
    __not_<__is_derived_Tp<typename remove_extent<_Up>::type>>
     >
   >;

    public:
      typedef typename _Pointer::type pointer;
      typedef _Tp element_type;
      typedef _Dp deleter_type;




      constexpr unique_ptr() noexcept
      : _M_t()
      { static_assert(!std::is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }







      explicit
      unique_ptr(pointer __p) noexcept
      : _M_t(__p, deleter_type())
      { static_assert(!is_pointer<deleter_type>::value,
        "constructed with null function pointer deleter"); }


      template<typename _Up, typename = _Require<is_pointer<pointer>,
        is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>
 explicit
 unique_ptr(_Up* __p) = delete;
# 444 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unique_ptr.h" 3
      unique_ptr(pointer __p,
   typename conditional<is_reference<deleter_type>::value,
       deleter_type, const deleter_type&>::type __d) noexcept
      : _M_t(__p, __d) { }
# 456 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unique_ptr.h" 3
      unique_ptr(pointer __p, typename
   remove_reference<deleter_type>::type&& __d) noexcept
      : _M_t(std::move(__p), std::move(__d))
      { static_assert(!is_reference<deleter_type>::value,
        "rvalue deleter bound to reference"); }


      unique_ptr(unique_ptr&& __u) noexcept
      : _M_t(__u.release(), std::forward<deleter_type>(__u.get_deleter())) { }


      constexpr unique_ptr(nullptr_t) noexcept : unique_ptr() { }

      template<typename _Up, typename _Ep,
        typename = _Require<__safe_conversion<_Up, _Ep>,
   typename conditional<is_reference<_Dp>::value,
          is_same<_Ep, _Dp>,
          is_convertible<_Ep, _Dp>>::type
        >>
 unique_ptr(unique_ptr<_Up, _Ep>&& __u) noexcept
 : _M_t(__u.release(), std::forward<_Ep>(__u.get_deleter()))
 { }


      ~unique_ptr()
      {
 auto& __ptr = std::get<0>(_M_t);
 if (__ptr != nullptr)
   get_deleter()(__ptr);
 __ptr = pointer();
      }
# 496 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unique_ptr.h" 3
      unique_ptr&
      operator=(unique_ptr&& __u) noexcept
      {
 reset(__u.release());
 get_deleter() = std::forward<deleter_type>(__u.get_deleter());
 return *this;
      }
# 511 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unique_ptr.h" 3
      template<typename _Up, typename _Ep>
 typename
 enable_if<__safe_conversion<_Up, _Ep>::value, unique_ptr&>::type
 operator=(unique_ptr<_Up, _Ep>&& __u) noexcept
 {
   reset(__u.release());
   get_deleter() = std::forward<_Ep>(__u.get_deleter());
   return *this;
 }


      unique_ptr&
      operator=(nullptr_t) noexcept
      {
 reset();
 return *this;
      }




      typename std::add_lvalue_reference<element_type>::type
      operator[](size_t __i) const
      {
 ;
 return get()[__i];
      }


      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }


      deleter_type&
      get_deleter() noexcept
      { return std::get<1>(_M_t); }


      const deleter_type&
      get_deleter() const noexcept
      { return std::get<1>(_M_t); }


      explicit operator bool() const noexcept
      { return get() == pointer() ? false : true; }




      pointer
      release() noexcept
      {
 pointer __p = get();
 std::get<0>(_M_t) = pointer();
 return __p;
      }







      void
      reset(pointer __p = pointer()) noexcept
      {
 using std::swap;
 swap(std::get<0>(_M_t), __p);
 if (__p != nullptr)
   get_deleter()(__p);
      }


      template<typename _Up, typename = _Require<is_pointer<pointer>,
        is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>
 void reset(_Up*) = delete;


      void
      swap(unique_ptr& __u) noexcept
      {
 using std::swap;
 swap(_M_t, __u._M_t);
      }


      unique_ptr(const unique_ptr&) = delete;
      unique_ptr& operator=(const unique_ptr&) = delete;


      template<typename _Up, typename = _Require<is_pointer<pointer>,
        is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>
 unique_ptr(_Up*, typename
     conditional<is_reference<deleter_type>::value,
     deleter_type, const deleter_type&>::type) = delete;


      template<typename _Up, typename = _Require<is_pointer<pointer>,
        is_convertible<_Up*, pointer>, __is_derived_Tp<_Up>>>
 unique_ptr(_Up*, typename
     remove_reference<deleter_type>::type&&) = delete;
    };

  template<typename _Tp, typename _Dp>
    inline void
    swap(unique_ptr<_Tp, _Dp>& __x,
  unique_ptr<_Tp, _Dp>& __y) noexcept
    { __x.swap(__y); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() == __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator==(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return !__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return __x.get() != __y.get(); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp>
    inline bool
    operator!=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x) noexcept
    { return (bool)__x; }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    {
      typedef typename
 std::common_type<typename unique_ptr<_Tp, _Dp>::pointer,
                  typename unique_ptr<_Up, _Ep>::pointer>::type _CT;
      return std::less<_CT>()(__x.get(), __y.get());
    }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(nullptr < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator<=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x,
       const unique_ptr<_Up, _Ep>& __y)
    { return (__y < __x); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(nullptr,
         __x.get()); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return std::less<typename unique_ptr<_Tp, _Dp>::pointer>()(__x.get(),
         nullptr); }

  template<typename _Tp, typename _Dp,
    typename _Up, typename _Ep>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x,
        const unique_ptr<_Up, _Ep>& __y)
    { return !(__x < __y); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(const unique_ptr<_Tp, _Dp>& __x, nullptr_t)
    { return !(__x < nullptr); }

  template<typename _Tp, typename _Dp>
    inline bool
    operator>=(nullptr_t, const unique_ptr<_Tp, _Dp>& __x)
    { return !(nullptr < __x); }


  template<typename _Tp, typename _Dp>
    struct hash<unique_ptr<_Tp, _Dp>>
    : public __hash_base<size_t, unique_ptr<_Tp, _Dp>>
    {
      size_t
      operator()(const unique_ptr<_Tp, _Dp>& __u) const noexcept
      {
 typedef unique_ptr<_Tp, _Dp> _UP;
 return std::hash<typename _UP::pointer>()(__u.get());
      }
    };
# 778 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/unique_ptr.h" 3

}
# 82 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/memory" 2 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr.h" 1 3
# 52 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr.h" 3
# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr_base.h" 1 3
# 54 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr_base.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{



  template<typename> class auto_ptr;






  class bad_weak_ptr : public std::exception
  {
  public:
    virtual char const*
    what() const noexcept;

    virtual ~bad_weak_ptr() noexcept;
  };


  inline void
  __throw_bad_weak_ptr()
  { (throw (bad_weak_ptr())); }

  using __gnu_cxx::_Lock_policy;
  using __gnu_cxx::__default_lock_policy;
  using __gnu_cxx::_S_single;
  using __gnu_cxx::_S_mutex;
  using __gnu_cxx::_S_atomic;


  template<_Lock_policy _Lp>
    class _Mutex_base
    {
    protected:

      enum { _S_need_barriers = 0 };
    };

  template<>
    class _Mutex_base<_S_mutex>
    : public __gnu_cxx::__mutex
    {
    protected:



      enum { _S_need_barriers = 1 };
    };

  template<_Lock_policy _Lp = __default_lock_policy>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }

      virtual
      ~_Sp_counted_base() noexcept
      { }



      virtual void
      _M_dispose() noexcept = 0;


      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept = 0;

      void
      _M_add_ref_copy()
      { __gnu_cxx::__atomic_add_dispatch(&_M_use_count, 1); }

      void
      _M_add_ref_lock();

      bool
      _M_add_ref_lock_nothrow();

      void
      _M_release() noexcept
      {

        ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, -1) == 1)
   {
            ;
     _M_dispose();




     if (_Mutex_base<_Lp>::_S_need_barriers)
       {
         __asm volatile ("":::"memory");
         __asm volatile ("":::"memory");
       }


            ;
     if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count,
             -1) == 1)
              {
                ;
         _M_destroy();
              }
   }
      }

      void
      _M_weak_add_ref() noexcept
      { __gnu_cxx::__atomic_add_dispatch(&_M_weak_count, 1); }

      void
      _M_weak_release() noexcept
      {

        ;
 if (__gnu_cxx::__exchange_and_add_dispatch(&_M_weak_count, -1) == 1)
   {
            ;
     if (_Mutex_base<_Lp>::_S_need_barriers)
       {


         __asm volatile ("":::"memory");
         __asm volatile ("":::"memory");
       }
     _M_destroy();
   }
      }

      long
      _M_get_use_count() const noexcept
      {


        return __atomic_load_n(&_M_use_count, 0);
      }

    private:
      _Sp_counted_base(_Sp_counted_base const&) = delete;
      _Sp_counted_base& operator=(_Sp_counted_base const&) = delete;

      _Atomic_word _M_use_count;
      _Atomic_word _M_weak_count;
    };

  template<>
    inline void
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock()
    {
      if (_M_use_count == 0)
 __throw_bad_weak_ptr();
      ++_M_use_count;
    }

  template<>
    inline void
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   __throw_bad_weak_ptr();
 }
    }

  template<>
    inline void
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock()
    {

      _Atomic_word __count = _M_get_use_count();
      do
 {
   if (__count == 0)
     __throw_bad_weak_ptr();


 }
      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
       true, 4,
       0));
    }

  template<>
    inline bool
    _Sp_counted_base<_S_single>::
    _M_add_ref_lock_nothrow()
    {
      if (_M_use_count == 0)
 return false;
      ++_M_use_count;
      return true;
    }

  template<>
    inline bool
    _Sp_counted_base<_S_mutex>::
    _M_add_ref_lock_nothrow()
    {
      __gnu_cxx::__scoped_lock sentry(*this);
      if (__gnu_cxx::__exchange_and_add_dispatch(&_M_use_count, 1) == 0)
 {
   _M_use_count = 0;
   return false;
 }
      return true;
    }

  template<>
    inline bool
    _Sp_counted_base<_S_atomic>::
    _M_add_ref_lock_nothrow()
    {

      _Atomic_word __count = _M_get_use_count();
      do
 {
   if (__count == 0)
     return false;


 }
      while (!__atomic_compare_exchange_n(&_M_use_count, &__count, __count + 1,
       true, 4,
       0));
      return true;
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
        }
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_weak_add_ref() noexcept
    { ++_M_weak_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_weak_release() noexcept
    {
      if (--_M_weak_count == 0)
        _M_destroy();
    }

  template<>
    inline long
    _Sp_counted_base<_S_single>::_M_get_use_count() const noexcept
    { return _M_use_count; }



  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __shared_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __weak_ptr;

  template<typename _Tp, _Lock_policy _Lp = __default_lock_policy>
    class __enable_shared_from_this;

  template<typename _Tp>
    class shared_ptr;

  template<typename _Tp>
    class weak_ptr;

  template<typename _Tp>
    struct owner_less;

  template<typename _Tp>
    class enable_shared_from_this;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __weak_count;

  template<_Lock_policy _Lp = __default_lock_policy>
    class __shared_count;



  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
    {
    public:
      explicit
      _Sp_counted_ptr(_Ptr __p) noexcept
      : _M_ptr(__p) { }

      virtual void
      _M_dispose() noexcept
      { delete _M_ptr; }

      virtual void
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept
      { return nullptr; }

      _Sp_counted_ptr(const _Sp_counted_ptr&) = delete;
      _Sp_counted_ptr& operator=(const _Sp_counted_ptr&) = delete;

    private:
      _Ptr _M_ptr;
    };

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_single>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_mutex>::_M_dispose() noexcept { }

  template<>
    inline void
    _Sp_counted_ptr<nullptr_t, _S_atomic>::_M_dispose() noexcept { }

  template<int _Nm, typename _Tp,
    bool __use_ebo = !__is_final(_Tp) && __is_empty(_Tp)>
    struct _Sp_ebo_helper;


  template<int _Nm, typename _Tp>
    struct _Sp_ebo_helper<_Nm, _Tp, true> : private _Tp
    {
      explicit _Sp_ebo_helper(const _Tp& __tp) : _Tp(__tp) { }

      static _Tp&
      _S_get(_Sp_ebo_helper& __eboh) { return static_cast<_Tp&>(__eboh); }
    };


  template<int _Nm, typename _Tp>
    struct _Sp_ebo_helper<_Nm, _Tp, false>
    {
      explicit _Sp_ebo_helper(const _Tp& __tp) : _M_tp(__tp) { }

      static _Tp&
      _S_get(_Sp_ebo_helper& __eboh)
      { return __eboh._M_tp; }

    private:
      _Tp _M_tp;
    };


  template<typename _Ptr, typename _Deleter, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_deleter final : public _Sp_counted_base<_Lp>
    {
      class _Impl : _Sp_ebo_helper<0, _Deleter>, _Sp_ebo_helper<1, _Alloc>
      {
 typedef _Sp_ebo_helper<0, _Deleter> _Del_base;
 typedef _Sp_ebo_helper<1, _Alloc> _Alloc_base;

      public:
 _Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
 : _M_ptr(__p), _Del_base(__d), _Alloc_base(__a)
 { }

 _Deleter& _M_del() noexcept { return _Del_base::_S_get(*this); }
 _Alloc& _M_alloc() noexcept { return _Alloc_base::_S_get(*this); }

 _Ptr _M_ptr;
      };

    public:

      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, __d, _Alloc()) { }


      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }

      virtual void
      _M_dispose() noexcept
      { _M_impl._M_del()(_M_impl._M_ptr); }

      virtual void
      _M_destroy() noexcept
      {
 typedef typename allocator_traits<_Alloc>::template
   rebind_traits<_Sp_counted_deleter> _Alloc_traits;
 typename _Alloc_traits::allocator_type __a(_M_impl._M_alloc());
 _Alloc_traits::destroy(__a, this);
 _Alloc_traits::deallocate(__a, this, 1);
      }

      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept
      {

        return __ti == typeid(_Deleter) ? &_M_impl._M_del() : nullptr;



      }

    private:
      _Impl _M_impl;
    };



  struct _Sp_make_shared_tag { };

  template<typename _Tp, typename _Alloc, _Lock_policy _Lp>
    class _Sp_counted_ptr_inplace final : public _Sp_counted_base<_Lp>
    {
      class _Impl : _Sp_ebo_helper<0, _Alloc>
      {
 typedef _Sp_ebo_helper<0, _Alloc> _A_base;

      public:
 explicit _Impl(_Alloc __a) noexcept : _A_base(__a) { }

 _Alloc& _M_alloc() noexcept { return _A_base::_S_get(*this); }

 __gnu_cxx::__aligned_buffer<_Tp> _M_storage;
      };

    public:
      template<typename... _Args>
 _Sp_counted_ptr_inplace(_Alloc __a, _Args&&... __args)
 : _M_impl(__a)
 {


   allocator_traits<_Alloc>::construct(__a, _M_ptr(),
       std::forward<_Args>(__args)...);
 }

      ~_Sp_counted_ptr_inplace() noexcept { }

      virtual void
      _M_dispose() noexcept
      {
 allocator_traits<_Alloc>::destroy(_M_impl._M_alloc(), _M_ptr());
      }


      virtual void
      _M_destroy() noexcept
      {
 typedef typename allocator_traits<_Alloc>::template
   rebind_traits<_Sp_counted_ptr_inplace> _Alloc_traits;
 typename _Alloc_traits::allocator_type __a(_M_impl._M_alloc());
 _Alloc_traits::destroy(__a, this);
 _Alloc_traits::deallocate(__a, this, 1);
      }


      virtual void*
      _M_get_deleter(const std::type_info& __ti) noexcept
      {

 if (__ti == typeid(_Sp_make_shared_tag))
   return const_cast<typename remove_cv<_Tp>::type*>(_M_ptr());

 return nullptr;
      }

    private:
      _Tp* _M_ptr() noexcept { return _M_impl._M_storage._M_ptr(); }

      _Impl _M_impl;
    };


  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
 __shared_count(_Ptr __p) : _M_pi(0)
 {
   try
     {
       _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
     }
   catch(...)
     {
       delete __p;
       throw;
     }
 }

      template<typename _Ptr, typename _Deleter>
 __shared_count(_Ptr __p, _Deleter __d)
 : __shared_count(__p, std::move(__d), allocator<void>())
 { }

      template<typename _Ptr, typename _Deleter, typename _Alloc>
 __shared_count(_Ptr __p, _Deleter __d, _Alloc __a) : _M_pi(0)
 {
   typedef _Sp_counted_deleter<_Ptr, _Deleter, _Alloc, _Lp> _Sp_cd_type;
   typedef typename allocator_traits<_Alloc>::template
     rebind_traits<_Sp_cd_type> _Alloc_traits;
   typename _Alloc_traits::allocator_type __a2(__a);
   _Sp_cd_type* __mem = 0;
   try
     {
       __mem = _Alloc_traits::allocate(__a2, 1);
       _Alloc_traits::construct(__a2, __mem,
    __p, std::move(__d), std::move(__a));
       _M_pi = __mem;
     }
   catch(...)
     {
       __d(__p);
       if (__mem)
         _Alloc_traits::deallocate(__a2, __mem, 1);
       throw;
     }
 }

      template<typename _Tp, typename _Alloc, typename... _Args>
 __shared_count(_Sp_make_shared_tag, _Tp*, const _Alloc& __a,
         _Args&&... __args)
 : _M_pi(0)
 {
   typedef _Sp_counted_ptr_inplace<_Tp, _Alloc, _Lp> _Sp_cp_type;
   typedef typename allocator_traits<_Alloc>::template
     rebind_traits<_Sp_cp_type> _Alloc_traits;
   typename _Alloc_traits::allocator_type __a2(__a);
   _Sp_cp_type* __mem = _Alloc_traits::allocate(__a2, 1);
   try
     {
       _Alloc_traits::construct(__a2, __mem, std::move(__a),
      std::forward<_Args>(__args)...);
       _M_pi = __mem;
     }
   catch(...)
     {
       _Alloc_traits::deallocate(__a2, __mem, 1);
       throw;
     }
 }



      template<typename _Tp>
        explicit
 __shared_count(std::auto_ptr<_Tp>&& __r);



      template<typename _Tp, typename _Del>
        explicit
 __shared_count(std::unique_ptr<_Tp, _Del>&& __r) : _M_pi(0)
 {
   using _Ptr = typename unique_ptr<_Tp, _Del>::pointer;
   using _Del2 = typename conditional<is_reference<_Del>::value,
       reference_wrapper<typename remove_reference<_Del>::type>,
       _Del>::type;
   using _Sp_cd_type
     = _Sp_counted_deleter<_Ptr, _Del2, allocator<void>, _Lp>;
   using _Alloc = allocator<_Sp_cd_type>;
   using _Alloc_traits = allocator_traits<_Alloc>;
   _Alloc __a;
   _Sp_cd_type* __mem = _Alloc_traits::allocate(__a, 1);
   _Alloc_traits::construct(__a, __mem, __r.release(),
       __r.get_deleter());
   _M_pi = __mem;
 }


      explicit __shared_count(const __weak_count<_Lp>& __r);


      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
 if (_M_pi != nullptr)
   _M_pi->_M_release();
      }

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_add_ref_copy();
      }

      __shared_count&
      operator=(const __shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != _M_pi)
   {
     if (__tmp != 0)
       __tmp->_M_add_ref_copy();
     if (_M_pi != 0)
       _M_pi->_M_release();
     _M_pi = __tmp;
   }
 return *this;
      }

      void
      _M_swap(__shared_count& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_unique() const noexcept
      { return this->_M_get_use_count() == 1; }

      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_pi ? _M_pi->_M_get_deleter(__ti) : nullptr; }

      bool
      _M_less(const __shared_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __weak_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __shared_count& __a, const __shared_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __weak_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    class __weak_count
    {
    public:
      constexpr __weak_count() noexcept : _M_pi(0)
      { }

      __weak_count(const __shared_count<_Lp>& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_weak_add_ref();
      }

      __weak_count(const __weak_count<_Lp>& __r) noexcept
      : _M_pi(__r._M_pi)
      {
 if (_M_pi != 0)
   _M_pi->_M_weak_add_ref();
      }

      ~__weak_count() noexcept
      {
 if (_M_pi != 0)
   _M_pi->_M_weak_release();
      }

      __weak_count<_Lp>&
      operator=(const __shared_count<_Lp>& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != 0)
   __tmp->_M_weak_add_ref();
 if (_M_pi != 0)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      __weak_count<_Lp>&
      operator=(const __weak_count<_Lp>& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 if (__tmp != 0)
   __tmp->_M_weak_add_ref();
 if (_M_pi != 0)
   _M_pi->_M_weak_release();
 _M_pi = __tmp;
 return *this;
      }

      void
      _M_swap(__weak_count<_Lp>& __r) noexcept
      {
 _Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 __r._M_pi = _M_pi;
 _M_pi = __tmp;
      }

      long
      _M_get_use_count() const noexcept
      { return _M_pi != 0 ? _M_pi->_M_get_use_count() : 0; }

      bool
      _M_less(const __weak_count& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }

      bool
      _M_less(const __shared_count<_Lp>& __rhs) const noexcept
      { return std::less<_Sp_counted_base<_Lp>*>()(this->_M_pi, __rhs._M_pi); }


      friend inline bool
      operator==(const __weak_count& __a, const __weak_count& __b) noexcept
      { return __a._M_pi == __b._M_pi; }

    private:
      friend class __shared_count<_Lp>;

      _Sp_counted_base<_Lp>* _M_pi;
    };


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::__shared_count(const __weak_count<_Lp>& __r)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != nullptr)
 _M_pi->_M_add_ref_lock();
      else
 __throw_bad_weak_ptr();
    }


  template<_Lock_policy _Lp>
    inline
    __shared_count<_Lp>::
    __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t)
    : _M_pi(__r._M_pi)
    {
      if (_M_pi != nullptr)
 if (!_M_pi->_M_add_ref_lock_nothrow())
   _M_pi = nullptr;
    }




  template<_Lock_policy _Lp, typename _Tp1, typename _Tp2>
    void
    __enable_shared_from_this_helper(const __shared_count<_Lp>&,
         const __enable_shared_from_this<_Tp1,
         _Lp>*, const _Tp2*) noexcept;


  template<typename _Tp1, typename _Tp2>
    void
    __enable_shared_from_this_helper(const __shared_count<>&,
         const enable_shared_from_this<_Tp1>*,
         const _Tp2*) noexcept;

  template<_Lock_policy _Lp>
    inline void
    __enable_shared_from_this_helper(const __shared_count<_Lp>&, ...) noexcept
    { }


  template<typename _Tp, _Lock_policy _Lp>
    class __shared_ptr
    {
    public:
      typedef _Tp element_type;

      constexpr __shared_ptr() noexcept
      : _M_ptr(0), _M_refcount()
      { }

      template<typename _Tp1>
 explicit __shared_ptr(_Tp1* __p)
        : _M_ptr(__p), _M_refcount(__p)
 {
  
   static_assert( !is_void<_Tp1>::value, "incomplete type" );
   static_assert( sizeof(_Tp1) > 0, "incomplete type" );
   __enable_shared_from_this_helper(_M_refcount, __p, __p);
 }

      template<typename _Tp1, typename _Deleter>
 __shared_ptr(_Tp1* __p, _Deleter __d)
 : _M_ptr(__p), _M_refcount(__p, __d)
 {
  

   __enable_shared_from_this_helper(_M_refcount, __p, __p);
 }

      template<typename _Tp1, typename _Deleter, typename _Alloc>
 __shared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)
 : _M_ptr(__p), _M_refcount(__p, __d, std::move(__a))
 {
  

   __enable_shared_from_this_helper(_M_refcount, __p, __p);
 }

      template<typename _Deleter>
 __shared_ptr(nullptr_t __p, _Deleter __d)
 : _M_ptr(0), _M_refcount(__p, __d)
 { }

      template<typename _Deleter, typename _Alloc>
        __shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : _M_ptr(0), _M_refcount(__p, __d, std::move(__a))
 { }

      template<typename _Tp1>
 __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
 : _M_ptr(__p), _M_refcount(__r._M_refcount)
 { }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;

      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
 __shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
 _M_refcount._M_swap(__r._M_refcount);
 __r._M_ptr = 0;
      }

      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
 __shared_ptr(__shared_ptr<_Tp1, _Lp>&& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount()
 {
   _M_refcount._M_swap(__r._M_refcount);
   __r._M_ptr = 0;
 }

      template<typename _Tp1>
 explicit __shared_ptr(const __weak_ptr<_Tp1, _Lp>& __r)
 : _M_refcount(__r._M_refcount)
 {
  



   _M_ptr = __r._M_ptr;
 }


      template<typename _Tp1, typename _Del>
 __shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)
 : _M_ptr(__r.get()), _M_refcount()
 {
  
   auto __raw = _S_raw_ptr(__r.get());
   _M_refcount = __shared_count<_Lp>(std::move(__r));
   __enable_shared_from_this_helper(_M_refcount, __raw, __raw);
 }



      template<typename _Tp1>
 __shared_ptr(std::auto_ptr<_Tp1>&& __r);



      constexpr __shared_ptr(nullptr_t) noexcept
      : _M_ptr(0), _M_refcount()
      { }

      template<typename _Tp1>
 __shared_ptr&
 operator=(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }


      template<typename _Tp1>
 __shared_ptr&
 operator=(std::auto_ptr<_Tp1>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }


      __shared_ptr&
      operator=(__shared_ptr&& __r) noexcept
      {
 __shared_ptr(std::move(__r)).swap(*this);
 return *this;
      }

      template<class _Tp1>
 __shared_ptr&
 operator=(__shared_ptr<_Tp1, _Lp>&& __r) noexcept
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      template<typename _Tp1, typename _Del>
 __shared_ptr&
 operator=(std::unique_ptr<_Tp1, _Del>&& __r)
 {
   __shared_ptr(std::move(__r)).swap(*this);
   return *this;
 }

      void
      reset() noexcept
      { __shared_ptr().swap(*this); }

      template<typename _Tp1>
 void
 reset(_Tp1* __p)
 {

   ;
   __shared_ptr(__p).swap(*this);
 }

      template<typename _Tp1, typename _Deleter>
 void
 reset(_Tp1* __p, _Deleter __d)
 { __shared_ptr(__p, __d).swap(*this); }

      template<typename _Tp1, typename _Deleter, typename _Alloc>
 void
        reset(_Tp1* __p, _Deleter __d, _Alloc __a)
        { __shared_ptr(__p, __d, std::move(__a)).swap(*this); }


      typename std::add_lvalue_reference<_Tp>::type
      operator*() const noexcept
      {
 ;
 return *_M_ptr;
      }

      _Tp*
      operator->() const noexcept
      {
 ;
 return _M_ptr;
      }

      _Tp*
      get() const noexcept
      { return _M_ptr; }

      explicit operator bool() const
      { return _M_ptr == 0 ? false : true; }

      bool
      unique() const noexcept
      { return _M_refcount._M_unique(); }

      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }

      void
      swap(__shared_ptr<_Tp, _Lp>& __other) noexcept
      {
 std::swap(_M_ptr, __other._M_ptr);
 _M_refcount._M_swap(__other._M_refcount);
      }

      template<typename _Tp1>
 bool
 owner_before(__shared_ptr<_Tp1, _Lp> const& __rhs) const
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(__weak_ptr<_Tp1, _Lp> const& __rhs) const
 { return _M_refcount._M_less(__rhs._M_refcount); }


    protected:

      template<typename _Alloc, typename... _Args>
 __shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
       _Args&&... __args)
 : _M_ptr(), _M_refcount(__tag, (_Tp*)0, __a,
    std::forward<_Args>(__args)...)
 {


   void* __p = _M_refcount._M_get_deleter(typeid(__tag));
   _M_ptr = static_cast<_Tp*>(__p);
   __enable_shared_from_this_helper(_M_refcount, _M_ptr, _M_ptr);
 }
# 1138 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr_base.h" 3
      template<typename _Tp1, _Lock_policy _Lp1, typename _Alloc,
        typename... _Args>
 friend __shared_ptr<_Tp1, _Lp1>
 __allocate_shared(const _Alloc& __a, _Args&&... __args);



      __shared_ptr(const __weak_ptr<_Tp, _Lp>& __r, std::nothrow_t)
      : _M_refcount(__r._M_refcount, std::nothrow)
      {
 _M_ptr = _M_refcount._M_get_use_count() ? __r._M_ptr : nullptr;
      }

      friend class __weak_ptr<_Tp, _Lp>;

    private:
      void*
      _M_get_deleter(const std::type_info& __ti) const noexcept
      { return _M_refcount._M_get_deleter(__ti); }

      template<typename _Tp1>
 static _Tp1*
 _S_raw_ptr(_Tp1* __ptr)
 { return __ptr; }

      template<typename _Tp1>
 static auto
 _S_raw_ptr(_Tp1 __ptr) -> decltype(std::__addressof(*__ptr))
 { return std::__addressof(*__ptr); }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;

      template<typename _Del, typename _Tp1, _Lock_policy _Lp1>
 friend _Del* get_deleter(const __shared_ptr<_Tp1, _Lp1>&) noexcept;

      _Tp* _M_ptr;
      __shared_count<_Lp> _M_refcount;
    };



  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() == __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !__a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator==(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !__a; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return __a.get() != __b.get(); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return (bool)__a; }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator!=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return (bool)__a; }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp1, _Lp>& __a,
       const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    {
      typedef typename std::common_type<_Tp1*, _Tp2*>::type _CT;
      return std::less<_CT>()(__a.get(), __b.get());
    }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return std::less<_Tp*>()(__a.get(), nullptr); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return std::less<_Tp*>()(nullptr, __a.get()); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator<=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp1, _Lp>& __a,
       const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return (__b < __a); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return std::less<_Tp*>()(nullptr, __a.get()); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return std::less<_Tp*>()(__a.get(), nullptr); }

  template<typename _Tp1, typename _Tp2, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp1, _Lp>& __a,
        const __shared_ptr<_Tp2, _Lp>& __b) noexcept
    { return !(__a < __b); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(const __shared_ptr<_Tp, _Lp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp, _Lock_policy _Lp>
    inline bool
    operator>=(nullptr_t, const __shared_ptr<_Tp, _Lp>& __a) noexcept
    { return !(nullptr < __a); }

  template<typename _Sp>
    struct _Sp_less : public binary_function<_Sp, _Sp, bool>
    {
      bool
      operator()(const _Sp& __lhs, const _Sp& __rhs) const noexcept
      {
 typedef typename _Sp::element_type element_type;
 return std::less<element_type*>()(__lhs.get(), __rhs.get());
      }
    };

  template<typename _Tp, _Lock_policy _Lp>
    struct less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_less<__shared_ptr<_Tp, _Lp>>
    { };


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__shared_ptr<_Tp, _Lp>& __a, __shared_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }
# 1308 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr_base.h" 3
  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    static_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    { return __shared_ptr<_Tp, _Lp>(__r, static_cast<_Tp*>(__r.get())); }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    const_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    { return __shared_ptr<_Tp, _Lp>(__r, const_cast<_Tp*>(__r.get())); }






  template<typename _Tp, typename _Tp1, _Lock_policy _Lp>
    inline __shared_ptr<_Tp, _Lp>
    dynamic_pointer_cast(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
    {
      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))
 return __shared_ptr<_Tp, _Lp>(__r, __p);
      return __shared_ptr<_Tp, _Lp>();
    }


  template<typename _Tp, _Lock_policy _Lp>
    class __weak_ptr
    {
    public:
      typedef _Tp element_type;

      constexpr __weak_ptr() noexcept
      : _M_ptr(0), _M_refcount()
      { }

      __weak_ptr(const __weak_ptr&) noexcept = default;
      __weak_ptr& operator=(const __weak_ptr&) noexcept = default;
      ~__weak_ptr() = default;
# 1366 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr_base.h" 3
      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
 __weak_ptr(const __weak_ptr<_Tp1, _Lp>& __r) noexcept
 : _M_refcount(__r._M_refcount)
        { _M_ptr = __r.lock().get(); }

      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
 __weak_ptr(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
 : _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
 { }

      template<typename _Tp1>
 __weak_ptr&
 operator=(const __weak_ptr<_Tp1, _Lp>& __r) noexcept
 {
   _M_ptr = __r.lock().get();
   _M_refcount = __r._M_refcount;
   return *this;
 }

      template<typename _Tp1>
 __weak_ptr&
 operator=(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
 {
   _M_ptr = __r._M_ptr;
   _M_refcount = __r._M_refcount;
   return *this;
 }

      __shared_ptr<_Tp, _Lp>
      lock() const noexcept
      { return __shared_ptr<element_type, _Lp>(*this, std::nothrow); }

      long
      use_count() const noexcept
      { return _M_refcount._M_get_use_count(); }

      bool
      expired() const noexcept
      { return _M_refcount._M_get_use_count() == 0; }

      template<typename _Tp1>
 bool
 owner_before(const __shared_ptr<_Tp1, _Lp>& __rhs) const
 { return _M_refcount._M_less(__rhs._M_refcount); }

      template<typename _Tp1>
 bool
 owner_before(const __weak_ptr<_Tp1, _Lp>& __rhs) const
 { return _M_refcount._M_less(__rhs._M_refcount); }

      void
      reset() noexcept
      { __weak_ptr().swap(*this); }

      void
      swap(__weak_ptr& __s) noexcept
      {
 std::swap(_M_ptr, __s._M_ptr);
 _M_refcount._M_swap(__s._M_refcount);
      }

    private:

      void
      _M_assign(_Tp* __ptr, const __shared_count<_Lp>& __refcount) noexcept
      {
 _M_ptr = __ptr;
 _M_refcount = __refcount;
      }

      template<typename _Tp1, _Lock_policy _Lp1> friend class __shared_ptr;
      template<typename _Tp1, _Lock_policy _Lp1> friend class __weak_ptr;
      friend class __enable_shared_from_this<_Tp, _Lp>;
      friend class enable_shared_from_this<_Tp>;

      _Tp* _M_ptr;
      __weak_count<_Lp> _M_refcount;
    };


  template<typename _Tp, _Lock_policy _Lp>
    inline void
    swap(__weak_ptr<_Tp, _Lp>& __a, __weak_ptr<_Tp, _Lp>& __b) noexcept
    { __a.swap(__b); }

  template<typename _Tp, typename _Tp1>
    struct _Sp_owner_less : public binary_function<_Tp, _Tp, bool>
    {
      bool
      operator()(const _Tp& __lhs, const _Tp& __rhs) const
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp& __lhs, const _Tp1& __rhs) const
      { return __lhs.owner_before(__rhs); }

      bool
      operator()(const _Tp1& __lhs, const _Tp& __rhs) const
      { return __lhs.owner_before(__rhs); }
    };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__shared_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__shared_ptr<_Tp, _Lp>, __weak_ptr<_Tp, _Lp>>
    { };

  template<typename _Tp, _Lock_policy _Lp>
    struct owner_less<__weak_ptr<_Tp, _Lp>>
    : public _Sp_owner_less<__weak_ptr<_Tp, _Lp>, __shared_ptr<_Tp, _Lp>>
    { };


  template<typename _Tp, _Lock_policy _Lp>
    class __enable_shared_from_this
    {
    protected:
      constexpr __enable_shared_from_this() noexcept { }

      __enable_shared_from_this(const __enable_shared_from_this&) noexcept { }

      __enable_shared_from_this&
      operator=(const __enable_shared_from_this&) noexcept
      { return *this; }

      ~__enable_shared_from_this() { }

    public:
      __shared_ptr<_Tp, _Lp>
      shared_from_this()
      { return __shared_ptr<_Tp, _Lp>(this->_M_weak_this); }

      __shared_ptr<const _Tp, _Lp>
      shared_from_this() const
      { return __shared_ptr<const _Tp, _Lp>(this->_M_weak_this); }

    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<_Lp>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }

      template<typename _Tp1>
 friend void
 __enable_shared_from_this_helper(const __shared_count<_Lp>& __pn,
      const __enable_shared_from_this* __pe,
      const _Tp1* __px) noexcept
 {
   if (__pe != 0)
     __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);
 }

      mutable __weak_ptr<_Tp, _Lp> _M_weak_this;
    };


  template<typename _Tp, _Lock_policy _Lp, typename _Alloc, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      return __shared_ptr<_Tp, _Lp>(_Sp_make_shared_tag(), __a,
        std::forward<_Args>(__args)...);
    }

  template<typename _Tp, _Lock_policy _Lp, typename... _Args>
    inline __shared_ptr<_Tp, _Lp>
    __make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return std::__allocate_shared<_Tp, _Lp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp, _Lock_policy _Lp>
    struct hash<__shared_ptr<_Tp, _Lp>>
    : public __hash_base<size_t, __shared_ptr<_Tp, _Lp>>
    {
      size_t
      operator()(const __shared_ptr<_Tp, _Lp>& __s) const noexcept
      { return std::hash<_Tp*>()(__s.get()); }
    };


}
# 53 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr.h" 2 3

namespace std __attribute__ ((__visibility__ ("default")))
{








  template<typename _Ch, typename _Tr, typename _Tp, _Lock_policy _Lp>
    inline std::basic_ostream<_Ch, _Tr>&
    operator<<(std::basic_ostream<_Ch, _Tr>& __os,
        const __shared_ptr<_Tp, _Lp>& __p)
    {
      __os << __p.get();
      return __os;
    }


  template<typename _Del, typename _Tp, _Lock_policy _Lp>
    inline _Del*
    get_deleter(const __shared_ptr<_Tp, _Lp>& __p) noexcept
    {

      return static_cast<_Del*>(__p._M_get_deleter(typeid(_Del)));



    }
# 92 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr.h" 3
  template<typename _Tp>
    class shared_ptr : public __shared_ptr<_Tp>
    {
    public:




      constexpr shared_ptr() noexcept
      : __shared_ptr<_Tp>() { }

      shared_ptr(const shared_ptr&) noexcept = default;







      template<typename _Tp1>
 explicit shared_ptr(_Tp1* __p)
        : __shared_ptr<_Tp>(__p) { }
# 128 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr.h" 3
      template<typename _Tp1, typename _Deleter>
 shared_ptr(_Tp1* __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, __d) { }
# 145 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr.h" 3
      template<typename _Deleter>
 shared_ptr(nullptr_t __p, _Deleter __d)
        : __shared_ptr<_Tp>(__p, __d) { }
# 164 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr.h" 3
      template<typename _Tp1, typename _Deleter, typename _Alloc>
 shared_ptr(_Tp1* __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, __d, std::move(__a)) { }
# 183 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr.h" 3
      template<typename _Deleter, typename _Alloc>
 shared_ptr(nullptr_t __p, _Deleter __d, _Alloc __a)
 : __shared_ptr<_Tp>(__p, __d, std::move(__a)) { }
# 205 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr.h" 3
      template<typename _Tp1>
 shared_ptr(const shared_ptr<_Tp1>& __r, _Tp* __p) noexcept
 : __shared_ptr<_Tp>(__r, __p) { }
# 216 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr.h" 3
      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
 shared_ptr(const shared_ptr<_Tp1>& __r) noexcept
        : __shared_ptr<_Tp>(__r) { }






      shared_ptr(shared_ptr&& __r) noexcept
      : __shared_ptr<_Tp>(std::move(__r)) { }






      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
 shared_ptr(shared_ptr<_Tp1>&& __r) noexcept
 : __shared_ptr<_Tp>(std::move(__r)) { }
# 247 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr.h" 3
      template<typename _Tp1>
 explicit shared_ptr(const weak_ptr<_Tp1>& __r)
 : __shared_ptr<_Tp>(__r) { }


      template<typename _Tp1>
 shared_ptr(std::auto_ptr<_Tp1>&& __r);


      template<typename _Tp1, typename _Del>
 shared_ptr(std::unique_ptr<_Tp1, _Del>&& __r)
 : __shared_ptr<_Tp>(std::move(__r)) { }






      constexpr shared_ptr(nullptr_t __p) noexcept
      : __shared_ptr<_Tp>(__p) { }

      shared_ptr& operator=(const shared_ptr&) noexcept = default;

      template<typename _Tp1>
 shared_ptr&
 operator=(const shared_ptr<_Tp1>& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(__r);
   return *this;
 }


      template<typename _Tp1>
 shared_ptr&
 operator=(std::auto_ptr<_Tp1>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }


      shared_ptr&
      operator=(shared_ptr&& __r) noexcept
      {
 this->__shared_ptr<_Tp>::operator=(std::move(__r));
 return *this;
      }

      template<class _Tp1>
 shared_ptr&
 operator=(shared_ptr<_Tp1>&& __r) noexcept
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

      template<typename _Tp1, typename _Del>
 shared_ptr&
 operator=(std::unique_ptr<_Tp1, _Del>&& __r)
 {
   this->__shared_ptr<_Tp>::operator=(std::move(__r));
   return *this;
 }

    private:

      template<typename _Alloc, typename... _Args>
 shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
     _Args&&... __args)
 : __shared_ptr<_Tp>(__tag, __a, std::forward<_Args>(__args)...)
 { }

      template<typename _Tp1, typename _Alloc, typename... _Args>
 friend shared_ptr<_Tp1>
 allocate_shared(const _Alloc& __a, _Args&&... __args);


      shared_ptr(const weak_ptr<_Tp>& __r, std::nothrow_t)
      : __shared_ptr<_Tp>(__r, std::nothrow) { }

      friend class weak_ptr<_Tp>;
    };


  template<typename _Tp1, typename _Tp2>
    inline bool
    operator==(const shared_ptr<_Tp1>& __a,
        const shared_ptr<_Tp2>& __b) noexcept
    { return __a.get() == __b.get(); }

  template<typename _Tp>
    inline bool
    operator==(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !__a; }

  template<typename _Tp>
    inline bool
    operator==(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !__a; }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator!=(const shared_ptr<_Tp1>& __a,
        const shared_ptr<_Tp2>& __b) noexcept
    { return __a.get() != __b.get(); }

  template<typename _Tp>
    inline bool
    operator!=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return (bool)__a; }

  template<typename _Tp>
    inline bool
    operator!=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return (bool)__a; }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator<(const shared_ptr<_Tp1>& __a,
       const shared_ptr<_Tp2>& __b) noexcept
    {
      typedef typename std::common_type<_Tp1*, _Tp2*>::type _CT;
      return std::less<_CT>()(__a.get(), __b.get());
    }

  template<typename _Tp>
    inline bool
    operator<(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return std::less<_Tp*>()(__a.get(), nullptr); }

  template<typename _Tp>
    inline bool
    operator<(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return std::less<_Tp*>()(nullptr, __a.get()); }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator<=(const shared_ptr<_Tp1>& __a,
        const shared_ptr<_Tp2>& __b) noexcept
    { return !(__b < __a); }

  template<typename _Tp>
    inline bool
    operator<=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp>
    inline bool
    operator<=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator>(const shared_ptr<_Tp1>& __a,
       const shared_ptr<_Tp2>& __b) noexcept
    { return (__b < __a); }

  template<typename _Tp>
    inline bool
    operator>(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return std::less<_Tp*>()(nullptr, __a.get()); }

  template<typename _Tp>
    inline bool
    operator>(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return std::less<_Tp*>()(__a.get(), nullptr); }

  template<typename _Tp1, typename _Tp2>
    inline bool
    operator>=(const shared_ptr<_Tp1>& __a,
        const shared_ptr<_Tp2>& __b) noexcept
    { return !(__a < __b); }

  template<typename _Tp>
    inline bool
    operator>=(const shared_ptr<_Tp>& __a, nullptr_t) noexcept
    { return !(__a < nullptr); }

  template<typename _Tp>
    inline bool
    operator>=(nullptr_t, const shared_ptr<_Tp>& __a) noexcept
    { return !(nullptr < __a); }

  template<typename _Tp>
    struct less<shared_ptr<_Tp>> : public _Sp_less<shared_ptr<_Tp>>
    { };


  template<typename _Tp>
    inline void
    swap(shared_ptr<_Tp>& __a, shared_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }


  template<typename _Tp, typename _Tp1>
    inline shared_ptr<_Tp>
    static_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept
    { return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get())); }

  template<typename _Tp, typename _Tp1>
    inline shared_ptr<_Tp>
    const_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept
    { return shared_ptr<_Tp>(__r, const_cast<_Tp*>(__r.get())); }

  template<typename _Tp, typename _Tp1>
    inline shared_ptr<_Tp>
    dynamic_pointer_cast(const shared_ptr<_Tp1>& __r) noexcept
    {
      if (_Tp* __p = dynamic_cast<_Tp*>(__r.get()))
 return shared_ptr<_Tp>(__r, __p);
      return shared_ptr<_Tp>();
    }







  template<typename _Tp>
    class weak_ptr : public __weak_ptr<_Tp>
    {
    public:
      constexpr weak_ptr() noexcept
      : __weak_ptr<_Tp>() { }

      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
 weak_ptr(const weak_ptr<_Tp1>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      template<typename _Tp1, typename = typename
        std::enable_if<std::is_convertible<_Tp1*, _Tp*>::value>::type>
 weak_ptr(const shared_ptr<_Tp1>& __r) noexcept
 : __weak_ptr<_Tp>(__r) { }

      template<typename _Tp1>
 weak_ptr&
 operator=(const weak_ptr<_Tp1>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      template<typename _Tp1>
 weak_ptr&
 operator=(const shared_ptr<_Tp1>& __r) noexcept
 {
   this->__weak_ptr<_Tp>::operator=(__r);
   return *this;
 }

      shared_ptr<_Tp>
      lock() const noexcept
      { return shared_ptr<_Tp>(*this, std::nothrow); }
    };


  template<typename _Tp>
    inline void
    swap(weak_ptr<_Tp>& __a, weak_ptr<_Tp>& __b) noexcept
    { __a.swap(__b); }



  template<typename _Tp>
    struct owner_less;


  template<typename _Tp>
    struct owner_less<shared_ptr<_Tp>>
    : public _Sp_owner_less<shared_ptr<_Tp>, weak_ptr<_Tp>>
    { };


  template<typename _Tp>
    struct owner_less<weak_ptr<_Tp>>
    : public _Sp_owner_less<weak_ptr<_Tp>, shared_ptr<_Tp>>
    { };




  template<typename _Tp>
    class enable_shared_from_this
    {
    protected:
      constexpr enable_shared_from_this() noexcept { }

      enable_shared_from_this(const enable_shared_from_this&) noexcept { }

      enable_shared_from_this&
      operator=(const enable_shared_from_this&) noexcept
      { return *this; }

      ~enable_shared_from_this() { }

    public:
      shared_ptr<_Tp>
      shared_from_this()
      { return shared_ptr<_Tp>(this->_M_weak_this); }

      shared_ptr<const _Tp>
      shared_from_this() const
      { return shared_ptr<const _Tp>(this->_M_weak_this); }

    private:
      template<typename _Tp1>
 void
 _M_weak_assign(_Tp1* __p, const __shared_count<>& __n) const noexcept
 { _M_weak_this._M_assign(__p, __n); }

      template<typename _Tp1>
 friend void
 __enable_shared_from_this_helper(const __shared_count<>& __pn,
      const enable_shared_from_this* __pe,
      const _Tp1* __px) noexcept
 {
   if (__pe != 0)
     __pe->_M_weak_assign(const_cast<_Tp1*>(__px), __pn);
 }

      mutable weak_ptr<_Tp> _M_weak_this;
    };
# 583 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr.h" 3
  template<typename _Tp, typename _Alloc, typename... _Args>
    inline shared_ptr<_Tp>
    allocate_shared(const _Alloc& __a, _Args&&... __args)
    {
      return shared_ptr<_Tp>(_Sp_make_shared_tag(), __a,
        std::forward<_Args>(__args)...);
    }
# 598 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/bits/shared_ptr.h" 3
  template<typename _Tp, typename... _Args>
    inline shared_ptr<_Tp>
    make_shared(_Args&&... __args)
    {
      typedef typename std::remove_const<_Tp>::type _Tp_nc;
      return std::allocate_shared<_Tp>(std::allocator<_Tp_nc>(),
           std::forward<_Args>(__args)...);
    }


  template<typename _Tp>
    struct hash<shared_ptr<_Tp>>
    : public __hash_base<size_t, shared_ptr<_Tp>>
    {
      size_t
      operator()(const shared_ptr<_Tp>& __s) const noexcept
      { return std::hash<_Tp*>()(__s.get()); }
    };




}
# 83 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/memory" 2 3

# 1 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/auto_ptr.h" 1 3
# 36 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/auto_ptr.h" 3
namespace std __attribute__ ((__visibility__ ("default")))
{

# 47 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/auto_ptr.h" 3
  template<typename _Tp1>
    struct auto_ptr_ref
    {
      _Tp1* _M_ptr;

      explicit
      auto_ptr_ref(_Tp1* __p): _M_ptr(__p) { }
    } __attribute__ ((__deprecated__));
# 86 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/auto_ptr.h" 3
  template<typename _Tp>
    class auto_ptr
    {
    private:
      _Tp* _M_ptr;

    public:

      typedef _Tp element_type;







      explicit
      auto_ptr(element_type* __p = 0) throw() : _M_ptr(__p) { }
# 112 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr& __a) throw() : _M_ptr(__a.release()) { }
# 124 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr(auto_ptr<_Tp1>& __a) throw() : _M_ptr(__a.release()) { }
# 135 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/auto_ptr.h" 3
      auto_ptr&
      operator=(auto_ptr& __a) throw()
      {
 reset(__a.release());
 return *this;
      }
# 152 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/auto_ptr.h" 3
      template<typename _Tp1>
        auto_ptr&
        operator=(auto_ptr<_Tp1>& __a) throw()
        {
   reset(__a.release());
   return *this;
 }
# 170 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/auto_ptr.h" 3
      ~auto_ptr() { delete _M_ptr; }
# 180 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/auto_ptr.h" 3
      element_type&
      operator*() const throw()
      {
 ;
 return *_M_ptr;
      }







      element_type*
      operator->() const throw()
      {
 ;
 return _M_ptr;
      }
# 210 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/auto_ptr.h" 3
      element_type*
      get() const throw() { return _M_ptr; }
# 224 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/auto_ptr.h" 3
      element_type*
      release() throw()
      {
 element_type* __tmp = _M_ptr;
 _M_ptr = 0;
 return __tmp;
      }
# 239 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/auto_ptr.h" 3
      void
      reset(element_type* __p = 0) throw()
      {
 if (__p != _M_ptr)
   {
     delete _M_ptr;
     _M_ptr = __p;
   }
      }
# 260 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/backward/auto_ptr.h" 3
      auto_ptr(auto_ptr_ref<element_type> __ref) throw()
      : _M_ptr(__ref._M_ptr) { }

      auto_ptr&
      operator=(auto_ptr_ref<element_type> __ref) throw()
      {
 if (__ref._M_ptr != this->get())
   {
     delete _M_ptr;
     _M_ptr = __ref._M_ptr;
   }
 return *this;
      }

      template<typename _Tp1>
        operator auto_ptr_ref<_Tp1>() throw()
        { return auto_ptr_ref<_Tp1>(this->release()); }

      template<typename _Tp1>
        operator auto_ptr<_Tp1>() throw()
        { return auto_ptr<_Tp1>(this->release()); }
    } __attribute__ ((__deprecated__));



  template<>
    class auto_ptr<void>
    {
    public:
      typedef void element_type;
    } __attribute__ ((__deprecated__));


  template<_Lock_policy _Lp>
  template<typename _Tp>
    inline
    __shared_count<_Lp>::__shared_count(std::auto_ptr<_Tp>&& __r)
    : _M_pi(new _Sp_counted_ptr<_Tp*, _Lp>(__r.get()))
    { __r.release(); }

  template<typename _Tp, _Lock_policy _Lp>
  template<typename _Tp1>
    inline
    __shared_ptr<_Tp, _Lp>::__shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : _M_ptr(__r.get()), _M_refcount()
    {
     
      static_assert( sizeof(_Tp1) > 0, "incomplete type" );
      _Tp1* __tmp = __r.get();
      _M_refcount = __shared_count<_Lp>(std::move(__r));
      __enable_shared_from_this_helper(_M_refcount, __tmp, __tmp);
    }

  template<typename _Tp>
  template<typename _Tp1>
    inline
    shared_ptr<_Tp>::shared_ptr(std::auto_ptr<_Tp1>&& __r)
    : __shared_ptr<_Tp>(std::move(__r)) { }

  template<typename _Tp, typename _Dp>
  template<typename _Up, typename>
    inline
    unique_ptr<_Tp, _Dp>::unique_ptr(auto_ptr<_Up>&& __u) noexcept
    : _M_t(__u.release(), deleter_type()) { }



}
# 85 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/memory" 2 3
# 41 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/thread" 2 3






namespace std __attribute__ ((__visibility__ ("default")))
{

# 60 "C:\\ndk/sources/cxx-stl/gnu-libstdc++/4.9/include/thread" 3
  class thread
  {
  public:
    typedef __gthread_t native_handle_type;
    struct _Impl_base;
    typedef shared_ptr<_Impl_base> __shared_base_type;


    class id
    {
      native_handle_type _M_thread;

    public:
      id() noexcept : _M_thread() { }

      explicit
      id(native_handle_type __id) : _M_thread(__id) { }

    private:
      friend class thread;
      friend class hash<thread::id>;

      friend bool
      operator==(thread::id __x, thread::id __y) noexcept
      { return __gthread_equal(__x._M_thread, __y._M_thread); }

      friend bool
      operator<(thread::id __x, thread::id __y) noexcept
      { return __x._M_thread < __y._M_thread; }

      template<class _CharT, class _Traits>
 friend basic_ostream<_CharT, _Traits>&
 operator<<(basic_ostream<_CharT, _Traits>& __out, thread::id __id);
    };



    struct _Impl_base
    {
      __shared_base_type _M_this_ptr;

      inline virtual ~_Impl_base();

      virtual void _M_run() = 0;
    };

    template<typename _Callable>
      struct _Impl : public _Impl_base
      {
 _Callable _M_func;

 _Impl(_Callable&& __f) : _M_func(std::forward<_Callable>(__f))
 { }

 void
 _M_run() { _M_func(); }
      };

  private:
    id _M_id;

  public:
    thread() noexcept = default;


    thread(thread&) = delete;
    thread(const thread&) = delete;

    thread(thread&& __t) noexcept
    { swap(__t); }

    template<typename _Callable, typename... _Args>
      explicit
      thread(_Callable&& __f, _Args&&... __args)
      {
        _M_start_thread(_M_make_routine(std::__bind_simple(
                std::forward<_Callable>(__f),
                std::forward<_Args>(__args)...)));
      }

    ~thread()
    {
      if (joinable())
 std::terminate();
    }

    thread& operator=(const thread&) = delete;

    thread& operator=(thread&& __t) noexcept
    {
      if (joinable())
 std::terminate();
      swap(__t);
      return *this;
    }

    void
    swap(thread& __t) noexcept
    { std::swap(_M_id, __t._M_id); }

    bool
    joinable() const noexcept
    { return !(_M_id == id()); }

    void
    join();

    void
    detach();

    thread::id
    get_id() const noexcept
    { return _M_id; }



    native_handle_type
    native_handle()
    { return _M_id._M_thread; }


    static unsigned int
    hardware_concurrency() noexcept;

  private:
    void
    _M_start_thread(__shared_base_type);

    template<typename _Callable>
      shared_ptr<_Impl<_Callable>>
      _M_make_routine(_Callable&& __f)
      {

 return std::make_shared<_Impl<_Callable>>(std::forward<_Callable>(__f));
      }
  };

  inline thread::_Impl_base::~_Impl_base() = default;

  inline void
  swap(thread& __x, thread& __y) noexcept
  { __x.swap(__y); }

  inline bool
  operator!=(thread::id __x, thread::id __y) noexcept
  { return !(__x == __y); }

  inline bool
  operator<=(thread::id __x, thread::id __y) noexcept
  { return !(__y < __x); }

  inline bool
  operator>(thread::id __x, thread::id __y) noexcept
  { return __y < __x; }

  inline bool
  operator>=(thread::id __x, thread::id __y) noexcept
  { return !(__x < __y); }



  template<>
    struct hash<thread::id>
    : public __hash_base<size_t, thread::id>
    {
      size_t
      operator()(const thread::id& __id) const noexcept
      { return std::_Hash_impl::hash(__id._M_thread); }
    };

  template<class _CharT, class _Traits>
    inline basic_ostream<_CharT, _Traits>&
    operator<<(basic_ostream<_CharT, _Traits>& __out, thread::id __id)
    {
      if (__id == thread::id())
 return __out << "thread::id of a non-executing thread";
      else
 return __out << __id._M_thread;
    }







  namespace this_thread
  {
 


    inline thread::id
    get_id() noexcept { return thread::id(__gthread_self()); }


    inline void
    yield() noexcept
    {

      __gthread_yield();

    }

    void
    __sleep_for(chrono::seconds, chrono::nanoseconds);


    template<typename _Rep, typename _Period>
      inline void
      sleep_for(const chrono::duration<_Rep, _Period>& __rtime)
      {
 auto __s = chrono::duration_cast<chrono::seconds>(__rtime);
 auto __ns = chrono::duration_cast<chrono::nanoseconds>(__rtime - __s);

 __gthread_time_t __ts =
   {
     static_cast<std::time_t>(__s.count()),
     static_cast<long>(__ns.count())
   };
 ::nanosleep(&__ts, 0);



      }


    template<typename _Clock, typename _Duration>
      inline void
      sleep_until(const chrono::time_point<_Clock, _Duration>& __atime)
      { sleep_for(__atime - _Clock::now()); }

 
  }



}
# 14 "../Quadris/Engine.h" 2

# 1 "../Quadris/Math.hpp" 1





struct Size
{
 Size()
 :W(0)
 ,H(0)
 {

 }

 Size(float w, float h)
 :W(w)
 ,H(h)
 {

 }
 float W;
 float H;
};

template <class T>
struct Point
{
 T X;
 T Y;
 Point() = default;

 Point(T x, T y)
  : X(x)
  , Y(y)
 {

 }
};

typedef Point<int32_t> IPoint;
typedef Point<int16_t> SPoint;
typedef Point<float> FPoint;

struct QuadSize
{
 uint16_t W;
 uint16_t H;
};


struct Color32
{
 uint8_t R;
 uint8_t G;
 uint8_t B;
 uint8_t A;
};

struct Vertex
{

};

struct ColorVertex2D
 :public Vertex
{
 Color32 color;
 float X, Y;
};

struct SmallTexVertex2D
 :public Vertex
{
 int16_t U, V;
 float X, Y;
};

struct SizeOffsetPointer
{
 uint32_t Size;
 uint32_t Offset;
};
# 16 "../Quadris/Engine.h" 2
# 1 "../Quadris/Renderer.h" 1




# 1 "../Quadris/GeometryPointer.hpp" 1





class GemeotryPointer
{
 friend class Engine;

public:
 GemeotryPointer()
  :glBufferVertex(0)
  , glBufferIndices(0)
 {

 }
 ~GemeotryPointer();
 enum States
 {
  NONE = 0x000
  , VERTEX = 0X001
  , COLOR = 0X002
  , TEXTURE = 0x004
 };

 uint8_t mode;
 uint8_t states;
 uint8_t vertexOffset;
 uint8_t colorOffset;
 uint8_t textureOffset;
 uint8_t stride;
 uint32_t glBufferVertex;
 uint32_t glBufferIndices;
 size_t size;
};
# 6 "../Quadris/Renderer.h" 2

class VertexRenderer
{
public:
 virtual void Init(){}
 virtual void ReplaceModelViewMatrix(float*){}
 virtual void ReplaceTextureMatrix(float* m){}
 virtual void RenderGeometry(GemeotryPointer*, int size, int ofsset){}
 virtual void RenderGeometry(GemeotryPointer* p)
 {
  RenderGeometry(p, -1, -1);
 }
 virtual GemeotryPointer* BuildGeometry(ColorVertex2D* buffer, size_t n,
  uint16_t* indices, size_t nidx)
 {
  return nullptr;
 }

 virtual GemeotryPointer* BuildGeometry(SmallTexVertex2D* buffer, size_t n,
  uint16_t* indices, size_t nidx)
 {
  return nullptr;
 }
};
# 17 "../Quadris/Engine.h" 2
# 1 "../Quadris/FixedPipeline.h" 1





class FixedPipeline
 :public VertexRenderer
{
public:
 FixedPipeline();
 virtual ~FixedPipeline();
 virtual void Init();
 virtual void ReplaceModelViewMatrix(float*);
 virtual void ReplaceTextureMatrix(float* m);
 virtual void RenderGeometry(GemeotryPointer*, int, int);
 virtual GemeotryPointer* BuildGeometry(ColorVertex2D* buffer, size_t n,
  uint16_t* indices, size_t nidx);
 virtual GemeotryPointer* BuildGeometry(SmallTexVertex2D* buffer, size_t n,
  uint16_t* indices, size_t nidx);
private:
 void BuildGeneralGeometry(GemeotryPointer*p,
  size_t n, uint16_t* indices, size_t nidx);

 uint32_t m_lastIndexBuffer;
 uint32_t m_lastVertexBuffer;
 uint8_t m_lastState;
};
# 18 "../Quadris/Engine.h" 2
# 1 "../Quadris/Model2D.h" 1







class Model2D
{
public:
 friend class SimpleGeometry;

 typedef void(*TransformGeometryFunc)(Vertex*);

 enum Type : uint16_t
 {
  RGBA2D = 0x1001
  , SMALLTEX2D = 0x1002
 };

 Model2D();
 Model2D(const Model2D&);
 Model2D(Model2D&&);

 Model2D operator + (const Model2D& x);
 Model2D& operator = (const Model2D& x);
 Model2D& operator = (Model2D&& x);

 ~Model2D();
 bool Load(const char* filename);
 GemeotryPointer* BuildGeometry();
 void TransformGeometry(TransformGeometryFunc func)
 {
  uintptr_t ptr = reinterpret_cast<uintptr_t>(m_Data);
  uintptr_t inc = 0;
  switch (m_Type)
  {
  case RGBA2D:
   inc = sizeof(ColorVertex2D);
  case SMALLTEX2D:
   inc = sizeof(SmallTexVertex2D);
   break;
  }

  for (uint32_t i = 0; i < m_DataCount; i++)
  {
   uintptr_t p = ptr + inc*i;
   func(reinterpret_cast<Vertex*>(p));
  }
 }

 Type GetType() const
 {
  return m_Type;
 }


 uint32_t IndexCount()
 {
  return m_IdxCount * 3;
 }

private:
 void CopyData(const Model2D* data);

 Vertex* m_Data;
 uint16_t* m_Indices;
 uint32_t m_DataCount;
 uint32_t m_IdxCount;
 Type m_Type;
};
# 19 "../Quadris/Engine.h" 2
# 1 "../Quadris/StringManager.h" 1






class StringManager
{
public:
 StringManager();
 const std::string& ReturnString(const char* idx);
private:
 typedef std::unordered_map<std::string, std::string> Values;
 typedef std::pair<std::string, std::string> Pair;

 Values m_values;
};
# 20 "../Quadris/Engine.h" 2

class SimpleGeometry;

class Engine
{
public:

 typedef std::function<bool()> TaskCallback;
 typedef std::list <TaskCallback> TaskList;
 typedef TaskList::iterator TaskListI;

 typedef std::function<void()> HandlerCallback;
 typedef std::list <HandlerCallback> HandlerList;
 typedef HandlerList::iterator HandlerListI;

 typedef std::list <std::thread*> WaitThreadsList;
 typedef WaitThreadsList::iterator WaitThreadsListI;

 typedef std::chrono::high_resolution_clock HighResClock;
 typedef std::chrono::high_resolution_clock::duration Duration;
 typedef std::chrono::high_resolution_clock::time_point Time;

 Engine();
 ~Engine();


 static void AssignInstance(Engine* s)
 {
  s_Instance = s;
 }
 static Engine& Instance()
 {
  return *s_Instance;
 }
 static bool HasInstance()
 {
  return s_Instance != nullptr;
 }


 StringManager& GetStringManager()
 {
  return m_stringManager;
 }
 VertexRenderer* GetRenderer()
 {
  return m_renderer;
 }
 bool EngineVersion20()
 {
  return m_20Ready;
 }
 int MaxTextureSize()
 {
  return m_maxTextureSize;
 }
 double LastMeasureFPS()
 {
  return m_fps;
 }

 double AverageFPS()
 {
  return m_normalAverageFPS;
 }
 bool IsClosing()
 {
  return m_isClosing;
 }


 void AddAfterRenderTask(TaskCallback callback)
 {
  m_AfterRenderTaskList.push_back(callback);
 }
 void AddBeforeRenderTask(TaskCallback callback)
 {
  m_BeforeRenderTaskList.push_back(callback);
 }
 void AddRenderTask(TaskCallback callback)
 {
  m_RenderTaskList.push_back(callback);
 }
 void PrepareLoad(TaskList& loadtasks);
 void SetLoadingRender(HandlerCallback render)
 {
  m_loadingRender = render;
 }
 void AddWaitThread(std::thread* thread)
 {
  m_waitingThreads.push_back(thread);
 }







 void LogInformation(const char* string, ...){}
 void LogWarning(const char* string, ...){}
 void LogError(const char* string, ...){}
 void LogError(const char* string, va_list){}



 enum class FileSeekPos
 {
  CUR
  ,START
  ,END
 };
 struct FileDescriptor;
 static FileDescriptor* OpenFileBinary(const char* file);
 static size_t ReadFile(FileDescriptor* f, size_t unit, size_t count, void* buffer);
 static size_t FileSeek(FileDescriptor* f, size_t offset, FileSeekPos pos = FileSeekPos::END);
 static size_t FileSize(FileDescriptor* f);
 static void CloseFile(FileDescriptor*);


 void Close();
 void NativeClose();
 void ReloadContex();
 bool MainLoop();
 void SendTouch(int x, int y);

 void AddOnLoadHandle(HandlerCallback callback)
 {
  m_onLoadHandlers.push_back(callback);
 }
 void AddOnTouchHandle(HandlerCallback callback)
 {
  m_onTouchHandlers.push_back(callback);
 }
 void AddOnReloadHandle(HandlerCallback callback)
 {
  m_onReloadHandlers.push_back(callback);
 }
 SPoint GetTouchPoint()
 {
  return m_touchPoint;
 }
 const Size& GetWindowSize()
 {
  return m_WindowSize;
 }
 void SetWindowSize(const Size& s)
 {
  m_WindowSize = s;
 }


 void UserError(const char* error, ...)
 {
  va_list ap;
  __builtin_va_start(ap,error);
  LogError(error, ap);
 }
private:
 void EarlyInit();

 void AsyncInit(TaskList&);
 bool InitStageOne();
 bool InitStageTwo();

private:

 static Engine* s_Instance;
 int m_asynInitStage;
 VertexRenderer* m_renderer;
 StringManager m_stringManager;
 bool m_isClosing;
 WaitThreadsList m_waitingThreads;

 Size m_WindowSize;
 TaskList m_AfterRenderTaskList;
 TaskList m_BeforeRenderTaskList;
 TaskList m_RenderTaskList;
 HandlerList m_onLoadHandlers;
 HandlerList m_onReloadHandlers;
 HandlerList m_onTouchHandlers;
 HandlerCallback m_loadingRender;
 SPoint m_touchPoint;

 const unsigned char* m_OpenGLVendor;
 const unsigned char* m_OpenGLDriver;
 const unsigned char* m_OpenGLVersion;
 const unsigned char* m_OpenGLExtensions;
 bool m_20Ready;
 int m_maxTextureSize;

 double m_fps;
 double m_normalAverageFPS;
 Time m_lastTime;
 HighResClock m_clock;

};
# 18 "../Quadris/Font.cpp" 2
# 1 "../Quadris/Font.h" 1
# 10 "../Quadris/Font.h"
class FontManager;
class Image;

class Font
{
public:
 friend class FontManager;

 Font();
 Font(const Font&) = delete;
 Font(Font&&);

 Font& operator = (const Font&) = delete;
 Font& operator = (Font&&);

 operator bool()
 {
  return m_freetypeFace != nullptr;
 }

 ~Font();

 void SetSize(size_t h);
 void BufferChar(uint16_t c);
 void LoadVideoMemory(bool clear = false);
 void DrawString(const std::string& utf8string);
 void SetCursor(float _x, float _y)
 {
  m_curX = _x;
  m_curY = _y;
 }
protected:
 Font(void* face);
private:

 struct Glyph
 {
  uint8_t* buffer;
  uint16_t width;
  uint16_t height;
  uint16_t pitch;
  int16_t advance;
  int16_t X;
  int16_t Y;
  uint16_t charchode;
  uint16_t texX;
  uint16_t texY;
 };

 typedef std::pair<uint16_t, Glyph> GlyphPair;
 typedef std::unordered_map<uint16_t, Glyph> GlyhpMap;

 void* m_freetypeFace;
 GemeotryPointer* m_geom;
 size_t m_height;
 GlyhpMap m_glyphMap;
 size_t m_area;
 unsigned int m_glTexAtlas;
 float m_curX;
 float m_curY;
 float m_atlasSize;
};
# 19 "../Quadris/Font.cpp" 2
# 1 "../Quadris/Image.h" 1






class Image
{
public:

 Image();
 ~Image();

 Image(const Image&) = delete;
 Image(Image&&) = delete;

 Image operator = (const Image&) = delete;

 enum Type
 {
  NONE
  , RGB
  , BGR
  , RGBA
  , BGRA
  , MONO
 };

 static Image* LoadFromPath(const char* path);
 static Image* LoadFromStringName(const char* stringidx)
 {
  return LoadFromPath(Engine::Instance().GetStringManager()
   .ReturnString(stringidx).c_str());
 }
 static Image* LoadFromMemory(uint8_t* bytes, size_t pitch, size_t w, size_t h);

 void LoadVideoMemory(bool);
 void LoadVideoMemory()
 {
  LoadVideoMemory(false);
 }
 void Bind();

private:
 static bool LoadPNG(uint8_t* mem, Image& desc, size_t);

 uint8_t* m_pixelData;
 int m_width;
 int m_height;
 int m_stride;
 int m_bpp;
 Type m_type;
 uint32_t m_glPointer;
};
# 20 "../Quadris/Font.cpp" 2
# 1 "../Quadris/SimpleGeometry.hpp" 1






class SimpleGeometry
{
public:
 static Model2D TextureSquare()
 {
  static_assert(sizeof(SmallTexVertex2D) == 12, "Must be 12");

  Model2D model;
  model.m_Type = Model2D::SMALLTEX2D;
  model.m_Data = new SmallTexVertex2D[4];
  model.m_DataCount = 4;

  SmallTexVertex2D* datap = static_cast<SmallTexVertex2D*>(model.m_Data);
  datap[0].X = 0.0f;
  datap[0].Y = 0.0f;
  datap[0].U = 0;
  datap[0].V = 0;
  datap[1].X = 1.0f;
  datap[1].Y = 0.0f;
  datap[1].U = 1;
  datap[1].V = 0;
  datap[2].X = 0.0f;
  datap[2].Y = 1.0f;
  datap[2].U = 0;
  datap[2].V = 1;
  datap[3].X = 1.0f;
  datap[3].Y = 1.0f;
  datap[3].U = 1;
  datap[3].V = 1;
  model.m_Indices = new uint16_t[6];
  model.m_IdxCount = 2;
  model.m_Indices[0] = 0;
  model.m_Indices[1] = 1;
  model.m_Indices[2] = 2;
  model.m_Indices[3] = 1;
  model.m_Indices[4] = 2;
  model.m_Indices[5] = 3;

  return model;
 }
};
# 21 "../Quadris/Font.cpp" 2
# 33 "../Quadris/Font.cpp"
Font::Font()
 :m_freetypeFace(nullptr)
{
}

Font::Font(void* face)
: m_freetypeFace(face)
{


}

Font::Font(Font&& x)
 :m_freetypeFace(x.m_freetypeFace)
{
 x.m_freetypeFace = 0;
}

Font& Font::operator = (Font&& x)
{
 void* tmp = x.m_freetypeFace;
 m_freetypeFace = x.m_freetypeFace;
 x.m_freetypeFace = tmp;
 return *this;
}

Font::~Font()
{
}


void Font::SetSize(size_t h)
{
 ((m_freetypeFace) ? (void)0 : __assert2("../Quadris/Font.cpp", 66, __PRETTY_FUNCTION__, "m_freetypeFace"));
 FT_Face face = static_cast<FT_Face>(m_freetypeFace);
 FT_Set_Pixel_Sizes(face, 0, h);
 m_height = h;
}

void Font::BufferChar(uint16_t c)
{
 ((m_freetypeFace) ? (void)0 : __assert2("../Quadris/Font.cpp", 74, __PRETTY_FUNCTION__, "m_freetypeFace"));
 ((m_glyphMap.find(c) == m_glyphMap.end()) ? (void)0 : __assert2("../Quadris/Font.cpp", 75, __PRETTY_FUNCTION__, "m_glyphMap.find(c) == m_glyphMap.end()"));
 FT_Face face = static_cast<FT_Face>(m_freetypeFace);
 auto index = FT_Get_Char_Index(face, c);
 FT_Load_Glyph(face, index, 0);
 auto error = FT_Render_Glyph(face->glyph
  , FT_Render_Mode_::FT_RENDER_MODE_NORMAL);
 if (error)
 {
  Engine::Instance().LogWarning("Font could not be buffered");
  return;
 }

 auto& g = m_glyphMap[c];
 size_t s = face->glyph->bitmap.pitch*face->glyph->bitmap.rows;
 g.height = face->glyph->bitmap.rows;
 g.width = face->glyph->bitmap.width;
 g.pitch = face->glyph->bitmap.pitch;
 g.charchode = c;
 g.advance = (uint16_t)(face->glyph->advance.x >> 6);
 g.X = face->glyph->bitmap_left;
 g.Y = face->glyph->bitmap_top;

 if (face->glyph->bitmap.buffer)
 {
  g.buffer = new uint8_t[s];
  memcpy(g.buffer, face->glyph->bitmap.buffer, s);
 }

 m_area += g.height*g.width;
}

void Font::LoadVideoMemory(bool clear)
{
 if (!this)
  return;

 Model2D model = SimpleGeometry::TextureSquare();
 m_geom = model.BuildGeometry();

 double f = (double)m_area;
 f = sqrt(f);
 int exp;
 if (frexp(f, &exp) != 0.5) {
  f = ldexp(1.0, exp);
 }

 size_t size = (size_t)f;
 size_t max = Engine::Instance().MaxTextureSize();
 if (size > max)
 {
  Engine::Instance().LogWarning("Font atlas too big");
  return;
 }
 m_atlasSize = (float)f;

 glEnable(0x0DE1);
 glGenTextures(1, &m_glTexAtlas);
 ;
 int lastbinding;
 glGetIntegerv(0x8069, &lastbinding);
 glBindTexture(0x0DE1, m_glTexAtlas);

 glTexParameteri(0x0DE1, 0x2800, 0x2600);
 glTexParameteri(0x0DE1, 0x2801, 0x2600);
 glTexImage2D(0x0DE1, 0, 0x1906, size, size, 0, 0x1906,
  0x1401, 0);
 ;
 size_t xof = 0;
 size_t yof = 0;
 int biggest = std::numeric_limits<int>::min();
 for (auto& g : m_glyphMap)
 {
  auto& gl = g.second;
  if (gl.buffer)
  {
   if (xof + gl.width > size)
   {
    xof = 0;
    yof += biggest;
    biggest = std::numeric_limits<int>::min();
   }

   gl.texX = xof;
   gl.texY = yof;
   glTexSubImage2D(0x0DE1, 0, xof, yof, gl.width, gl.height
    , 0x1906, 0x1401, gl.buffer);
   if (gl.height > biggest)
    biggest = gl.height;

   xof += gl.width;
   if (clear)
    delete[] gl.buffer;
  }
 }

 ;
 glBindTexture(0x0DE1, lastbinding);

}

void Font::DrawString(const std::string& s)
{
 if (!this)
  return;

 glBindTexture(0x0DE1, m_glTexAtlas);

 for (auto c : s)
 {
  if (m_glyphMap.find((uint16_t)c) != m_glyphMap.end())
  {
   auto gp = m_glyphMap[(uint16_t)c];
   float tp = 1.0f / m_atlasSize;
   auto trans = glm::translate(glm::vec3(m_curX+gp.X, m_curY-gp.Y, 0.0f));
   trans = glm::scale(trans, glm::vec3(gp.width, gp.height, 0.0f));


   auto tex = glm::translate(glm::vec3(tp*gp.texX, tp*gp.texY, 0.0f));
   tex = glm::scale(tex, glm::vec3(tp*gp.width, tp*gp.height, 1.0f));
   Engine::Instance().GetRenderer()->ReplaceTextureMatrix(&tex[0][0]);
   Engine::Instance().GetRenderer()->ReplaceModelViewMatrix(&trans[0][0]);

   Engine::Instance().GetRenderer()->RenderGeometry(m_geom);
   m_curX += gp.advance+1;
  }
 }
# 211 "../Quadris/Font.cpp"
}
